# Entry Points Analysis

> Generated by entry-point-analyzer for docker/docker-cli

## Entry Point Summary

```
Application Type: CLI
Primary Entry: cmd/docker/docker.go::main()
Command Registration: Init-time via internal/commands registry
Feature Entry Points:
  - cli/command/container/run.go::newRunCommand()
  - cli/command/container/create.go::newCreateCommand()
Shared Options Entry: cli/command/container/opts.go::addFlags()
```

## Primary Entry Point

### main() - Application Bootstrap
- **File**: `cmd/docker/docker.go:37-49`
- **Type**: CLI main entry
- **Invocation**: Direct binary execution (`docker [COMMAND]`)
- **Purpose**: Bootstraps the Docker CLI, sets up signal handling, and delegates to `dockerMain()`

```go
func main() {
    err := dockerMain(context.Background())
    if errors.As(err, &errCtxSignalTerminated{}) {
        os.Exit(getExitCode(err))
    }
    if err != nil && !errdefs.IsCanceled(err) {
        if err.Error() != "" {
            _, _ = fmt.Fprintln(os.Stderr, err)
        }
        os.Exit(getExitCode(err))
    }
}
```

### dockerMain() - CLI Initialization
- **File**: `cmd/docker/docker.go:77-89`
- **Type**: Main initialization function
- **Purpose**: Creates DockerCli instance, sets up logging, and runs the command

```go
func dockerMain(ctx context.Context) error {
    ctx, cancelNotify := notifyContext(ctx, platformsignals.TerminationSignals...)
    defer cancelNotify()

    dockerCli, err := command.NewDockerCli(command.WithBaseContext(ctx))
    if err != nil {
        return err
    }
    logrus.SetOutput(dockerCli.Err())
    otel.SetErrorHandler(debug.OTELErrorHandler)

    return runDocker(ctx, dockerCli)
}
```

### newDockerCommand() - Root Command Construction
- **File**: `cmd/docker/docker.go:117-174`
- **Type**: Cobra command factory
- **Purpose**: Constructs the root `docker` command and registers all subcommands

**Key steps**:
1. Creates root cobra.Command with global flags
2. Sets up help and completion
3. Calls `commands.AddCommands(cmd, dockerCli)` to register all subcommands
4. Returns wrapped TopLevelCommand

## Initialization Sequence

```
1. main() (cmd/docker/docker.go:37)
   └─ Sets up process-level error handling

2. dockerMain() (cmd/docker/docker.go:77)
   └─ Creates signal context
   └─ Initializes DockerCli (command.NewDockerCli)
   └─ Configures logging

3. runDocker() (called from dockerMain)
   └─ Calls newDockerCommand()

4. newDockerCommand() (cmd/docker/docker.go:117)
   └─ Creates root cobra.Command
   └─ Sets up global flags (--context, --log-level, etc.)
   └─ Calls commands.AddCommands()

5. commands.AddCommands() (cli/command/commands/commands.go:26)
   └─ Imports all command packages (container, image, network, etc.)
   └─ Triggers init() functions via side-effect imports
   └─ Iterates registered commands and adds to root

6. Container command init() (cli/command/container/cmd.go:9)
   └─ Registers newRunCommand via commands.Register()
   └─ Registers newCreateCommand via commands.RegisterLegacy()
   └─ Registers other container commands

7. Command execution (when user runs 'docker run ...')
   └─ Cobra routing → newRunCommand → RunE closure
   └─ Calls runRun() with parsed flags
```

## Command Registration Flow

### Init-Time Registration Pattern

Docker CLI uses Go's `init()` function pattern for command registration:

**Step 1: Package Import Side-Effects**
```go
// cli/command/commands/commands.go:3-21
import (
    _ "github.com/docker/cli/cli/command/container"  // Triggers init()
    _ "github.com/docker/cli/cli/command/image"
    // ... other command packages
)
```

**Step 2: Command Package Init Function**
```go
// cli/command/container/cmd.go:9-34
func init() {
    commands.Register(newRunCommand)        // Top-level command
    commands.RegisterLegacy(newCreateCommand) // Hidden by default
    commands.RegisterLegacy(newAttachCommand)
    // ... 20+ more container commands
}
```

**Step 3: Registry Storage**
```go
// internal/commands/commands.go:14-16
var commands []func(command.Cli) *cobra.Command

func Register(f func(command.Cli) *cobra.Command) {
    commands = append(commands, f)
}
```

**Step 4: Deferred Command Construction**
```go
// cli/command/commands/commands.go:26-30
func AddCommands(cmd *cobra.Command, dockerCLI command.Cli) {
    for _, c := range commands.Commands() {
        cmd.AddCommand(c(dockerCLI))  // Lazy construction
    }
}
```

This pattern ensures:
- Commands are registered at import time
- Command instances are created lazily when needed
- Each command receives the initialized DockerCli instance
- No circular dependencies between command packages

## Feature Entry Points: Container Options Pattern

### Entry Point 1: newRunCommand()

**File**: `cli/command/container/run.go:32-84`

**Execution Flow**:
```
User: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
  ↓
Cobra routes to newRunCommand
  ↓
newRunCommand() constructs cobra.Command
  ├─ Declares runOptions (command-specific)
  ├─ Declares copts *containerOptions (shared)
  ├─ Sets up RunE closure
  ├─ Registers run-specific flags (--detach, --sig-proxy, etc.)
  └─ Calls addFlags(flags) → stores returned copts
```

**Command Construction Pattern**:
```go
func newRunCommand(dockerCLI command.Cli) *cobra.Command {
    var options runOptions           // Command-specific options
    var copts *containerOptions      // Shared container options (initially nil)

    cmd := &cobra.Command{
        Use:  "run [OPTIONS] IMAGE [COMMAND] [ARG...]",
        RunE: func(cmd *cobra.Command, args []string) error {
            copts.Image = args[0]    // Positional args stored in copts
            if len(args) > 1 {
                copts.Args = args[1:]
            }
            return runRun(cmd.Context(), dockerCLI, cmd.Flags(), &options, copts)
        },
    }

    flags := cmd.Flags()

    // Register run-specific flags
    flags.BoolVarP(&options.detach, "detach", "d", false, "...")
    flags.BoolVar(&options.sigProxy, "sig-proxy", true, "...")
    flags.StringVar(&options.name, "name", "", "...")
    flags.StringVar(&options.pull, "pull", PullImageMissing, "...")

    // Register ALL shared container flags
    copts = addFlags(flags)  // Returns initialized *containerOptions

    return cmd
}
```

**Key Observations**:
1. `copts` is declared as `*containerOptions` but not initialized
2. `addFlags(flags)` both registers flags AND returns the initialized struct
3. Positional arguments (IMAGE, COMMAND, ARG...) are stored in `copts.Image` and `copts.Args`
4. The RunE closure captures both `options` and `copts` by reference
5. Flag values are automatically populated by Cobra when user runs the command

### Entry Point 2: newCreateCommand()

**File**: `cli/command/container/create.go:47-95`

**Execution Flow**:
```
User: docker create [OPTIONS] IMAGE [COMMAND] [ARG...]
  ↓
Cobra routes to newCreateCommand
  ↓
newCreateCommand() constructs cobra.Command
  ├─ Declares createOptions (command-specific)
  ├─ Declares copts *containerOptions (shared)
  ├─ Sets up RunE closure
  ├─ Registers create-specific flags (--name, --platform, etc.)
  └─ Calls addFlags(flags) → stores returned copts
```

**Identical Pattern**:
```go
func newCreateCommand(dockerCLI command.Cli) *cobra.Command {
    var options createOptions        // Command-specific options
    var copts *containerOptions      // Shared container options

    cmd := &cobra.Command{
        Use:  "create [OPTIONS] IMAGE [COMMAND] [ARG...]",
        RunE: func(cmd *cobra.Command, args []string) error {
            copts.Image = args[0]
            if len(args) > 1 {
                copts.Args = args[1:]
            }
            return runCreate(cmd.Context(), dockerCLI, cmd.Flags(), &options, copts)
        },
    }

    flags := cmd.Flags()

    // Register create-specific flags (fewer than run)
    flags.StringVar(&options.name, "name", "", "...")
    flags.StringVar(&options.pull, "pull", PullImageMissing, "...")
    flags.StringVar(&options.platform, "platform", os.Getenv("DOCKER_DEFAULT_PLATFORM"), "...")

    // Register ALL shared container flags (same call)
    copts = addFlags(flags)

    return cmd
}
```

**Command-Specific Options Comparison**:

| Option | run | create | Notes |
|--------|-----|--------|-------|
| `name` | ✓ | ✓ | Container name |
| `platform` | ✓ | ✓ | Target platform |
| `pull` | ✓ | ✓ | Pull strategy |
| `quiet` | ✓ | ✓ | Suppress output |
| `detach` | ✓ | ✗ | Run in background (run-specific) |
| `sigProxy` | ✓ | ✗ | Signal proxying (run-specific) |
| `detachKeys` | ✓ | ✗ | Detach key sequence (run-specific) |

### Entry Point 3: addFlags() - Shared Flag Registration

**File**: `cli/command/container/opts.go:148-328`

**Purpose**: Single source of truth for registering 98 container-related flags

**Execution Flow**:
```
addFlags(flags *pflag.FlagSet) called from command constructor
  ↓
1. Allocate containerOptions struct
  ├─ Initialize all custom option types
  ├─ Attach validators to each option
  └─ 36 fields initialized with NewListOpts(), NewMapOpts(), etc.

2. Register flags with pflag.FlagSet
  ├─ 98 flag definitions
  ├─ Short flag aliases (-a, -e, -v, -p, -m, -c, etc.)
  ├─ API version annotations
  ├─ OS-type annotations (Windows-only flags)
  ├─ Deprecation markers
  └─ Flag aliases (--net vs --network)

3. Return initialized *containerOptions
```

**Structure**:
```go
func addFlags(flags *pflag.FlagSet) *containerOptions {
    // PHASE 1: Initialize containerOptions with validators
    copts := &containerOptions{
        // Repeatable flags with validators
        attach:    opts.NewListOpts(validateAttach),
        dns:       opts.NewListOpts(opts.ValidateIPAddress),
        env:       opts.NewListOpts(opts.ValidateEnv),
        labels:    opts.NewListOpts(opts.ValidateLabel),

        // Key-value maps with validators
        sysctls:   opts.NewMapOpts(nil, opts.ValidateSysctl),
        annotations: opts.NewMapOpts(nil, nil),

        // Complex types
        ulimits:   opts.NewUlimitOpt(nil),
        mounts:    opts.MountOpt{},
        netMode:   opts.NetworkOpt{},

        // Memory/CPU types with unit parsing
        memory:    opts.MemBytes{},
        cpus:      opts.NanoCPUs{},

        // ... 70+ more field initializations
    }

    // PHASE 2: Register flags (98 total)

    // General purpose flags
    flags.VarP(&copts.attach, "attach", "a", "Attach to STDIN, STDOUT or STDERR")
    flags.VarP(&copts.env, "env", "e", "Set environment variables")
    flags.VarP(&copts.labels, "label", "l", "Set meta data on a container")
    flags.VarP(&copts.volumes, "volume", "v", "Bind mount a volume")
    flags.VarP(&copts.publish, "publish", "p", "Publish a container's port(s)")

    // Security flags
    flags.Var(&copts.capAdd, "cap-add", "Add Linux capabilities")
    flags.Var(&copts.capDrop, "cap-drop", "Drop Linux capabilities")
    flags.BoolVar(&copts.privileged, "privileged", false, "Extended privileges")

    // Resource flags with typed values
    flags.VarP(&copts.memory, "memory", "m", "Memory limit")
    flags.Var(&copts.cpus, "cpus", "Number of CPUs")
    flags.Int64VarP(&copts.cpuShares, "cpu-shares", "c", 0, "CPU shares")

    // API version annotations (for newer flags)
    flags.Var(&copts.gpus, "gpus", "GPU devices to add")
    flags.SetAnnotation("gpus", "version", []string{"1.40"})

    flags.StringVar(&copts.cgroupnsMode, "cgroupns", "", "Cgroup namespace")
    flags.SetAnnotation("cgroupns", "version", []string{"1.41"})

    // Platform-specific flags
    flags.Int64Var(&copts.cpuCount, "cpu-count", 0, "CPU count (Windows only)")
    flags.SetAnnotation("cpu-count", "ostype", []string{"windows"})

    // Flag aliases (legacy compatibility)
    flags.Var(&copts.netMode, "net", "Connect to a network")
    flags.Var(&copts.netMode, "network", "Connect to a network")
    flags.MarkHidden("net")  // Hide legacy name

    // Deprecated flags (still functional, but warn users)
    var stub opts.MemBytes
    flags.Var(&stub, "kernel-memory", "Kernel memory limit (deprecated)")
    flags.MarkDeprecated("kernel-memory", "no longer supported by kernel")

    return copts  // Return initialized struct
}
```

**Flag Registration Features**:

1. **Custom Types**: Uses `flags.Var()` for types implementing `pflag.Value` interface
2. **Short Aliases**: Common flags have single-letter shortcuts (`-a`, `-e`, `-v`, `-p`, `-m`)
3. **Validators**: Injected at construction time, run during `flags.Parse()`
4. **Version Gating**: `SetAnnotation("version", ...)` enables runtime API version checks
5. **Platform Filtering**: `SetAnnotation("ostype", ...)` hides Windows-only flags on Linux
6. **Backward Compatibility**: Multiple flag names point to same field, older hidden
7. **Deprecation**: Flags marked deprecated show warnings but continue working

### Entry Point 4: Command Execution Functions

#### runRun() - Run Command Execution

**File**: `cli/command/container/run.go:86-117`

**Execution Flow**:
```
RunE closure invoked by Cobra
  ↓
runRun(ctx, dockerCLI, flags, runOptions, containerOptions)
  ├─ Validate pull option
  ├─ Configure proxy environment variables
  ├─ Ping daemon to get server OS
  ├─ Call parse(flags, copts, serverOS) → containerConfig
  └─ Call runContainer(ctx, dockerCLI, runOpts, copts, containerCfg)
```

**Code**:
```go
func runRun(ctx context.Context, dockerCLI command.Cli, flags *pflag.FlagSet,
    ropts *runOptions, copts *containerOptions) error {

    // Validate command-specific options
    if err := validatePullOpt(ropts.pull); err != nil {
        return cli.StatusError{Status: withHelp(err, "run").Error(), StatusCode: 125}
    }

    // Inject proxy config into environment
    proxyConfig := dockerCLI.ConfigFile().ParseProxyConfig(
        dockerCLI.Client().DaemonHost(),
        opts.ConvertKVStringsToMapWithNil(copts.env.GetSlice()),
    )
    newEnv := []string{}
    for k, v := range proxyConfig {
        if v == nil {
            newEnv = append(newEnv, k)
        } else {
            newEnv = append(newEnv, k+"="+*v)
        }
    }
    copts.env = *opts.NewListOptsRef(&newEnv, nil)

    // Get server info for platform-specific parsing
    serverInfo, err := dockerCLI.Client().Ping(ctx, client.PingOptions{})
    if err != nil {
        return err
    }

    // CRITICAL: Convert options to API types
    containerCfg, err := parse(flags, copts, serverInfo.OSType)
    if err != nil {
        return cli.StatusError{Status: withHelp(err, "run").Error(), StatusCode: 125}
    }

    // Execute container creation and attachment
    return runContainer(ctx, dockerCLI, ropts, copts, containerCfg)
}
```

#### runCreate() - Create Command Execution

**File**: `cli/command/container/create.go:97-132`

**Identical Pattern** (simpler than run):
```go
func runCreate(ctx context.Context, dockerCLI command.Cli, flags *pflag.FlagSet,
    options *createOptions, copts *containerOptions) error {

    if err := validatePullOpt(options.pull); err != nil {
        return cli.StatusError{Status: withHelp(err, "create").Error(), StatusCode: 125}
    }

    // Inject proxy config (same as runRun)
    proxyConfig := dockerCLI.ConfigFile().ParseProxyConfig(...)
    // ... (identical proxy handling)
    copts.env = *opts.NewListOptsRef(&newEnv, nil)

    // Get server OS
    serverInfo, err := dockerCLI.Client().Ping(ctx, client.PingOptions{})
    if err != nil {
        return err
    }

    // CRITICAL: Convert options to API types (same call)
    containerCfg, err := parse(flags, copts, serverInfo.OSType)
    if err != nil {
        return cli.StatusError{Status: withHelp(err, "create").Error(), StatusCode: 125}
    }

    // Create container only (no start/attach)
    id, err := createContainer(ctx, dockerCLI, containerCfg, options)
    if err != nil {
        return err
    }
    fmt.Fprintln(dockerCLI.Out(), id)
    return nil
}
```

**Key Observation**: Both `runRun()` and `runCreate()` follow identical pattern:
1. Validate command-specific options
2. Inject proxy configuration
3. Get server OS via Ping
4. Call `parse()` with same arguments
5. Diverge only in execution (run starts+attaches, create just creates)

### Entry Point 5: parse() - Options to API Conversion

**File**: `cli/command/container/opts.go:341-740`

**Purpose**: Convert intermediate `containerOptions` to API-ready structures

**Execution Flow**:
```
parse(flags, copts, serverOS) called from runRun/runCreate
  ↓
1. Additional validation
  ├─ MAC address format
  ├─ Swappiness range (0-100)
  ├─ PID/UTS/userns/cgroup namespace modes
  ├─ Healthcheck conflicts
  └─ Restart policy conflicts

2. Complex transformations
  ├─ Volume specs → binds + volumes map
  ├─ Port specs → exposed ports + port bindings
  ├─ Device paths (OS-dependent validation)
  ├─ Environment files + vars → merged env array
  ├─ Label files + labels → merged labels map
  └─ Network configuration

3. Construct API structures
  ├─ container.Config (Image, Cmd, Env, Labels, etc.)
  ├─ container.HostConfig (Binds, Resources, NetworkMode, etc.)
  └─ network.NetworkingConfig (Endpoints)

4. Handle conditional fields (flags.Changed)
  ├─ --init (only set if explicitly provided)
  ├─ --stop-timeout (only set if changed from default)
  └─ --entrypoint (distinguish empty vs unset)

5. Return containerConfig struct
```

**Key Sections**:

**Section 1: Validation and Defaults**
```go
func parse(flags *pflag.FlagSet, copts *containerOptions, serverOS string) (*containerConfig, error) {
    // Determine attach streams
    var (
        attachStdin  = copts.attach.Get("stdin")
        attachStdout = copts.attach.Get("stdout")
        attachStderr = copts.attach.Get("stderr")
    )

    // Validate MAC address
    if copts.macAddress != "" {
        if _, err := net.ParseMAC(strings.TrimSpace(copts.macAddress)); err != nil {
            return nil, fmt.Errorf("%s is not a valid mac address", copts.macAddress)
        }
    }

    // Apply defaults for attach
    if copts.stdin {
        attachStdin = true
    }
    if copts.attach.Len() == 0 {
        attachStdout = true
        attachStderr = true
    }

    // Validate swappiness range
    swappiness := copts.swappiness
    if swappiness != -1 && (swappiness < 0 || swappiness > 100) {
        return nil, fmt.Errorf("invalid value: %d. Valid memory swappiness range is 0-100", swappiness)
    }
```

**Section 2: Volume Processing**
```go
    // Transform volume specs to binds and volumes
    var binds []string
    volumes := copts.volumes.GetMap()

    for bind := range copts.volumes.GetMap() {
        parsed, err := volumespec.Parse(bind)
        if err != nil {
            return nil, err
        }

        if parsed.Source != "" {
            toBind := bind

            // Convert relative paths to absolute for bind mounts
            if parsed.Type == string(mount.TypeBind) {
                if hostPart, targetPath, ok := strings.Cut(bind, ":"); ok {
                    if !filepath.IsAbs(hostPart) && strings.HasPrefix(hostPart, ".") {
                        if absHostPart, err := filepath.Abs(hostPart); err == nil {
                            hostPart = absHostPart
                        }
                    }
                    toBind = hostPart + ":" + targetPath
                }
            }

            binds = append(binds, toBind)
            delete(volumes, bind)  // Remove bind mounts from volumes map
        }
    }
```

**Section 3: Port Mapping Processing**
```go
    // Parse port specifications
    convertedOpts, err := convertToStandardNotation(copts.publish.GetSlice())
    if err != nil {
        return nil, err
    }

    // Short syntax: [ip:]public:private[/proto]
    ports, natPortBindings, err := nat.ParsePortSpecs(convertedOpts)
    if err != nil {
        return nil, err
    }

    // Convert to API types
    portBindings := network.PortMap{}
    for port, bindings := range natPortBindings {
        p, err := network.ParsePort(string(port))
        if err != nil {
            return nil, err
        }
        portBindings[p] = []network.PortBinding{}
        for _, b := range bindings {
            var hostIP netip.Addr
            if b.HostIP != "" {
                hostIP, err = netip.ParseAddr(b.HostIP)
                if err != nil {
                    return nil, err
                }
            }
            portBindings[p] = append(portBindings[p], network.PortBinding{
                HostIP:   hostIP,
                HostPort: b.HostPort,
            })
        }
    }

    // Merge published + exposed ports
    exposedPorts := network.PortSet{}
    for port := range ports {
        p, err := network.ParsePort(string(port))
        if err != nil {
            return nil, err
        }
        exposedPorts[p] = struct{}{}
    }

    for _, e := range copts.expose.GetSlice() {
        pr, err := network.ParsePortRange(e)
        if err != nil {
            return nil, fmt.Errorf("invalid range format for --expose: %w", err)
        }
        for p := range pr.All() {
            exposedPorts[p] = struct{}{}
        }
    }
```

**Section 4: Device Processing (OS-Dependent)**
```go
    // Validate and parse device mappings
    devices := copts.devices.GetSlice()
    deviceMappings := make([]container.DeviceMapping, 0, len(devices))
    cdiDeviceNames := make([]string, 0, len(devices))

    for _, device := range devices {
        // CDI (Container Device Interface) devices
        if cdi.IsQualifiedName(device) {
            cdiDeviceNames = append(cdiDeviceNames, device)
            continue
        }

        // Traditional device paths - validate with server OS
        validated, err := validateDevice(device, serverOS)
        if err != nil {
            return nil, err
        }
        deviceMapping, err := parseDevice(validated, serverOS)
        if err != nil {
            return nil, err
        }
        deviceMappings = append(deviceMappings, deviceMapping)
    }
```

**Section 5: File Merging (env, labels)**
```go
    // Merge environment files + command-line env vars
    envVariables, err := opts.ReadKVEnvStrings(
        copts.envFile.GetSlice(),   // Files first
        copts.env.GetSlice(),        // Command-line overrides
    )
    if err != nil {
        return nil, err
    }

    // Merge label files + command-line labels
    labels, err := opts.ReadKVStrings(
        copts.labelsFile.GetSlice(),
        copts.labels.GetSlice(),
    )
    if err != nil {
        return nil, err
    }
```

**Section 6: Healthcheck Configuration**
```go
    var healthConfig *container.HealthConfig
    haveHealthSettings := copts.healthCmd != "" ||
        copts.healthInterval != 0 ||
        copts.healthTimeout != 0 ||
        copts.healthStartPeriod != 0 ||
        copts.healthRetries != 0 ||
        copts.healthStartInterval != 0

    if copts.noHealthcheck {
        if haveHealthSettings {
            return nil, errors.New("--no-healthcheck conflicts with --health-* options")
        }
        healthConfig = &container.HealthConfig{Test: []string{"NONE"}}
    } else if haveHealthSettings {
        var probe []string
        if copts.healthCmd != "" {
            probe = []string{"CMD-SHELL", copts.healthCmd}
        }

        // Validate all health settings are non-negative
        if copts.healthInterval < 0 {
            return nil, errors.New("--health-interval cannot be negative")
        }
        // ... (similar checks for timeout, retries, start-period, start-interval)

        healthConfig = &container.HealthConfig{
            Test:          probe,
            Interval:      copts.healthInterval,
            Timeout:       copts.healthTimeout,
            StartPeriod:   copts.healthStartPeriod,
            StartInterval: copts.healthStartInterval,
            Retries:       copts.healthRetries,
        }
    }
```

**Section 7: Resources Structure**
```go
    // Build resources configuration
    resources := container.Resources{
        CgroupParent:         copts.cgroupParent,
        Memory:               copts.memory.Value(),           // MemBytes → int64
        MemoryReservation:    copts.memoryReservation.Value(),
        MemorySwap:           copts.memorySwap.Value(),
        MemorySwappiness:     &copts.swappiness,             // Pointer for optional
        OomKillDisable:       &copts.oomKillDisable,
        NanoCPUs:             copts.cpus.Value(),             // NanoCPUs → int64
        CPUCount:             copts.cpuCount,
        CPUPercent:           copts.cpuPercent,
        CPUShares:            copts.cpuShares,
        CPUPeriod:            copts.cpuPeriod,
        CpusetCpus:           copts.cpusetCpus,
        CpusetMems:           copts.cpusetMems,
        CPUQuota:             copts.cpuQuota,
        CPURealtimePeriod:    copts.cpuRealtimePeriod,
        CPURealtimeRuntime:   copts.cpuRealtimeRuntime,
        PidsLimit:            &copts.pidsLimit,
        BlkioWeight:          copts.blkioWeight,
        BlkioWeightDevice:    copts.blkioWeightDevice.GetList(),
        BlkioDeviceReadBps:   copts.deviceReadBps.GetList(),
        BlkioDeviceWriteBps:  copts.deviceWriteBps.GetList(),
        BlkioDeviceReadIOps:  copts.deviceReadIOps.GetList(),
        BlkioDeviceWriteIOps: copts.deviceWriteIOps.GetList(),
        IOMaximumIOps:        copts.ioMaxIOps,
        IOMaximumBandwidth:   uint64(copts.ioMaxBandwidth),
        Ulimits:              copts.ulimits.GetList(),
        DeviceCgroupRules:    copts.deviceCgroupRules.GetSlice(),
        Devices:              deviceMappings,
        DeviceRequests:       deviceRequests,  // GPUs + CDI devices
    }
```

**Section 8: Config Structure**
```go
    config := &container.Config{
        Hostname:     copts.hostname,
        Domainname:   copts.domainname,
        ExposedPorts: exposedPorts,
        User:         copts.user,
        Tty:          copts.tty,
        OpenStdin:    copts.stdin,
        AttachStdin:  attachStdin,
        AttachStdout: attachStdout,
        AttachStderr: attachStderr,
        Env:          envVariables,
        Cmd:          runCmd,                    // Positional args
        Image:        copts.Image,               // Positional arg
        Volumes:      volumes,                   // Named volumes only
        Entrypoint:   entrypoint,
        WorkingDir:   copts.workingDir,
        Labels:       opts.ConvertKVStringsToMap(labels),
        StopSignal:   copts.stopSignal,
        Healthcheck:  healthConfig,
    }

    // Conditional field: only set if user explicitly provided flag
    if flags.Changed("stop-timeout") {
        config.StopTimeout = &copts.stopTimeout
    }
```

**Section 9: HostConfig Structure**
```go
    hostConfig := &container.HostConfig{
        Binds:           binds,
        ContainerIDFile: copts.containerIDFile,
        OomScoreAdj:     copts.oomScoreAdj,
        AutoRemove:      copts.autoRemove,
        Privileged:      copts.privileged,
        PortBindings:    portBindings,
        Links:           copts.links.GetSlice(),
        PublishAllPorts: copts.publishAll,
        DNS:             toNetipAddrSlice(copts.dns.GetAllOrEmpty()),
        DNSSearch:       copts.dnsSearch.GetAllOrEmpty(),
        DNSOptions:      copts.dnsOptions.GetAllOrEmpty(),
        ExtraHosts:      copts.extraHosts.GetSlice(),
        VolumesFrom:     copts.volumesFrom.GetSlice(),
        IpcMode:         container.IpcMode(copts.ipcMode),
        NetworkMode:     container.NetworkMode(copts.netMode.NetworkMode()),
        PidMode:         pidMode,
        UTSMode:         utsMode,
        UsernsMode:      usernsMode,
        CgroupnsMode:    cgroupnsMode,
        CapAdd:          copts.capAdd.GetSlice(),
        CapDrop:         copts.capDrop.GetSlice(),
        GroupAdd:        copts.groupAdd.GetSlice(),
        RestartPolicy:   restartPolicy,
        SecurityOpt:     securityOpts,
        StorageOpt:      storageOpts,
        ReadonlyRootfs:  copts.readonlyRootfs,
        LogConfig:       container.LogConfig{Type: copts.loggingDriver, Config: loggingOpts},
        VolumeDriver:    copts.volumeDriver,
        Isolation:       container.Isolation(copts.isolation),
        ShmSize:         copts.shmSize.Value(),
        Resources:       resources,
        Tmpfs:           tmpfs,
        Sysctls:         copts.sysctls.GetAll(),
        Runtime:         copts.runtime,
        Mounts:          copts.mounts.Value(),
        MaskedPaths:     maskedPaths,
        ReadonlyPaths:   readonlyPaths,
        Annotations:     copts.annotations.GetAll(),
    }

    // Cross-field validation
    if copts.autoRemove && !hostConfig.RestartPolicy.IsNone() {
        return nil, errors.New("conflicting options: cannot specify both --restart and --rm")
    }

    // Conditional field: only set if user explicitly provided --init
    if flags.Changed("init") {
        hostConfig.Init = &copts.init
    }

    // Auto-close stdin when attached and client disconnects
    if config.OpenStdin && config.AttachStdin {
        config.StdinOnce = true
    }
```

**Section 10: NetworkingConfig**
```go
    // Parse network endpoints
    epCfg, err := parseNetworkOpts(copts)
    if err != nil {
        return nil, err
    }

    return &containerConfig{
        Config:     config,
        HostConfig: hostConfig,
        NetworkingConfig: &network.NetworkingConfig{
            EndpointsConfig: epCfg,
        },
    }, nil
}
```

**Critical Features of parse()**:

1. **Server OS Dependency**: Device validation, path handling differ by OS
2. **flags.Changed()**: Distinguishes explicit vs default values
3. **Complex Transformations**: Port specs, volume specs, device specs all parsed
4. **File Merging**: Environment/label files merged with CLI flags (CLI wins)
5. **Validation**: Cross-field validation (conflicting options)
6. **Type Conversion**: Custom types → API types (MemBytes→int64, NanoCPUs→int64)
7. **Pointer Semantics**: Optional fields use pointers to distinguish unset vs zero

### Entry Point 6: API Call - createContainer()

**File**: `cli/command/container/create.go:213-379`

**Purpose**: Create container via Docker API using parsed configuration

**Execution Flow**:
```
createContainer(ctx, dockerCLI, containerConfig, createOptions)
  ↓
1. Image reference parsing
  ├─ Parse IMAGE to reference.Named
  └─ Apply TagNameOnly (adds :latest if needed)

2. Platform handling
  ├─ Parse --platform flag if provided
  └─ Validate platform string

3. Pre-creation image pull (if --pull=always)
  └─ pullImage(ctx, dockerCLI, image, options)

4. Container ID file handling
  ├─ Create/validate --cidfile path
  └─ Defer cleanup

5. --use-api-socket handling (experimental)
  ├─ Add bind mount for /var/run/docker.sock
  ├─ Resolve registry credentials
  └─ Prepare to inject docker config.json

6. API call: ContainerCreate
  ├─ Pass Config, HostConfig, NetworkingConfig
  ├─ Retry with image pull if NotFound error
  └─ Return response.ID

7. Post-creation steps
  ├─ Inject docker config if --use-api-socket
  ├─ Write container ID to --cidfile
  └─ Print warnings
```

**Code**:
```go
func createContainer(ctx context.Context, dockerCLI command.Cli,
    containerCfg *containerConfig, options *createOptions) (containerID string, _ error) {

    config := containerCfg.Config
    hostConfig := containerCfg.HostConfig
    networkingConfig := containerCfg.NetworkingConfig

    // Parse image reference
    var namedRef reference.Named
    ref, err := reference.ParseAnyReference(config.Image)
    if err != nil {
        return "", err
    }
    if named, ok := ref.(reference.Named); ok {
        namedRef = reference.TagNameOnly(named)  // Add :latest if needed
    }

    // Handle platform
    var platform *ocispec.Platform
    if options.platform != "" {
        p, err := platforms.Parse(options.platform)
        if err != nil {
            return "", invalidParameter(fmt.Errorf("error parsing specified platform: %w", err))
        }
        platform = &p
    }

    // Pull image if --pull=always
    if options.pull == PullImageAlways {
        if err := pullImage(ctx, dockerCLI, config.Image, options); err != nil {
            return "", err
        }
    }

    // Set console size for TTY
    hostConfig.ConsoleSize[0], hostConfig.ConsoleSize[1] = dockerCLI.Out().GetTtySize()

    // CRITICAL API CALL
    response, err := dockerCLI.Client().ContainerCreate(ctx, client.ContainerCreateOptions{
        Name:             options.name,
        Platform:         platform,
        Config:           config,           // From parse()
        HostConfig:       hostConfig,       // From parse()
        NetworkingConfig: networkingConfig, // From parse()
    })

    if err != nil {
        // Auto-pull if image not found and --pull=missing (default)
        if errdefs.IsNotFound(err) && namedRef != nil && options.pull == PullImageMissing {
            if !options.quiet {
                fmt.Fprintf(dockerCLI.Err(), "Unable to find image '%s' locally\n",
                    reference.FamiliarString(namedRef))
            }

            if err := pullImage(ctx, dockerCLI, config.Image, options); err != nil {
                return "", err
            }

            // Retry create after pull
            var retryErr error
            response, retryErr = dockerCLI.Client().ContainerCreate(ctx, client.ContainerCreateOptions{
                Name:             options.name,
                Platform:         platform,
                Config:           config,
                HostConfig:       hostConfig,
                NetworkingConfig: networkingConfig,
            })
            if retryErr != nil {
                return "", retryErr
            }
        } else {
            return "", err
        }
    }

    // Print warnings from daemon
    for _, w := range response.Warnings {
        fmt.Fprintln(dockerCLI.Err(), "WARNING:", w)
    }

    // Write container ID to file if --cidfile provided
    err = containerIDFile.Write(response.ID)
    return response.ID, err
}
```

**Key Observations**:
1. **Destructures containerConfig**: Extracts Config, HostConfig, NetworkingConfig
2. **Auto-pull logic**: Handles --pull=always, --pull=missing, --pull=never
3. **Platform aware**: Passes platform if specified
4. **Retry pattern**: If NotFound + pull=missing, pull then retry
5. **Warning handling**: Prints daemon warnings to stderr
6. **CID file**: Atomically writes container ID to file

## Request/Command Flow Diagrams

### Flow 1: docker run Command

```
User: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
  ↓
main() @ cmd/docker/docker.go:37
  ↓
dockerMain() @ cmd/docker/docker.go:77
  ├─ Creates DockerCli instance
  └─ Calls runDocker()
  ↓
newDockerCommand() @ cmd/docker/docker.go:117
  ├─ Creates root cobra.Command
  └─ Calls commands.AddCommands()
  ↓
commands.AddCommands() @ cli/command/commands/commands.go:26
  └─ Invokes newRunCommand(dockerCLI)
  ↓
newRunCommand() @ cli/command/container/run.go:32
  ├─ Declares: var options runOptions
  ├─ Declares: var copts *containerOptions
  ├─ Registers run-specific flags → options
  ├─ Calls: copts = addFlags(flags)
  └─ Returns cobra.Command with RunE closure
  ↓
[User executes: docker run -d -p 8080:80 nginx]
  ↓
Cobra invokes RunE closure @ run.go:40
  ├─ Sets: copts.Image = "nginx"
  └─ Calls: runRun(ctx, dockerCLI, flags, &options, copts)
  ↓
runRun() @ cli/command/container/run.go:86
  ├─ Validates pull option
  ├─ Injects proxy environment
  ├─ Pings daemon for server OS
  ├─ Calls: containerCfg = parse(flags, copts, serverOS)
  └─ Calls: runContainer(ctx, dockerCLI, runOpts, copts, containerCfg)
  ↓
parse() @ cli/command/container/opts.go:341
  ├─ Validates all options
  ├─ Transforms volumes, ports, devices
  ├─ Merges env files + flags
  ├─ Builds container.Config
  ├─ Builds container.HostConfig
  ├─ Builds network.NetworkingConfig
  └─ Returns containerConfig struct
  ↓
runContainer() @ cli/command/container/run.go:120
  ├─ Validates attach/detach options
  ├─ Calls: createContainer(ctx, dockerCLI, containerCfg, &options.createOptions)
  ├─ Sets up signal forwarding (if --sig-proxy)
  ├─ Attaches I/O streams (if not detached)
  ├─ Calls: apiClient.ContainerStart(ctx, containerID, ...)
  ├─ Monitors TTY size (if --tty)
  └─ Waits for container exit or detach
  ↓
createContainer() @ cli/command/container/create.go:213
  ├─ Parses image reference
  ├─ Handles --pull strategy
  ├─ Calls: dockerCLI.Client().ContainerCreate(ctx, ...)
  │   ├─ Config:           containerCfg.Config
  │   ├─ HostConfig:       containerCfg.HostConfig
  │   └─ NetworkingConfig: containerCfg.NetworkingConfig
  └─ Returns container ID
  ↓
Docker API: POST /containers/create
  ↓
[Container created and started]
```

### Flow 2: docker create Command

```
User: docker create [OPTIONS] IMAGE [COMMAND] [ARG...]
  ↓
[Same initialization as docker run through newDockerCommand()]
  ↓
newCreateCommand() @ cli/command/container/create.go:47
  ├─ Declares: var options createOptions
  ├─ Declares: var copts *containerOptions
  ├─ Registers create-specific flags → options
  ├─ Calls: copts = addFlags(flags)  [SAME CALL AS RUN]
  └─ Returns cobra.Command with RunE closure
  ↓
[User executes: docker create --name mycontainer nginx]
  ↓
Cobra invokes RunE closure @ create.go:55
  ├─ Sets: copts.Image = "nginx"
  └─ Calls: runCreate(ctx, dockerCLI, flags, &options, copts)
  ↓
runCreate() @ cli/command/container/create.go:97
  ├─ Validates pull option
  ├─ Injects proxy environment
  ├─ Pings daemon for server OS
  ├─ Calls: containerCfg = parse(flags, copts, serverOS)  [SAME CALL AS RUN]
  └─ Calls: createContainer(ctx, dockerCLI, containerCfg, options)
  ↓
parse() @ cli/command/container/opts.go:341
  [IDENTICAL TO RUN - same function, same inputs]
  ↓
createContainer() @ cli/command/container/create.go:213
  [IDENTICAL TO RUN - same function]
  ↓
[Container created but NOT started]
```

**Key Difference**: `run` calls `runContainer()` which starts+attaches, `create` just calls `createContainer()` and prints ID.

### Flow 3: addFlags() - Flag Registration

```
Command constructor calls: copts = addFlags(flags)
  ↓
addFlags() @ cli/command/container/opts.go:148
  ↓
PHASE 1: Initialize containerOptions
  ├─ copts := &containerOptions{}
  ├─ copts.attach = opts.NewListOpts(validateAttach)
  ├─ copts.dns = opts.NewListOpts(opts.ValidateIPAddress)
  ├─ copts.env = opts.NewListOpts(opts.ValidateEnv)
  ├─ copts.labels = opts.NewListOpts(opts.ValidateLabel)
  ├─ copts.sysctls = opts.NewMapOpts(nil, opts.ValidateSysctl)
  ├─ copts.ulimits = opts.NewUlimitOpt(nil)
  ├─ copts.mounts = opts.MountOpt{}
  ├─ copts.memory = opts.MemBytes{}
  ├─ copts.cpus = opts.NanoCPUs{}
  └─ ... (36 fields total)
  ↓
PHASE 2: Register flags with pflag
  ├─ flags.VarP(&copts.attach, "attach", "a", "...")
  ├─ flags.VarP(&copts.env, "env", "e", "...")
  ├─ flags.VarP(&copts.volumes, "volume", "v", "...")
  ├─ flags.VarP(&copts.publish, "publish", "p", "...")
  ├─ flags.VarP(&copts.memory, "memory", "m", "...")
  ├─ flags.BoolVar(&copts.privileged, "privileged", false, "...")
  ├─ flags.Int64VarP(&copts.cpuShares, "cpu-shares", "c", 0, "...")
  ├─ ... (98 flags total)
  ├─
  ├─ [Annotations]
  ├─ flags.SetAnnotation("gpus", "version", []string{"1.40"})
  ├─ flags.SetAnnotation("cgroupns", "version", []string{"1.41"})
  ├─ flags.SetAnnotation("cpu-count", "ostype", []string{"windows"})
  ├─
  ├─ [Aliases]
  ├─ flags.Var(&copts.netMode, "net", "...")
  ├─ flags.Var(&copts.netMode, "network", "...")  [same variable]
  ├─ flags.MarkHidden("net")
  ├─
  ├─ [Deprecations]
  ├─ flags.Var(&stub, "kernel-memory", "...")
  └─ flags.MarkDeprecated("kernel-memory", "...")
  ↓
PHASE 3: Return initialized struct
  └─ return copts
  ↓
[Caller stores returned pointer]
copts = addFlags(flags)
  ↓
[Later: User runs command with flags]
  ↓
Cobra calls flags.Parse()
  ├─ For each flag provided by user:
  ├─   Calls flag.Value.Set(userValue)
  │     ├─ Runs validator (if attached)
  │     └─ Stores in copts field
  └─ copts now populated with user values
```

### Flow 4: parse() - Options to API Conversion

```
parse(flags, copts, serverOS) called from runRun/runCreate
  ↓
PHASE 1: Validation
  ├─ Validate MAC address format
  ├─ Validate swappiness range (0-100)
  ├─ Validate namespace modes (pid, uts, userns, cgroup)
  ├─ Validate restart policy
  ├─ Check healthcheck conflicts
  └─ Validate cross-field constraints
  ↓
PHASE 2: Complex Parsing
  ├─ Volume specs → binds + volumes
  │   ├─ Parse each volume spec
  │   ├─ Separate bind mounts from named volumes
  │   ├─ Convert relative paths to absolute
  │   └─ Build binds array and volumes map
  ├─
  ├─ Port specs → exposed + bindings
  │   ├─ Parse [ip:]hostPort:containerPort[/proto]
  │   ├─ Build portBindings map
  │   └─ Merge with --expose flags
  ├─
  ├─ Device specs → device mappings (OS-dependent)
  │   ├─ Validate device paths for serverOS
  │   ├─ Parse PathOnHost:PathInContainer:Permissions
  │   └─ Handle CDI devices separately
  ├─
  ├─ Environment → merged array
  │   ├─ Read env files (if any)
  │   ├─ Merge with --env flags (flags override files)
  │   └─ Return envVariables array
  ├─
  └─ Labels → merged map
      ├─ Read label files (if any)
      ├─ Merge with --label flags
      └─ Convert to map[string]string
  ↓
PHASE 3: Build Resources
  └─ resources := container.Resources{
      Memory:    copts.memory.Value(),     [MemBytes → int64]
      NanoCPUs:  copts.cpus.Value(),       [NanoCPUs → int64]
      CPUShares: copts.cpuShares,          [int64]
      Ulimits:   copts.ulimits.GetList(),  [*UlimitOpt → []*Ulimit]
      Devices:   deviceMappings,           [parsed devices]
      ... [40+ more fields]
  }
  ↓
PHASE 4: Build Config
  └─ config := &container.Config{
      Hostname:     copts.hostname,
      Image:        copts.Image,           [positional arg]
      Cmd:          copts.Args,            [positional args]
      Env:          envVariables,          [merged]
      Labels:       labels,                [merged map]
      ExposedPorts: exposedPorts,          [parsed ports]
      AttachStdin:  attachStdin,           [computed from --attach]
      Tty:          copts.tty,
      OpenStdin:    copts.stdin,
      ... [20+ more fields]
  }
  ├─ [Conditional fields]
  └─ if flags.Changed("stop-timeout") {
      config.StopTimeout = &copts.stopTimeout
  }
  ↓
PHASE 5: Build HostConfig
  └─ hostConfig := &container.HostConfig{
      Binds:        binds,                 [computed from volumes]
      PortBindings: portBindings,          [parsed ports]
      Privileged:   copts.privileged,
      NetworkMode:  copts.netMode.NetworkMode(),
      Resources:    resources,             [from phase 3]
      Mounts:       copts.mounts.Value(),
      Sysctls:      copts.sysctls.GetAll(),
      ... [50+ more fields]
  }
  ├─ [Cross-field validation]
  ├─ if copts.autoRemove && !hostConfig.RestartPolicy.IsNone() {
  │       return nil, errors.New("conflicting options: --restart and --rm")
  ├─ }
  ├─ [Conditional fields]
  └─ if flags.Changed("init") {
      hostConfig.Init = &copts.init
  }
  ↓
PHASE 6: Build NetworkingConfig
  ├─ epCfg, err := parseNetworkOpts(copts)
  └─ networkingConfig := &network.NetworkingConfig{
      EndpointsConfig: epCfg,
  }
  ↓
PHASE 7: Return Assembled Config
  └─ return &containerConfig{
      Config:           config,
      HostConfig:       hostConfig,
      NetworkingConfig: networkingConfig,
  }, nil
```

## Handler Registration Pattern

### Registration Mechanism

**Pattern**: Init-time registration via side-effect imports

**Files Involved**:
- `internal/commands/commands.go` - Registry storage
- `cli/command/container/cmd.go` - Command package init()
- `cli/command/commands/commands.go` - Import aggregator

**Registration Flow**:

```go
// 1. Registry (internal/commands/commands.go)
var commands []func(command.Cli) *cobra.Command

func Register(f func(command.Cli) *cobra.Command) {
    commands = append(commands, f)
}

func Commands() []func(command.Cli) *cobra.Command {
    return commands
}

// 2. Package init (cli/command/container/cmd.go)
func init() {
    commands.Register(newRunCommand)
    commands.Register(newExecCommand)
    commands.RegisterLegacy(newCreateCommand)
    // ... 20+ more commands
}

// 3. Import aggregator (cli/command/commands/commands.go)
import (
    _ "github.com/docker/cli/cli/command/container"  // Triggers init()
    _ "github.com/docker/cli/cli/command/image"
    _ "github.com/docker/cli/cli/command/network"
    // ... 12 more packages
)

func AddCommands(cmd *cobra.Command, dockerCLI command.Cli) {
    for _, c := range commands.Commands() {
        cmd.AddCommand(c(dockerCLI))  // Lazy construction
    }
}
```

**Key Features**:
1. **Lazy Construction**: Commands aren't built until `AddCommands()` is called
2. **Decoupled**: Each command package independently registers itself
3. **No Circular Dependencies**: Registry is in `internal/`, command packages import it
4. **Testable**: Each command can be tested independently by calling factory function

### Handler Signature

**Factory Function Signature**:
```go
func newCommandName(dockerCLI command.Cli) *cobra.Command
```

**Example**: `newRunCommand(dockerCLI command.Cli) *cobra.Command`

**Handler Interface** (Cobra RunE):
```go
RunE: func(cmd *cobra.Command, args []string) error {
    // Command implementation
    return runCommandName(cmd.Context(), dockerCLI, cmd.Flags(), &options, copts)
}
```

**Common Handler Pattern**:
```go
func runCommandName(ctx context.Context, dockerCLI command.Cli,
    flags *pflag.FlagSet, opts *commandOptions, copts *containerOptions) error {

    // 1. Validate command-specific options
    // 2. Get server info (if needed)
    // 3. Parse shared options: containerCfg = parse(flags, copts, serverOS)
    // 4. Execute API calls
    // 5. Handle output/errors

    return nil
}
```

## Extension Points

### Extension Point 1: Adding New Commands

**Location**: Any new package under `cli/command/`

**Steps**:
1. Create new package (e.g., `cli/command/newfeature/`)
2. Implement command factory function
3. Add init() function that registers commands
4. Add blank import to `cli/command/commands/commands.go`

**Example**:
```go
// cli/command/newfeature/cmd.go
package newfeature

import "github.com/docker/cli/internal/commands"

func init() {
    commands.Register(newMyCommand)
}

func newMyCommand(dockerCLI command.Cli) *cobra.Command {
    // Command implementation
}
```

### Extension Point 2: Adding Shared Container Flags

**Location**: `cli/command/container/opts.go::addFlags()`

**Steps**:
1. Add field to `containerOptions` struct
2. Initialize field in `addFlags()` with validator
3. Register flag with `flags.Var()` or `flags.StringVar()`, etc.
4. Add API version annotation if needed
5. Handle field in `parse()` function

**Example**:
```go
// In containerOptions struct (line ~48)
type containerOptions struct {
    // ... existing fields
    myNewOption string
}

// In addFlags() initialization (line ~148)
copts := &containerOptions{
    // ... existing initializations
}

// In addFlags() registration (line ~200)
flags.StringVar(&copts.myNewOption, "my-option", "", "Description of my option")
flags.SetAnnotation("my-option", "version", []string{"1.45"})

// In parse() (line ~341)
// Use copts.myNewOption in building Config or HostConfig
config.MyField = copts.myNewOption
```

### Extension Point 3: Custom Option Types

**Location**: `opts/` package

**Interface to Implement**:
```go
type Value interface {
    String() string
    Set(string) error
    Type() string
}
```

**Example**:
```go
// opts/mytype.go
package opts

type MyType struct {
    value string
}

func (m *MyType) Set(value string) error {
    // Parse and validate value
    m.value = value
    return nil
}

func (m *MyType) String() string {
    return m.value
}

func (m *MyType) Type() string {
    return "mytype"
}

func (m *MyType) Value() string {
    return m.value
}
```

Then use in `containerOptions`:
```go
myField opts.MyType

// In addFlags()
flags.Var(&copts.myField, "my-field", "Description")
```

### Extension Point 4: Command Middleware

**Location**: `cmd/docker/docker.go::newDockerCommand()`

**Hook**: `PersistentPreRunE` callback

**Example**:
```go
cmd := &cobra.Command{
    // ...
    PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
        // Runs before every command
        return isSupported(cmd, dockerCLI)
    },
}
```

### Extension Point 5: Output Formatting

**Location**: `cli/command/formatter/` package

**Pattern**: Commands support `--format` flag for custom output templates

**Example** (hypothetical):
```go
// In command implementation
if format := options.format; format != "" {
    return formatter.Format(ctx, format, data)
}
```

### Extension Point 6: Plugin System

**Location**: `cli-plugins/` package

**Discovery**: Searches for `docker-<name>` binaries in plugin directories

**Example**: `docker-buildx` is a plugin that extends Docker CLI

**Plugin Entry Point**:
```go
// A plugin is just an executable named docker-<name>
// that implements the plugin metadata protocol
```

## Call Graph Seeds

Key functions for deeper analysis:

### 1. `main()` at `cmd/docker/docker.go:37`
**Why**: Application entry point, sets up error handling and signal management

### 2. `newDockerCommand()` at `cmd/docker/docker.go:117`
**Why**: Central command construction, wires together all commands, sets up global flags

### 3. `commands.AddCommands()` at `cli/command/commands/commands.go:26`
**Why**: Command registration hub, triggers all command factories

### 4. `addFlags()` at `cli/command/container/opts.go:148`
**Why**: Single source of truth for 98 container flags, shows validator pattern

### 5. `parse()` at `cli/command/container/opts.go:341`
**Why**: Core transformation logic, handles all complex conversions and validations

### 6. `runRun()` at `cli/command/container/run.go:86`
**Why**: Example of command execution pattern, shows how options flow to API

### 7. `createContainer()` at `cli/command/container/create.go:213`
**Why**: Final API call layer, shows how parsed config reaches Docker daemon

### 8. `command.NewDockerCli()` (from docker/cli package)
**Why**: DockerCli initialization, API client lazy loading

### 9. `pflag.FlagSet.Parse()` (from spf13/pflag)
**Why**: Understand how custom types get populated via Value.Set()

### 10. `cobra.Command.Execute()` (from spf13/cobra)
**Why**: Command routing and execution framework

## Architecture Summary

### Key Insights

1. **Init-Time Registration**: Commands register themselves via `init()` functions triggered by blank imports
2. **Lazy Construction**: Command structs created on-demand when `AddCommands()` is called
3. **Two-Phase Options**:
   - **Phase 1**: `addFlags()` creates `containerOptions` and registers flags
   - **Phase 2**: `parse()` transforms `containerOptions` to API-ready structs
4. **Flag Binding**: Cobra/pflag automatically populates option fields when user provides flags
5. **Validation Layering**:
   - **Parse-time**: Validators in custom types (during `flags.Parse()`)
   - **Pre-API**: Complex validation in `parse()` function
   - **Server-side**: Docker daemon validates final API payload
6. **Separation of Concerns**:
   - **Commands**: Orchestration only (run.go, create.go)
   - **Options**: Flag management (opts.go::addFlags)
   - **Parsing**: Transformation logic (opts.go::parse)
   - **Custom Types**: Reusable validators (opts/ package)
7. **DRY via Shared Options**: Multiple commands share the same 98 flags via `addFlags()` call
8. **Conditional Fields**: `flags.Changed()` distinguishes explicit vs default values
9. **Platform Awareness**: Server OS influences device validation and path handling
10. **API Version Annotations**: Runtime checks ensure flags match daemon capabilities

### Pattern Strengths

1. **Maintainability**: Single flag definition used by multiple commands
2. **Consistency**: All commands using containerOptions have identical flag behavior
3. **Testability**: Each layer can be tested independently
4. **Extensibility**: Easy to add new commands or flags without modifying existing code
5. **Type Safety**: Custom option types provide compile-time safety and runtime validation
6. **Discoverability**: All container flags in one place (addFlags function)
7. **Backward Compatibility**: Deprecation and aliases support legacy flag names

### Data Flow Summary

```
User Input (CLI)
  ↓
Cobra Routing
  ↓
Command Factory (newRunCommand)
  ↓
Flag Registration (addFlags → containerOptions)
  ↓
User Execution
  ↓
Cobra Flag Parsing (populates containerOptions)
  ↓
Command Handler (runRun)
  ↓
Conversion (parse → containerConfig)
  ↓
API Call (createContainer → Docker daemon)
  ↓
Container Created/Started
```

### Critical Functions by Role

| Role | Function | File | Lines |
|------|----------|------|-------|
| **Bootstrap** | main() | cmd/docker/docker.go | 37-49 |
| **Initialization** | dockerMain() | cmd/docker/docker.go | 77-89 |
| **Command Setup** | newDockerCommand() | cmd/docker/docker.go | 117-174 |
| **Registration** | init() | cli/command/container/cmd.go | 9-34 |
| **Factory** | newRunCommand() | cli/command/container/run.go | 32-84 |
| **Factory** | newCreateCommand() | cli/command/container/create.go | 47-95 |
| **Flag Definition** | addFlags() | cli/command/container/opts.go | 148-328 |
| **Transformation** | parse() | cli/command/container/opts.go | 341-740 |
| **Execution** | runRun() | cli/command/container/run.go | 86-117 |
| **Execution** | runCreate() | cli/command/container/create.go | 97-132 |
| **API Call** | createContainer() | cli/command/container/create.go | 213-379 |

---

## Conclusion

The Docker CLI container options pattern demonstrates a sophisticated architecture for managing complex flag configurations across multiple commands. The key innovation is the **two-phase options pattern**:

1. **Registration Phase**: `addFlags()` creates an intermediate struct and registers all flags
2. **Transformation Phase**: `parse()` converts the intermediate struct to API-ready types

This pattern is invoked identically from `docker run` and `docker create`, ensuring perfect consistency while allowing each command to add its own specific flags and behavior. The pattern scales to 98 flags with type safety, validation, backward compatibility, and platform awareness, making it an excellent reference for building maintainable CLI applications with rich flag configurations.
