# Patterns & Conventions

> Generated by patterns-analyzer for docker/docker-cli
> Focus: Container options DRY pattern implementation

## Pattern Summary

**Design Patterns**: 10+ identified across multiple categories
**Naming Convention**: Go standard (camelCase, PascalCase)
**Error Handling**: Deferred validation with explicit error returns
**Async Model**: Synchronous flag parsing
**Pattern Consistency**: High - strong adherence to established patterns

The Docker CLI container options implementation exhibits mature, production-grade patterns centered around the **Intermediate Storage Pattern** combined with **Strategy Pattern** for validation. The codebase demonstrates exceptional consistency in applying these patterns across 90+ container configuration options.

---

## Design Patterns

### 1. Intermediate Storage Pattern (Builder Variant)

**Type**: Creational
**Purpose**: Decouple flag parsing from API type construction, enabling shared flag definitions across commands
**Locations**: `cli/command/container/opts.go` - `containerOptions` struct, `addFlags()`, `parse()`

This is the cornerstone pattern enabling DRY principles:

```go
// Intermediate storage - holds raw flag values
type containerOptions struct {
    attach            opts.ListOpts
    volumes           opts.ListOpts
    tmpfs             opts.ListOpts
    mounts            opts.MountOpt
    blkioWeightDevice opts.WeightdeviceOpt
    // ... 90+ fields

    hostname     string
    memory       opts.MemBytes
    cpuShares    int64
    // ... primitive types
}

// Builder-style registration
func addFlags(flags *pflag.FlagSet) *containerOptions {
    copts := &containerOptions{
        aliases:    opts.NewListOpts(nil),
        attach:     opts.NewListOpts(validateAttach),
        dns:        opts.NewListOpts(opts.ValidateIPAddress),
        env:        opts.NewListOpts(opts.ValidateEnv),
        // ... validators injected at construction
    }

    flags.VarP(&copts.attach, "attach", "a", "Attach to STDIN, STDOUT or STDERR")
    flags.VarP(&copts.env, "env", "e", "Set environment variables")
    // ... 90+ flags registered

    return copts
}

// Converter - transforms intermediate to API types
func parse(flags *pflag.FlagSet, copts *containerOptions, serverOS string) (*containerConfig, error) {
    // Deferred validation and transformation
    envVariables, err := opts.ReadKVEnvStrings(copts.envFile.GetSlice(), copts.env.GetSlice())
    if err != nil {
        return nil, err
    }

    config := &container.Config{
        Env:      envVariables,
        Hostname: copts.hostname,
        // ... map intermediate values to API structs
    }

    return &containerConfig{Config: config, HostConfig: hostConfig, NetworkingConfig: nwConfig}, nil
}
```

**Key Insights**:
- Separates parsing concerns from business logic
- Enables multiple commands to share the same flag definitions
- Defers complex validation until after all flags are parsed
- Provides clean extension point for new flags

---

### 2. Strategy Pattern (Validator Functions)

**Type**: Behavioral
**Purpose**: Inject validation logic at construction time, allowing flexible validation policies per flag
**Locations**: `opts/opts.go` - validator function types, all custom option types

```go
// Strategy interface (via function type)
type ValidatorFctType func(val string) (string, error)
type ValidatorFctListType func(val string) ([]string, error)

// Concrete strategies
func ValidateIPAddress(val string) (string, error) {
    if ip := net.ParseIP(strings.TrimSpace(val)); ip != nil {
        return ip.String(), nil
    }
    return "", fmt.Errorf("IP address is not correctly formatted: %s", val)
}

func ValidateDNSSearch(val string) (string, error) {
    if match, _ := regexp.MatchString(`^(\*|(\*\.)?([a-zA-Z0-9-]+\.?)+)$`, val); !match {
        return "", fmt.Errorf("%s is not a valid domain", val)
    }
    return val, nil
}

// Context that uses strategy
type ListOpts struct {
    values    *[]string
    validator ValidatorFctType  // Strategy injected here
}

func (opts *ListOpts) Set(value string) error {
    if opts.validator != nil {
        v, err := opts.validator(value)  // Invoke strategy
        if err != nil {
            return err
        }
        value = v
    }
    *opts.values = append(*opts.values, value)
    return nil
}

// Usage - strategy injection
copts := &containerOptions{
    dns:       opts.NewListOpts(opts.ValidateIPAddress),     // IP validation strategy
    dnsSearch: opts.NewListOpts(opts.ValidateDNSSearch),     // DNS validation strategy
    aliases:   opts.NewListOpts(nil),                        // No validation strategy
}
```

**Pattern Variations**:
- Some validators normalize values (e.g., `ValidateIPAddress` returns normalized form)
- `nil` validator is valid - signifies no validation needed
- Validators can modify the value (normalization) or just validate

---

### 3. pflag.Value Interface Pattern (Adapter)

**Type**: Structural
**Purpose**: Adapt custom types to pflag's flag-parsing interface
**Locations**: All types in `opts/` package

This is Go's approach to implementing the **Type-Safe Heterogeneous Container** pattern:

```go
// pflag.Value interface (from spf13/pflag)
type Value interface {
    String() string
    Set(string) error
    Type() string
}

// Custom type implementing pflag.Value
type ListOpts struct {
    values    *[]string
    validator ValidatorFctType
}

func (opts *ListOpts) String() string {
    if len(*opts.values) == 0 {
        return ""
    }
    return fmt.Sprintf("%v", *opts.values)
}

func (opts *ListOpts) Set(value string) error {
    if opts.validator != nil {
        v, err := opts.validator(value)
        if err != nil {
            return err
        }
        value = v
    }
    *opts.values = append(*opts.values, value)
    return nil
}

func (*ListOpts) Type() string {
    return "list"
}

// Usage with pflag
flags.Var(&copts.env, "env", "Set environment variables")
// pflag calls copts.env.Set() for each --env flag
```

**Key Characteristics**:
- `Set()` is called once per flag occurrence (enables repeatable flags)
- `String()` provides default value representation
- `Type()` used for help text and type documentation
- Validator runs during `Set()`, providing immediate feedback

---

### 4. Composite Pattern (Complex Option Types)

**Type**: Structural
**Purpose**: Build complex configuration structures from simpler components
**Locations**: `opts/mount.go`, `opts/network.go`, `opts/ulimit.go`

```go
// Leaf component
type NetworkAttachmentOpts struct {
    Target        string
    Aliases       []string
    DriverOpts    map[string]string
    IPv4Address   string
    IPv6Address   string
    LinkLocalIPs  []string
    MacAddress    string
    // ... more fields
}

// Composite - holds collection of leaf components
type NetworkOpt struct {
    options []NetworkAttachmentOpts
}

func (opt *NetworkOpt) Set(value string) error {
    netOpt, err := parseNetworkAttachmentOpt(value)
    if err != nil {
        return err
    }
    opt.options = append(opt.options, netOpt)
    return nil
}

// Parsing logic handles multiple sub-options in single flag value
// --network name=foo,ip=1.2.3.4,alias=bar
func parseNetworkAttachmentOpt(value string) (NetworkAttachmentOpts, error) {
    netAttach := NetworkAttachmentOpts{}
    // Parse key=value pairs from comma-separated string
    for _, field := range strings.Split(value, ",") {
        key, val := parseKeyValue(field)
        switch key {
        case "name": netAttach.Target = val
        case "ip": netAttach.IPv4Address = val
        case "alias": netAttach.Aliases = append(netAttach.Aliases, val)
        // ... more cases
        }
    }
    return netAttach, nil
}
```

---

### 5. Template Method Pattern (Parse Flow)

**Type**: Behavioral
**Purpose**: Define the skeleton of the parsing algorithm, allowing subclasses/callers to customize certain steps
**Locations**: `cli/command/container/opts.go` - `parse()` function

```go
func parse(flags *pflag.FlagSet, copts *containerOptions, serverOS string) (*containerConfig, error) {
    // Step 1: Basic validation (template defines order)
    if copts.macAddress != "" {
        if _, err := net.ParseMAC(strings.TrimSpace(copts.macAddress)); err != nil {
            return nil, fmt.Errorf("%s is not a valid mac address", copts.macAddress)
        }
    }

    // Step 2: Attach stream calculation (algorithm hook point)
    var attachStdin  = copts.attach.Get("stdin")
    var attachStdout = copts.attach.Get("stdout")
    var attachStderr = copts.attach.Get("stderr")
    if copts.stdin {
        attachStdin = true
    }
    if copts.attach.Len() == 0 {
        attachStdout = true
        attachStderr = true
    }

    // Step 3: Platform-specific validation (customization point via serverOS)
    devices := copts.devices.GetSlice()
    for _, device := range devices {
        validated, err := validateDevice(device, serverOS)  // serverOS enables customization
        if err != nil {
            return nil, err
        }
        deviceMapping, err := parseDevice(validated, serverOS)
        // ...
    }

    // Step 4: Aggregate sub-configs (fixed algorithm)
    resources := container.Resources{
        Memory:       copts.memory.Value(),
        CpusetCpus:   copts.cpusetCpus,
        // ... aggregate resource settings
    }

    config := &container.Config{
        Hostname: copts.hostname,
        Env:      envVariables,
        // ... aggregate config settings
    }

    hostConfig := &container.HostConfig{
        Resources: resources,
        // ... aggregate host settings
    }

    // Step 5: Return composite result (fixed)
    return &containerConfig{
        Config:           config,
        HostConfig:       hostConfig,
        NetworkingConfig: networkingConfig,
    }, nil
}
```

**Algorithm Structure**:
1. Validate MAC address, swappiness, other single-value options
2. Calculate derived values (attach streams from multiple flags)
3. Process file-based inputs (env files, label files)
4. Platform-specific validation (device paths differ by OS)
5. Parse complex types (mounts, networks, ports)
6. Aggregate into API structures
7. Cross-validate (e.g., `--rm` conflicts with `--restart`)

---

### 6. Factory Method Pattern (Option Constructors)

**Type**: Creational
**Purpose**: Provide consistent construction interface for option types
**Locations**: `opts/opts.go` - `NewListOpts`, `NewMapOpts`, etc.

```go
// Factory methods
func NewListOpts(validator ValidatorFctType) ListOpts {
    var values []string
    return *NewListOptsRef(&values, validator)
}

func NewListOptsRef(values *[]string, validator ValidatorFctType) *ListOpts {
    return &ListOpts{
        values:    values,
        validator: validator,
    }
}

func NewMapOpts(values map[string]string, validator ValidatorFctType) *MapOpts {
    if values == nil {
        values = make(map[string]string)
    }
    return &MapOpts{
        values:    values,
        validator: validator,
    }
}

// Usage - consistent construction
copts := &containerOptions{
    env:     opts.NewListOpts(opts.ValidateEnv),
    labels:  opts.NewListOpts(opts.ValidateLabel),
    sysctls: opts.NewMapOpts(nil, opts.ValidateSysctl),
}
```

**Pattern Benefits**:
- Encapsulates initialization logic (e.g., map initialization)
- Provides type-safe constructors
- Enables easy addition of new option types
- Consistent API across all option types

---

### 7. Null Object Pattern (Nil Validators)

**Type**: Behavioral
**Purpose**: Allow "no validation" to be expressed as `nil` rather than special-case code
**Locations**: Throughout `opts/` package

```go
// Null object is simply nil
copts := &containerOptions{
    aliases:   opts.NewListOpts(nil),      // No validation needed
    groupAdd:  opts.NewListOpts(nil),      // No validation needed
    dns:       opts.NewListOpts(opts.ValidateIPAddress),  // Validation required
}

// Check in Set() method
func (opts *ListOpts) Set(value string) error {
    if opts.validator != nil {  // Null object check
        v, err := opts.validator(value)
        if err != nil {
            return err
        }
        value = v
    }
    *opts.values = append(*opts.values, value)
    return nil
}
```

---

### 8. Decorator Pattern (Flag Annotations)

**Type**: Structural
**Purpose**: Add metadata to flags without modifying the flag's core behavior
**Locations**: `cli/command/container/opts.go` - `SetAnnotation()` calls

```go
// Base flag registration
flags.Var(&copts.gpus, "gpus", "GPU devices to add to the container")

// Decorate with version requirement
flags.SetAnnotation("gpus", "version", []string{"1.40"})

// Decorate with platform requirement
flags.Int64Var(&copts.cpuCount, "cpu-count", 0, "CPU count (Windows only)")
flags.SetAnnotation("cpu-count", "ostype", []string{"windows"})

// Multiple decorations for complex flags
flags.DurationVar(&copts.healthStartInterval, "health-start-interval", 0, "...")
flags.SetAnnotation("health-start-interval", "version", []string{"1.44"})
```

**Annotation Types**:
- **`version`**: Minimum Docker API version required (enables automatic version checking)
- **`ostype`**: Platform-specific flags (e.g., `windows`, `linux`)
- Used by CLI framework to hide/show flags based on context

---

### 9. Facade Pattern (addFlags Function)

**Type**: Structural
**Purpose**: Provide simplified interface to complex flag registration subsystem
**Locations**: `cli/command/container/opts.go` - `addFlags()` function

```go
// Complex subsystem: pflag, validators, option types, annotations
// Facade provides one-function interface:
func addFlags(flags *pflag.FlagSet) *containerOptions {
    // Hides complexity of:
    // - Creating 90+ option objects with validators
    // - Registering flags with correct types
    // - Setting up annotations
    // - Handling flag aliases
    // - Managing deprecations

    copts := &containerOptions{
        // 40+ custom option type initializations
    }

    // 90+ flag registrations with annotations

    return copts
}

// Commands use simple facade:
cmd := &cobra.Command{
    RunE: func(cmd *cobra.Command, args []string) error {
        copts := addFlags(cmd.Flags())  // One call does everything
        // Use copts...
    },
}
```

---

### 10. Data Transfer Object (DTO) Pattern

**Type**: Structural
**Purpose**: Transport data between flag parsing layer and API layer
**Locations**: `containerOptions` (intermediate DTO), `containerConfig` (output DTO)

```go
// Input DTO - holds parsed flag values
type containerOptions struct {
    // Fields match flag names/types
    hostname string
    memory   opts.MemBytes
    env      opts.ListOpts
    // ... 90+ fields
}

// Output DTO - holds API-ready structs
type containerConfig struct {
    Config           *container.Config
    HostConfig       *container.HostConfig
    NetworkingConfig *network.NetworkingConfig
}

// Transformation function
func parse(flags *pflag.FlagSet, copts *containerOptions, serverOS string) (*containerConfig, error) {
    // Transform input DTO to output DTO
    return &containerConfig{
        Config:     buildConfig(copts),
        HostConfig: buildHostConfig(copts),
        NetworkingConfig: buildNetworkingConfig(copts),
    }, nil
}
```

---

## Coding Conventions

### Naming Conventions

| Element | Convention | Example | Notes |
|---------|------------|---------|-------|
| Packages | lowercase, single word | `opts`, `container` | No underscores |
| Exported Types | PascalCase | `ListOpts`, `MemBytes` | Exported from package |
| Unexported Types | camelCase | `containerOptions`, `containerConfig` | Package-private |
| Exported Functions | PascalCase | `ValidateIPAddress`, `NewListOpts` | |
| Unexported Functions | camelCase | `addFlags`, `parse`, `parseDevice` | |
| Struct Fields (exported) | PascalCase | `Config`, `HostConfig` | JSON/API types |
| Struct Fields (unexported) | camelCase | `values`, `validator` | Internal only |
| Interface Methods | PascalCase | `Set()`, `String()`, `Type()` | Go convention |
| Constants | PascalCase or camelCase | `seccompProfileDefault` | Mixed approach |
| Flag Names | kebab-case | `--cpu-shares`, `--memory` | CLI convention |
| Flag Short Names | single letter | `-m`, `-e`, `-v` | Common flags only |
| Test Functions | TestPascalCase | `TestParseRunAttach` | Standard Go |
| Validator Functions | ValidatePascalCase | `ValidateIPAddress` | Clear intent |

**Naming Patterns**:
- **Validators**: Always start with `Validate` prefix
- **Constructors**: Start with `New` prefix (`NewListOpts`)
- **Getters**: Start with `Get` prefix (`GetSlice`, `GetMap`, `GetAll`)
- **Checkers**: Use verb form (`validDeviceMode`, not `deviceModeIsValid`)
- **Parsers**: Start with `parse` prefix (`parseLoggingOpts`, `parseDevice`)

---

### Code Structure

**Function Length**: Short to medium (most functions 10-50 lines)
- `addFlags()`: 180 lines (acceptable - it's a registration catalog)
- `parse()`: 400 lines (large but cohesive - transformation logic)
- Most helper functions: 10-30 lines

**File Organization**:
```
cli/command/container/
├── opts.go              # Core pattern implementation (740 lines)
│   ├── containerOptions struct
│   ├── addFlags() function
│   ├── parse() function
│   └── Helper functions (parseDevice, validateDevice, etc.)
├── opts_test.go         # Unit tests (1200+ lines)
├── run.go               # Command using the pattern
└── create.go            # Command using the pattern

opts/
├── opts.go              # Base option types (ListOpts, MapOpts)
├── mount.go             # Mount-specific option type
├── network.go           # Network-specific option type
├── ulimit.go            # Ulimit-specific option type
└── ... more specialized types
```

**Struct Organization**:
```go
type containerOptions struct {
    // Custom option types first (complex types)
    attach            opts.ListOpts
    volumes           opts.ListOpts
    mounts            opts.MountOpt
    // ... grouped by similarity

    // Simple types second
    hostname     string
    memory       opts.MemBytes
    cpuShares    int64
    // ... grouped by domain (network, resources, etc.)

    // Special fields last
    Image string
    Args  []string
}
```

**Comment Style**:
- Moderate commenting - focus on "why" not "what"
- Flag groups have section comments (`// Security`, `// Network and port publishing`)
- Complex logic has inline explanations
- No obvious comments (e.g., no "// Set memory" above `memory := ...`)

**Nesting Depth**: Shallow to moderate
- Most code: 1-3 levels
- Complex parsing: up to 4 levels (acceptable in `parse()`)
- Early returns used to reduce nesting

---

### Error Handling Pattern

**Convention**: Explicit error returns with context-rich messages

```go
// Pattern 1: Immediate validation with context
if copts.macAddress != "" {
    if _, err := net.ParseMAC(strings.TrimSpace(copts.macAddress)); err != nil {
        return nil, fmt.Errorf("%s is not a valid mac address", copts.macAddress)
    }
}

// Pattern 2: Validator functions return (value, error)
func ValidateIPAddress(val string) (string, error) {
    if ip := net.ParseIP(strings.TrimSpace(val)); ip != nil {
        return ip.String(), nil  // Normalized value
    }
    return "", fmt.Errorf("IP address is not correctly formatted: %s", val)
}

// Pattern 3: Deferred validation in parse()
func parse(flags *pflag.FlagSet, copts *containerOptions, serverOS string) (*containerConfig, error) {
    // Validators have already run during flag.Parse()
    // This does cross-flag validation and transformations

    if copts.autoRemove && !hostConfig.RestartPolicy.IsNone() {
        return nil, errors.New("conflicting options: cannot specify both --restart and --rm")
    }

    if copts.noHealthcheck && haveHealthSettings {
        return nil, errors.New("--no-healthcheck conflicts with --health-* options")
    }

    return result, nil
}

// Pattern 4: Error wrapping (not shown in older code, but emerging)
// Modern Go would use:
// return nil, fmt.Errorf("failed to parse device %s: %w", device, err)
```

**Error Types**:
- **Validation errors**: Returned from validators, include the invalid value
- **Conflict errors**: Returned from `parse()`, describe the conflicting flags
- **Parse errors**: Returned from parsing functions, include context
- **No panic()**: Errors are always returned, never panicked (except in test helpers)

**Error Propagation**:
- Errors bubble up through return values
- Callers check errors immediately after function calls
- `err != nil` checks are consistent
- Ignored errors are explicitly marked with `_ =` (e.g., `_ = flags.MarkDeprecated(...)`)

---

### Flag Aliasing and Deprecation Patterns

#### Flag Aliasing Pattern

Used to maintain backward compatibility while transitioning to preferred flag names:

```go
// Register both flags pointing to same variable
flags.Var(&copts.dnsOptions, "dns-opt", "Set DNS options")
flags.Var(&copts.dnsOptions, "dns-option", "Set DNS options")
flags.MarkHidden("dns-opt")  // Hide deprecated alias

// Net vs network aliasing
flags.Var(&copts.netMode, "net", "Connect a container to a network")
flags.Var(&copts.netMode, "network", "Connect a container to a network")
flags.MarkHidden("net")  // Prefer --network

// Net-alias vs network-alias
flags.Var(&copts.aliases, "net-alias", "Add network-scoped alias")
flags.Var(&copts.aliases, "network-alias", "Add network-scoped alias")
flags.MarkHidden("net-alias")
```

**Pattern Characteristics**:
- Both flags point to same underlying variable
- Deprecated flag is hidden from help text but still functional
- Comment explains rationale (`// although the latter is the recommended way`)
- Maintains CLI backward compatibility indefinitely

#### Deprecation Pattern

For flags being phased out:

```go
// Create stub variable that's not used
var stub opts.MemBytes
flags.Var(&stub, "kernel-memory", "Kernel memory limit (deprecated)")
_ = flags.MarkDeprecated("kernel-memory", "and no longer supported by the kernel")

// In run.go:
flags.Bool("disable-content-trust", true, "Skip image verification (deprecated)")
_ = flags.MarkDeprecated("disable-content-trust", "support for docker content trust was removed")
```

**Pattern Characteristics**:
- Stub variable prevents breaking existing scripts
- `MarkDeprecated()` shows deprecation warning when flag is used
- Deprecation message explains why (removed feature, kernel limitation)
- Error return from `MarkDeprecated` is ignored (it's best-effort)

#### Version Annotation Pattern

For new flags not available in older API versions:

```go
flags.Var(&copts.gpus, "gpus", "GPU devices to add")
flags.SetAnnotation("gpus", "version", []string{"1.40"})

flags.SetAnnotation("stop-timeout", "version", []string{"1.25"})
flags.SetAnnotation("cgroupns", "version", []string{"1.41"})
```

**Pattern Characteristics**:
- CLI framework uses this to automatically check API version
- Prevents sending unsupported flags to older daemons
- Version is Docker API version (not CLI version)
- Enables graceful degradation

#### Platform Annotation Pattern

For OS-specific flags:

```go
flags.Int64Var(&copts.cpuCount, "cpu-count", 0, "CPU count (Windows only)")
flags.SetAnnotation("cpu-count", "ostype", []string{"windows"})

flags.Var(&copts.ioMaxBandwidth, "io-maxbandwidth", "Maximum IO bandwidth (Windows only)")
flags.SetAnnotation("io-maxbandwidth", "ostype", []string{"windows"})
```

---

## Algorithmic Patterns

### 1. Deferred Validation

**Purpose**: Validate flags after all parsing completes, enabling cross-flag validation
**Complexity**: O(n) where n = number of flags

```go
// Phase 1: Flag parsing (validators run here - immediate validation)
flags.Parse(args)  // Calls Set() on each option type

// Phase 2: Cross-flag validation (in parse() - deferred validation)
if copts.autoRemove && !hostConfig.RestartPolicy.IsNone() {
    return nil, errors.New("conflicting options: cannot specify both --restart and --rm")
}

// Phase 3: Platform-specific validation (deferred until serverOS known)
for _, device := range copts.devices.GetSlice() {
    validated, err := validateDevice(device, serverOS)  // serverOS needed here
    // ...
}
```

**Key Insight**: Two-phase validation enables both immediate feedback (during parsing) and context-aware validation (after parsing).

---

### 2. List Deduplication

**Purpose**: Handle repeated flags by storing unique values
**Complexity**: O(n) for conversion to map

```go
// GetMap returns deduplicated values
func (opts *ListOpts) GetMap() map[string]struct{} {
    ret := make(map[string]struct{})
    for _, k := range *opts.values {
        ret[k] = struct{}{}  // Deduplicates automatically
    }
    return ret
}

// Usage for volumes
volumes := copts.volumes.GetMap()  // Deduplicated
for bind := range volumes {
    // Process each unique volume
}
```

---

### 3. Flag Change Detection

**Purpose**: Distinguish between explicit zero values and unset flags
**Approach**: Use pflag's `Changed()` method

```go
// Detect if flag was explicitly set
if flags.Changed("entrypoint") {
    entrypoint = []string{""}  // User explicitly cleared entrypoint
} else if copts.entrypoint != "" {
    entrypoint = []string{copts.entrypoint}  // User provided value
}
// Otherwise: entrypoint remains nil (unset)

// Used for optional fields
if flags.Changed("stop-timeout") {
    config.StopTimeout = &copts.stopTimeout  // Explicitly set
}
// Otherwise: nil means "use default"

if flags.Changed("init") {
    hostConfig.Init = &copts.init  // Explicitly set to true or false
}
// Otherwise: nil means "let daemon decide"
```

**Key Insight**: This pattern enables three-state booleans and distinguishes "zero value set" from "not set".

---

### 4. String Cutting (Go 1.18+)

**Purpose**: Split strings without allocating unnecessary slices
**Approach**: Use `strings.Cut()` instead of `strings.Split()`

```go
// Modern approach (allocates less)
key, value, ok := strings.Cut(str, "=")
if !ok {
    // No "=" found
}

// Older approach (allocates slice)
parts := strings.Split(str, "=")
if len(parts) != 2 {
    // Wrong format
}
key := parts[0]
value := parts[1]
```

**Pattern seen in**:
- `MapOpts.Set()`: `k, v, _ := strings.Cut(value, "=")`
- Volume parsing: `hostPart, targetPath, ok := strings.Cut(bind, ":")`
- Tmpfs parsing: `k, v, _ := strings.Cut(t, ":")`

---

## Testing Patterns

### Test Structure

**Framework**: `gotest.tools/v3` (not standard `testing` only)
**Assertion Style**: `assert.NilError()` and `is` package (from `gotest.tools`)

```go
import (
    "testing"
    "gotest.tools/v3/assert"
    is "gotest.tools/v3/assert/cmp"  // Aliased as "is"
)

func TestParseRunAttach(t *testing.T) {
    // Setup
    config, hostConfig, _, err := parseRun([]string{"--attach=stdin", "busybox"})

    // Assertions - explicit error checking
    assert.NilError(t, err)
    assert.Check(t, config.AttachStdin)
    assert.Check(t, !config.AttachStdout)
    assert.Check(t, is.Equal(config.Image, "busybox"))
}
```

### Table-Driven Tests

**Pattern**: Use structs to define test cases

```go
func TestParseRunLinks(t *testing.T) {
    tests := []struct {
        name               string           // Test case name
        input              string           // Flags to parse
        expHostConfigLinks []string         // Expected result
        expNetConfigLinks  map[string][]string
    }{
        {
            name:               "default/onelink",
            input:              "--link a:b",
            expHostConfigLinks: []string{"a:b"},
            expNetConfigLinks:  map[string][]string{"default": nil},
        },
        {
            name:               "default/twolinks",
            input:              "--link a:b --link c:d",
            expHostConfigLinks: []string{"a:b", "c:d"},
            expNetConfigLinks:  map[string][]string{"default": nil},
        },
        // ... more test cases
    }

    for _, tc := range tests {
        t.Run(tc.name, func(t *testing.T) {
            _, hostConfig, netConfig, err := parseRun(strings.Split(tc.input+" busybox", " "))
            assert.NilError(t, err)
            assert.DeepEqual(t, hostConfig.Links, tc.expHostConfigLinks)
            assert.DeepEqual(t, netConfig.EndpointsConfig, tc.expNetConfigLinks)
        })
    }
}
```

### Test Helpers

**Pattern**: Reusable setup and assertion functions

```go
// Setup helper
func setupRunFlags() (*pflag.FlagSet, *containerOptions) {
    flags := pflag.NewFlagSet("run", pflag.ContinueOnError)
    flags.SetOutput(io.Discard)  // Suppress error output
    flags.Usage = nil            // Disable usage printing
    copts := addFlags(flags)
    return flags, copts
}

// Parsing helper
func parseRun(args []string) (*container.Config, *container.HostConfig, *networktypes.NetworkingConfig, error) {
    flags, copts := setupRunFlags()
    if err := flags.Parse(args); err != nil {
        return nil, nil, nil, err
    }
    containerCfg, err := parse(flags, copts, runtime.GOOS)
    if err != nil {
        return nil, nil, nil, err
    }
    return containerCfg.Config, containerCfg.HostConfig, containerCfg.NetworkingConfig, err
}

// Assertion helper
func mustParse(t *testing.T, args string) (*container.Config, *container.HostConfig, *networktypes.NetworkingConfig) {
    t.Helper()  // Mark as test helper for better stack traces
    config, hostConfig, nwConfig, err := parseRun(append(strings.Split(args, " "), "ubuntu", "bash"))
    assert.NilError(t, err)
    return config, hostConfig, nwConfig
}
```

### Platform-Specific Tests

**Pattern**: Use `skip.If()` to conditionally skip tests

```go
func TestParseDevice(t *testing.T) {
    skip.If(t, runtime.GOOS != "linux")  // Skip on non-Linux

    // Linux-specific test logic
}
```

### Mock Helper Pattern

**Pattern**: Test helpers that create common test values

```go
func mustParseMAC(s string) networktypes.HardwareAddr {
    mac, err := net.ParseMAC(s)
    if err != nil {
        panic(err)  // OK in test helper - fail fast
    }
    return networktypes.HardwareAddr(mac)
}

// Usage in tests
expected := mustParseMAC("92:d0:c6:0a:29:33")
```

---

## Composition vs Inheritance Patterns

Go doesn't support classical inheritance, so Docker CLI uses **composition** exclusively:

### 1. Struct Embedding (Go's "Inheritance")

```go
// Base options
type createOptions struct {
    name         string
    platform     string
    pull         string
    quiet        bool
    useAPISocket bool
}

// Extended options via embedding
type runOptions struct {
    createOptions  // Embedded struct - "inherits" fields
    detach     bool
    sigProxy   bool
    detachKeys string
}

// Usage - embedded fields accessible directly
func (opts *runOptions) validate() error {
    if opts.name == "" {  // Access embedded field
        return errors.New("name required")
    }
    if opts.detach && opts.sigProxy {  // Mix embedded and direct fields
        return errors.New("conflict")
    }
    return nil
}
```

**Pattern**: Embedding provides field access but not polymorphism.

---

### 2. Interface Composition

```go
// From pflag library (simplified)
type Value interface {
    String() string
    Set(string) error
    Type() string
}

// Cobra extends pflag.Value
type SliceValue interface {
    Value           // Embedded interface
    GetSlice() []string
}

// ListOpts implements both interfaces
func (opts *ListOpts) String() string { /* ... */ }
func (opts *ListOpts) Set(string) error { /* ... */ }
func (opts *ListOpts) Type() string { /* ... */ }
func (opts *ListOpts) GetSlice() []string { /* ... */ }
```

**Pattern**: Interface embedding combines multiple interfaces.

---

### 3. Functional Composition (Validator Chain)

```go
// Not used in current code, but natural extension:
func ChainValidators(validators ...ValidatorFctType) ValidatorFctType {
    return func(val string) (string, error) {
        result := val
        for _, validator := range validators {
            var err error
            result, err = validator(result)
            if err != nil {
                return "", err
            }
        }
        return result, nil
    }
}

// Hypothetical usage
validateDNSIP := ChainValidators(
    opts.ValidateIPAddress,
    validateDNSReachable,
)
```

**Pattern**: Functions composing functions (not currently used but idiomatic Go).

---

### Why No Inheritance?

Go's philosophy: **"Composition over inheritance"**

**Benefits seen in Docker CLI**:
1. **Explicit dependencies**: `runOptions` clearly shows it uses `createOptions`
2. **No hidden state**: All fields are visible in struct definition
3. **No fragile base class**: Changes to `createOptions` don't break `runOptions` polymorphically
4. **Interface segregation**: Types implement only what they need (`pflag.Value`)
5. **Testability**: Easy to construct test structs with specific fields

---

## Code Style and Go Idioms

### 1. Pointer vs Value Receivers

**Consistent pattern**:
- **Pointer receivers** for methods that modify state: `func (opts *ListOpts) Set(value string) error`
- **Value receivers** for methods that don't need mutation: `func (*ListOpts) Type() string`
- Exception: pflag.Value methods use pointer receivers for consistency (interface requirement)

### 2. Named Return Values

**Rare usage** - only in complex functions for clarity:
```go
// Not common in codebase
func parseDevice(device, serverOS string) (deviceMapping container.DeviceMapping, err error) {
    // Named returns can be clearer in complex logic
}
```

**More common** - unnamed returns:
```go
func ValidateIPAddress(val string) (string, error) {
    // ...
    return ip.String(), nil
}
```

### 3. Early Returns

**Heavily used** to reduce nesting:
```go
func validateAttach(val string) (string, error) {
    s := strings.ToLower(val)

    // Early return for all valid cases
    for _, str := range []string{"stdin", "stdout", "stderr"} {
        if s == str {
            return s, nil
        }
    }

    // Only reach here if invalid
    return val, fmt.Errorf("valid streams are STDIN, STDOUT and STDERR")
}
```

### 4. Variable Declaration Style

```go
// Preferred: short declaration with inference
copts := &containerOptions{}
values := make(map[string]string)

// Used when type ambiguous
var values []string  // Want nil slice, not empty slice

// Multiple related vars
var (
    attachStdin  = copts.attach.Get("stdin")
    attachStdout = copts.attach.Get("stdout")
    attachStderr = copts.attach.Get("stderr")
)
```

### 5. String Building

```go
// Simple concatenation for few strings
toBind = hostPart + ":" + targetPath

// fmt.Sprintf for formatting
return "", fmt.Errorf("%s is not a valid mac address", copts.macAddress)

// strings.Builder not used (would be for many concatenations)
```

### 6. Struct Initialization

```go
// Preferred: field names for clarity
copts := &containerOptions{
    aliases:   opts.NewListOpts(nil),
    attach:    opts.NewListOpts(validateAttach),
    dns:       opts.NewListOpts(opts.ValidateIPAddress),
}

// Also common: zero value then set fields
restartPolicy, err := opts.ParseRestartPolicy(copts.restartPolicy)
if err != nil {
    return nil, err
}
resources := container.Resources{
    RestartPolicy: restartPolicy,
    Memory:        copts.memory.Value(),
}
```

### 7. Empty Slice vs Nil Slice

**Semantic difference**:
```go
// Nil slice - not initialized
var values []string  // Marshals to null in JSON

// Empty slice - explicitly empty
values := make([]string, 0)  // Marshals to [] in JSON

// Pattern for "always return non-nil"
func (opts *ListOpts) GetAllOrEmpty() []string {
    v := *opts.values
    if v == nil {
        return make([]string, 0)  // Ensure non-nil
    }
    return v
}
```

### 8. Error Wrapping (Modern Go)

**Note**: Docker CLI code predates Go 1.13 error wrapping, so uses older style:
```go
// Current style in codebase
return fmt.Errorf("invalid device: %s", device)

// Modern Go would use %w
return fmt.Errorf("invalid device %s: %w", device, err)
```

---

## Pattern Consistency Assessment

| Area | Consistency | Notes |
|------|-------------|-------|
| Naming | **High** | Strong adherence to Go conventions. Flag names consistently kebab-case. Validator functions always prefixed with `Validate`. Minor inconsistency: some consts are camelCase, some PascalCase. |
| Error Handling | **High** | Explicit error returns everywhere. Errors always include context. No panics in production code (only test helpers). Consistent use of `fmt.Errorf` for error messages. |
| Code Structure | **High** | Consistent file organization. Functions grouped by purpose. Helper functions near usage. Option types all follow same structure pattern. |
| Testing | **High** | Table-driven tests for all parsing functions. Consistent use of `assert.NilError()` and `is` comparisons. Test helpers reduce duplication. Platform-specific tests use `skip.If()`. |
| Flag Registration | **Very High** | Uniform pattern across all 90+ flags. Annotations applied consistently. Aliases handled identically. Comments group related flags. |
| Option Types | **Very High** | All implement pflag.Value interface. All have factory functions (`New*`). All follow Set/String/Type/Get* naming. Validators injected at construction. |
| Validation | **High** | Validators consistently return `(string, error)`. Two-phase validation (immediate + deferred) applied uniformly. Cross-flag validation in `parse()`. |
| Composition | **High** | Consistent use of struct embedding. No attempted inheritance patterns. Interfaces used appropriately. |

**Overall Assessment**: The codebase demonstrates exceptional pattern consistency, indicating:
- Mature design that evolved over time
- Strong code review practices
- Clear architectural vision
- Team alignment on Go idioms

---

## Inconsistencies

### 1. Constant Naming

**Location**: `cli/command/container/opts.go`

```go
// camelCase
const seccompProfileDefault = "default"
const seccompProfileUnconfined = "unconfined"

// Would be more consistent as:
// const SeccompProfileDefault = "default"  (exported)
// OR
// const seccomp_profile_default = "default"  (snake_case, rare in Go)
```

**Impact**: Minor - doesn't affect functionality, just style.

---

### 2. Variable Initialization

**Location**: Throughout `opts.go`

```go
// Sometimes: var then assign
var values []string
return *NewListOptsRef(&values, validator)

// Sometimes: inline
return &ListOpts{
    values:    values,
    validator: validator,
}

// Sometimes: make()
if values == nil {
    values = make(map[string]string)
}
```

**Impact**: Minor - just style variation.

---

### 3. Error Message Format

**Location**: Various

```go
// Some errors start with lowercase
return errors.New("conflicting options: cannot specify both --restart and --rm")

// Some with uppercase
return errors.New("--pid: invalid PID mode")

// Some reference the flag
return fmt.Errorf("%s is not a valid mac address", copts.macAddress)

// Some don't
return errors.New("--no-healthcheck conflicts with --health-* options")
```

**Impact**: Minor - all are clear, just not uniformly formatted.

---

### 4. Stub Variable Naming

**Location**: Deprecation pattern

```go
// In addFlags()
var stub opts.MemBytes  // Generic name

// Could be more descriptive
var deprecatedKernelMemory opts.MemBytes
```

**Impact**: Minor - doesn't affect users, just internal readability.

---

### 5. Comment Consistency

**Location**: Flag registration

```go
// Some flags have inline comments explaining why
// We allow for both "--net" and "--network", although the latter is the recommended way.

// Similar flags lack explanation
flags.Var(&copts.dnsOptions, "dns-opt", "Set DNS options")
flags.Var(&copts.dnsOptions, "dns-option", "Set DNS options")
// Missing: "We allow both for consistency with service commands"
```

**Impact**: Minor - documentation inconsistency only.

---

## Adaptation Recommendations

### Essential Patterns (Must Preserve)

These patterns are **critical** for the architecture to work:

1. **Intermediate Storage Pattern**: The `containerOptions` → `parse()` → `containerConfig` flow is the core of the DRY design. Must preserve.
2. **pflag.Value Interface**: Custom option types must implement this interface for pflag integration.
3. **Strategy Pattern for Validators**: Validator injection enables flexible validation without modifying option types.
4. **Factory Methods**: `NewListOpts()`, `NewMapOpts()` etc. provide consistent construction.
5. **Two-Phase Validation**: Immediate validation in `Set()`, deferred cross-validation in `parse()`.

### Style Patterns (Optional but Recommended)

These improve consistency and maintainability:

1. **Naming Conventions**: Follow Go standards - makes code instantly recognizable to Go developers.
2. **Table-Driven Tests**: Scales well as flag count grows.
3. **Flag Aliasing Pattern**: Essential for backward compatibility in mature CLIs.
4. **Annotation Pattern**: Enables version/platform gating without conditional compilation.
5. **Early Returns**: Reduces nesting, improves readability.

### Anti-patterns to Avoid

Patterns that would **break** the design:

1. **Don't mix parsing and execution**: Keep flag parsing separate from business logic.
2. **Don't validate in constructors**: Validators should run in `Set()`, not in `New*()`.
3. **Don't couple option types to commands**: Option types should be reusable across commands.
4. **Don't use global state**: All state should flow through `containerOptions`.
5. **Don't skip the intermediate struct**: Going directly from flags to API types loses the DRY benefit.
6. **Don't panic on user input**: Always return errors, let command layer decide how to handle.

### Language-Specific Considerations

**Go-specific patterns** (may not translate to other languages):

- **Interface-based polymorphism**: Other languages might use abstract classes (Java, C#) or protocols (Swift)
- **Pointer receivers**: Languages with implicit references (Python, Ruby) don't need this distinction
- **nil vs empty slice**: Languages with single null/None value don't have this distinction
- **Multiple return values**: Languages without this feature would use Result<T, E> types or exceptions
- **Embedding**: Languages with inheritance would use base classes instead

**Transferable patterns** (work in any language):

- Intermediate storage (DTO) pattern
- Strategy pattern for validators
- Factory method pattern
- Decorator pattern for annotations
- Two-phase validation
- Table-driven tests

### Configuration and Build Patterns

**Not shown in source code but important**:

1. **Vendor directory**: Docker CLI uses `vendor/` for all dependencies (no dynamic resolution)
2. **Docker-based builds**: All building happens in containers (reproducible builds)
3. **BuildKit/Bake**: Uses `docker buildx bake` for complex build configurations
4. **Platform matrix**: Single source builds for multiple OS/architectures
5. **CalVer versioning**: Uses `vendor.mod` instead of `go.mod` due to CalVer (not SemVer)

---

## Summary

The Docker CLI container options implementation is a **masterclass in DRY design**. The patterns work together to achieve:

1. **Single Source of Truth**: 90+ flags defined once in `addFlags()`, shared by multiple commands
2. **Flexible Validation**: Strategy pattern allows per-flag validation logic without coupling
3. **Clean Separation**: Parsing layer (pflag) is isolated from API layer (Docker types)
4. **Extensibility**: New flags require changes in only 3 places: struct field, flag registration, usage in `parse()`
5. **Backward Compatibility**: Aliasing and deprecation patterns maintain stable CLI interface
6. **Type Safety**: pflag.Value interface ensures type-safe flag handling
7. **Testability**: Clean interfaces enable comprehensive table-driven tests

**Key Takeaways**:
- Pattern consistency is **very high** - indicates mature, well-reviewed codebase
- Most patterns are **language-agnostic** and transferable to other languages
- The **Intermediate Storage Pattern** is the architectural keystone
- **Two-phase validation** (immediate + deferred) is critical for good UX
- **Strategy pattern** provides the flexibility needed for 90+ different flag types

**For Adaptation**:
- Preserve the intermediate storage → parse → output flow
- Implement equivalent of pflag.Value in your language
- Use strategy pattern for validators
- Follow the two-phase validation approach
- Apply flag annotations for version/platform gating
- Use composition, not inheritance, for code reuse
