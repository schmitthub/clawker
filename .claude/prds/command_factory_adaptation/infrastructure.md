# Infrastructure Requirements: GitHub CLI Command Factory System

> Generated by infra-analyzer for github.com/cli/cli
>
> Focus: Command Factory pattern build system, tooling, and operational requirements
> Date: 2026-01-28

---

## Infrastructure Summary

```
Build System: GNU Make + Go build scripts
Language Runtime: Go 1.25.5
Build Tool: go build with custom script/build.go orchestration
Containerized: No (binary distribution model)
CI/CD Platform: GitHub Actions
Code Quality: golangci-lint v2.6.0
Release Tool: GoReleaser v2.13.1
Documentation Generation: Custom gen-docs tool
Completion Generation: Cobra built-in + custom shell scripts
Test Framework: Go testing + acceptance tests (optional)
```

---

## Build System Architecture

### Build Orchestration Model

The GitHub CLI uses a **two-layer build system**:

1. **Layer 1: Make targets** - Platform-agnostic task definitions
   - `Makefile` provides portable task names across Unix/Windows
   - Delegates actual work to Go scripts

2. **Layer 2: Go build scripts** - Cross-platform execution
   - `script/build.go` handles platform-specific concerns
   - Runs as a Go program (not shell script) for Windows compatibility
   - Bootstraps itself on first invocation

### Build File Structure

```
├── Makefile                 # Task definitions
├── script/
│   ├── build.go            # Main build orchestrator
│   ├── build.exe           # Bootstrapped Windows executable
│   ├── release             # Release script with platform support
│   ├── licenses            # License compliance check
│   ├── licenses-check      # License audit tool
│   └── pkgmacos            # macOS package builder
├── cmd/
│   ├── gh/
│   │   └── main.go         # Binary entry point
│   └── gen-docs/
│       └── main.go         # Documentation generator
└── pkg/
    ├── cmd/
    │   ├── factory/        # Factory implementation
    │   ├── root/           # Root command tree
    │   └── [command]/      # Individual commands
    └── cmdutil/
        └── factory.go      # Factory struct definition
```

---

## Build System Details

### Primary Build: Binary Compilation

**Makefile Target Definition:**
```makefile
.PHONY: bin/gh$(EXE)
bin/gh$(EXE): script/build$(EXE)
	@script/build$(EXE) $@

script/build$(EXE): script/build.go
ifeq ($(EXE),)
	GOOS= GOARCH= GOARM= GOFLAGS= CGO_ENABLED= go build -o $@ $<
else
	go build -o $@ $<
endif
```

**What happens:**
1. Make resolves platform-specific executable extension (`EXE`)
2. Bootstraps `script/build.go` as standalone executable
3. Invokes that executable with target task (e.g., `bin/gh`)

### Build Script Invocation: script/build.go

**Key Functions:**

```go
func New(appVersion string) *cmdutil.Factory {
    f := &cmdutil.Factory{
        AppVersion:     appVersion,
        Config:         configFunc(),
        ExecutableName: "gh",
    }
    // Dependencies injected in order of their dependencies
    f.IOStreams = ioStreams(f)
    f.HttpClient = httpClientFunc(f, appVersion)
    f.PlainHttpClient = plainHttpClientFunc(f, appVersion)
    f.GitClient = newGitClient(f)
    f.Remotes = remotesFunc(f)
    f.BaseRepo = BaseRepoFunc(f)
    f.Prompter = newPrompter(f)
    f.Browser = newBrowser(f)
    f.ExtensionManager = extensionManager(f)
    f.Branch = branchFunc(f)
    return f
}
```

**Build Process:**

1. **Version Detection** (line 49-50):
   ```bash
   ldflags: "-X github.com/cli/cli/v2/internal/build.Version=<VERSION>"
   ldflags: "-X github.com/cli/cli/v2/internal/build.Date=<DATE>"
   ```

2. **OAuth Credentials** (optional, lines 51-54):
   ```bash
   ldflags: "-X github.com/cli/cli/v2/internal/authflow.oauthClientSecret=<SECRET>"
   ldflags: "-X github.com/cli/cli/v2/internal/authflow.oauthClientID=<ID>"
   ```

3. **Build Command** (line 58-62):
   ```bash
   go build -trimpath \
     [-tags <GO_BUILDTAGS>] \
     -ldflags "<VERSION> <DATE> <OAUTH> <GO_LDFLAGS>" \
     -o bin/gh \
     ./cmd/gh
   ```

### Version Injection Points

**Internal Build Package** (`internal/build/build.go`):
```go
// Version is dynamically set by the toolchain or overridden by the Makefile.
var Version = "DEV"

// Date is dynamically set at build time in the Makefile.
var Date = "" // YYYY-MM-DD

func init() {
    // Fallback to debug info if not set via ldflags
    if Version == "DEV" {
        if info, ok := debug.ReadBuildInfo(); ok && info.Main.Version != "(devel)" {
            Version = info.Main.Version
        }
    }
    // Tcell optimization for startup performance
    _ = os.Setenv("TCELL_MINIMIZE", "1")
}
```

**Consumed by:** `internal/ghcmd/cmd.go` line 43-44
```go
buildDate := build.Date
buildVersion := build.Version
```

### Build Environment Variables

| Variable | Required | Purpose | Example |
|----------|----------|---------|---------|
| `GH_VERSION` | No | Override auto-detected version | `v2.45.0` |
| `GH_OAUTH_CLIENT_ID` | No (if using OAuth) | OAuth app ID for auth flow | Set by CI/CD |
| `GH_OAUTH_CLIENT_SECRET` | No (if using OAuth) | OAuth app secret for auth flow | Set by CI/CD |
| `SOURCE_DATE_EPOCH` | No | Unix timestamp for reproducible builds | Used in CI/CD |
| `GO_LDFLAGS` | No | Additional linker flags | Architecture-specific flags |
| `GO_BUILDTAGS` | No | Conditional build tags | `integration`, `acceptance` |
| `GOOS` | No | Target OS override | `linux`, `darwin`, `windows` |
| `GOARCH` | No | Target architecture override | `amd64`, `arm64` |
| `CGO_ENABLED` | No | C interop flag (usually 0 for portability) | `0` or `1` |

### Reproducible Builds

The build script supports `SOURCE_DATE_EPOCH` (Unix timestamp) for reproducible builds:

```go
func date() string {
    t := time.Now()
    if sourceDate := os.Getenv("SOURCE_DATE_EPOCH"); sourceDate != "" {
        if sec, err := strconv.ParseInt(sourceDate, 10, 64); err == nil {
            t = time.Unix(sec, 0)
        }
    }
    return t.Format("2006-01-02")
}
```

This ensures binary builds are bit-for-bit identical given the same source.

---

## Command Factory Pattern

### Factory Implementation Flow

**Entry Point:** `cmd/gh/main.go`
```go
func main() {
    code := ghcmd.Main()
    os.Exit(int(code))
}
```

**Initialization:** `internal/ghcmd/cmd.go` (Main function)
```go
func Main() exitCode {
    buildDate := build.Date
    buildVersion := build.Version

    // Create factory with version
    cmdFactory := factory.New(buildVersion)

    // Create root command tree
    rootCmd, err := root.NewCmdRoot(cmdFactory, buildVersion, buildDate)
    if err != nil {
        return exitError
    }

    // Execute with args
    // ...
}
```

### Factory Struct Definition

**Location:** `pkg/cmdutil/factory.go`

```go
type Factory struct {
    AppVersion     string              // Version for display
    ExecutableName string              // "gh" by default

    // Core Dependencies
    Browser          browser.Browser    // Web browser launcher
    ExtensionManager extensions.ExtensionManager
    GitClient        *git.Client
    IOStreams        *iostreams.IOStreams
    Prompter         prompter.Prompter

    // Lazy-loaded Functions (dependency injection)
    BaseRepo        func() (ghrepo.Interface, error)  // Current repository
    Branch          func() (string, error)             // Current git branch
    Config          func() (gh.Config, error)          // Config file
    HttpClient      func() (*http.Client, error)       // Authenticated HTTP client
    PlainHttpClient func() (*http.Client, error)       // Unauthenticated HTTP client
    Remotes         func() (context.Remotes, error)    // Git remotes
}
```

### Factory Creation: pkg/cmd/factory/default.go

**Dependency Initialization Order:**

```go
func New(appVersion string) *cmdutil.Factory {
    f := &cmdutil.Factory{
        AppVersion:     appVersion,
        Config:         configFunc(),              // 1. No dependencies
        ExecutableName: "gh",
    }

    f.IOStreams = ioStreams(f)                     // 2. Depends on Config
    f.HttpClient = httpClientFunc(f, appVersion)   // 3. Depends on Config, IOStreams, appVersion
    f.PlainHttpClient = plainHttpClientFunc(...)   // 4. Depends on IOStreams, appVersion
    f.GitClient = newGitClient(f)                  // 5. Depends on IOStreams, Executable
    f.Remotes = remotesFunc(f)                     // 6. Depends on Config, GitClient
    f.BaseRepo = BaseRepoFunc(f)                   // 7. Depends on Remotes
    f.Prompter = newPrompter(f)                    // 8. Depends on Config, IOStreams
    f.Browser = newBrowser(f)                      // 9. Depends on Config, IOStreams
    f.ExtensionManager = extensionManager(f)       // 10. Depends on Config, HttpClient, IOStreams
    f.Branch = branchFunc(f)                       // 11. Depends on GitClient

    return f
}
```

**Key Design Pattern:**
- Linear initialization guarantees dependencies are available
- Lazy evaluation via function types allows deferring expensive operations
- Each command receives fully-initialized factory

### Command Tree Registration

**Location:** `pkg/cmd/root/root.go`

The root command imports all subcommands:

```go
import (
    accessibilityCmd "github.com/cli/cli/v2/pkg/cmd/accessibility"
    actionsCmd "github.com/cli/cli/v2/pkg/cmd/actions"
    // ... 20+ more commands
    prCmd "github.com/cli/cli/v2/pkg/cmd/pr"
    repoCmd "github.com/cli/cli/v2/pkg/cmd/repo"
    // ...
)

func NewCmdRoot(f *cmdutil.Factory, version, buildDate string) (*cobra.Command, error) {
    cmd := &cobra.Command{
        Use: "gh <command> <subcommand> [flags]",
        // ...
    }

    // Register all commands
    cmd.AddCommand(accessibilityCmd.NewCmdAccessibility(f))
    cmd.AddCommand(actionsCmd.NewCmdActions(f))
    // ... 30+ command registrations

    return cmd, nil
}
```

**Command Pattern:**
Each command follows this structure:
```go
pkg/cmd/<command>/<subcommand>/<subcommand>.go:

func NewCmd<Name>(f *cmdutil.Factory) *cobra.Command {
    var opts <CommandOptions>

    cmd := &cobra.Command{
        Use:   "...",
        Short: "...",
        RunE: func(cmd *cobra.Command, args []string) error {
            return <commandName>Run(&opts)
        },
    }

    // Add flags...

    return cmd
}
```

---

## Module and Dependency Management

### Go Module Configuration

**File:** `go.mod`

```
module github.com/cli/cli/v2
go 1.25.5

require (
    // Primary UI/CLI libraries
    github.com/AlecAivazis/survey/v2 v2.3.7
    github.com/charmbracelet/glamour v0.10.0
    github.com/charmbracelet/huh v0.8.0
    github.com/charmbracelet/lipgloss v1.1.1-0.20250404203927-76690c660834

    // GitHub-specific libraries
    github.com/cli/go-gh/v2 v2.13.0
    github.com/cli/oauth v1.2.1
    github.com/shurcooL/githubv4 v0.0.0-20240727222349-48295856cce7

    // CLI framework
    github.com/spf13/cobra v1.10.2
    github.com/spf13/pflag v1.0.10

    // Testing
    github.com/stretchr/testify v1.11.1

    // Cryptography/Security
    github.com/sigstore/sigstore-go v1.1.4
    github.com/theupdateframework/go-tuf/v2 v2.3.1

    // Miscellaneous
    github.com/cenkalti/backoff/v4 v4.3.0
    github.com/gabriel-vasile/mimetype v1.4.11
    github.com/zalando/go-keyring v0.2.6
    gopkg.in/yaml.v3 v3.0.1
}
```

**Key Dependency Groups:**

| Group | Purpose | Key Packages |
|-------|---------|--------------|
| CLI Framework | Command parsing & execution | cobra, pflag |
| GitHub API | API interactions | go-gh/v2, githubv4 |
| Terminal UI | Rich terminal output | glamour, huh, lipgloss, tcell |
| User Input | Interactive prompts | survey/v2 |
| Security | Signing & verification | sigstore, in-toto |
| Configuration | File & config management | yaml.v3 |
| Testing | Test utilities | testify |

---

## Build Targets

### Available Make Targets

#### Primary Targets

**`make` or `make bin/gh`** - Build main binary
```bash
# Builds platform-appropriate executable
# On Unix: produces bin/gh (executable)
# On Windows: produces bin/gh.exe (executable)
```

**`make clean`** - Remove all built artifacts
```bash
# Deletes: bin/ and share/ directories
rm -rf bin share
```

**`make test`** - Run all tests
```bash
go test ./...  # Runs all *_test.go files recursively
```

**`make acceptance`** - Run acceptance tests
```bash
# Requires GitHub credentials
go test -tags acceptance ./acceptance
# Environment variables:
#   GH_ACCEPTANCE_HOST=github.com
#   GH_ACCEPTANCE_ORG=<org>
#   GH_ACCEPTANCE_TOKEN=<token>
```

#### Documentation Targets

**`make manpages`** - Generate man pages
```bash
# Builds sh share/man/man1/gh.1 and subcommand pages
# Uses cmd/gen-docs tool internally
go run ./cmd/gen-docs --man-page --doc-path ./share/man/man1/
```

**`make completions`** - Generate shell completions
```bash
# Generates completion for bash, fish, zsh
mkdir -p ./share/bash-completion/completions ./share/fish/vendor_completions.d ./share/zsh/site-functions
bin/gh completion -s bash > ./share/bash-completion/completions/gh
bin/gh completion -s fish > ./share/fish/vendor_completions.d/gh.fish
bin/gh completion -s zsh > ./share/zsh/site-functions/_gh
```

**`make install`** - Install binary and documentation
```bash
# Installs to system directories (Unix only):
# Binary: ${DESTDIR}${prefix}/bin/gh
# Man pages: ${DESTDIR}${prefix}/share/man/man1/gh-*.1
# Completions: ${DESTDIR}${prefix}/share/[bash-completion|fish|zsh]/
```

#### Utility Targets

**`make licenses`** - Generate license attribution
```bash
./script/licenses  # Generates LICENSES.md with all dependencies
```

**`make licenses-check`** - Audit license compliance
```bash
./script/licenses-check  # Validates all dependencies have acceptable licenses
```

**`make site-docs`** - Generate website documentation
```bash
# Clones cli.github.com repo and generates markdown documentation
# Requires git and network access
```

#### Configuration

**Environment Variables for Make:**
```makefile
DESTDIR :=                    # Installation root (e.g., for staging)
prefix  := /usr/local         # Installation prefix
bindir  := ${prefix}/bin      # Binary installation directory
datadir := ${prefix}/share    # Data files installation directory
mandir  := ${datadir}/man     # Man pages installation directory
```

Example: `make install DESTDIR=/tmp/staging prefix=/usr`

---

## Linting and Code Quality

### Golangci-lint Configuration

**File:** `.golangci.yml` (v2)

**Enabled Linters:**
```yaml
linters:
  enable:
    - asasalint              # Checks []any in variadic functions
    - asciicheck             # Non-ASCII identifiers
    - bidichk                # Dangerous Unicode sequences
    - bodyclose              # HTTP response body closed
    - copyloopvar            # Loop variable copies (Go 1.22+)
    - durationcheck          # Multiplied durations
    - exptostd               # Replace golang.org/x/exp with std
    - fatcontext             # Nested contexts in loops
    - gocheckcompilerdirectives # Validate //go: directives
    - gochecksumtype         # Exhaustiveness on sum types
    - gocritic               # Bug/performance/style diagnostics
    - gomoddirectives        # replace/retract in go.mod
    - goprintffuncname       # Printf-like functions named with f
    - govet                  # Suspicious constructs
    - ineffassign            # Unused assignments
    - nilerr                 # Return nil despite error check
    - nolintlint             # Ill-formed nolint directives
    - nosprintfhostport      # Sprintf URL construction
    - reassign               # Package variable reassignment
    - unused                 # Unused symbols
```

**Disabled (Too Many Issues):**
```yaml
# - gosec                    # Security checks (has too many issues)
# - staticcheck              # Static analysis (has too many issues)
# - errcheck                 # Unchecked errors (has too many issues)
```

**Linter-Specific Settings:**
```yaml
settings:
  gocritic:
    disabled-checks:
      - appendAssign
    disabled-tags:
      - style

  gosec:
    excludes:
      - G110   # Potential DoS via hash collision
      - G204   # Code execution from user input
      - G301   # Poor file permissions
      - G302   # Poor permission mode
      - G304   # File path from user input
      - G307   # Deferred file close
      - G404   # Use of weak random number
    config:
      G104:    # Unhandled errors in os.Setenv
        os:
          - Setenv

  govet:
    enable:
      - httpresponse  # HTTP response body/headers handling
```

**Exclusions:**
- Test files: `bodyclose` and `gosec` disabled
- `third-party/` directory: all linters disabled

**Run Command:**
```bash
golangci-lint run --version v2.6.0
```

---

## CI/CD Infrastructure

### GitHub Actions Workflows

**Location:** `.github/workflows/`

#### 1. Unit and Integration Tests (`go.yml`)

**Trigger:** Push to `trunk` or PR

**Matrix:** Ubuntu, Windows, macOS (all latest)

**Steps:**
```yaml
- Checkout code
- Setup Go 1.25.5 (from go.mod)
- Download dependencies (go mod download)
- Run tests: go test -race -tags=internals ./...
- Build: go build -v ./cmd/gh
```

**Exit Codes:** Uses `-race` flag to detect race conditions

#### 2. Linting (`lint.yml`)

**Trigger:** Changes to Go/build files

**Steps:**
1. Validate `go.mod` and `go.sum` are up-to-date
   ```bash
   go mod tidy  # Must not modify files
   ```

2. Run golangci-lint v2.6.0
   ```bash
   golangci-lint run
   ```

3. Check licenses with go-licenses
   ```bash
   go install github.com/google/go-licenses/v2@3e084b0caf710f7bfead967567539214f598c0a2
   make licenses-check
   ```

4. Vulnerability check with govulncheck
   ```bash
   go run golang.org/x/vuln/cmd/govulncheck@d1f380186385b4f64e00313f31743df8e4b89a77 ./...
   ```

#### 3. Deployment (`deployment.yml`)

**Trigger:** Manual workflow dispatch

**Inputs:**
- `tag_name` (required): Release version (e.g., `v2.45.0`)
- `environment`: Target deployment (default: `production`)
- `platforms`: CSV of platforms (default: `linux,macos,windows`)
- `release`: Create GitHub Release (default: true)

**Platforms:**
- **Linux:** Ubuntu, uses goreleaser, generates .tar.gz and .rpm
- **macOS:** macOS, uses goreleaser, generates .tar.gz and .dmg
- **Windows:** Windows, uses goreleaser, generates .zip and .msi

**Per-Platform Steps:**
1. Checkout code
2. Setup Go 1.25.5
3. Install GoReleaser v2.13.1
4. Create temporary git tag
5. Run: `script/release --local "<TAG>" --platform <linux|macos|windows>`
6. Generate web docs: `go run ./cmd/gen-docs --website --doc-path dist/manual`
7. Upload artifacts

**Release Artifacts:**
- Binaries (platform-specific format)
- Man pages tarball
- Checksums and signatures (with GoReleaser provenance)

#### 4. Additional Workflows

**codeql.yml** - Security scanning (CodeQL Analysis)
**govulncheck.yml** - Vulnerability scanning (Go vulnerabilities)
**bump-go.yml** - Auto-bump Go version
**homebrew-bump.yml** - Notify Homebrew of releases

---

## Documentation Generation

### Manual Page Generation

**Tool:** `cmd/gen-docs/main.go`

**Invocation:**
```bash
go run ./cmd/gen-docs --man-page --doc-path ./share/man/man1/
```

**Process:**
1. Creates minimal Factory with mocked dependencies
   ```go
   ios, _, _, _ := iostreams.Test()
   rootCmd, _ := root.NewCmdRoot(&cmdutil.Factory{
       IOStreams: ios,
       Browser:   &browser{},
       Config: func() (gh.Config, error) {
           return config.NewFromString(""), nil
       },
       ExtensionManager: &em{},
   }, "", "")
   ```

2. Traverses cobra command tree
3. Generates roff format man pages
4. Outputs to `share/man/man1/gh.1`, `gh-<subcommand>.1`, etc.

**Cobra Integration:**
```go
docs.GenManTree(rootCmd, dirPath)  // Generates .1 files
```

### Website Documentation

**Invocation:**
```bash
go run ./cmd/gen-docs --website --doc-path ./dist/manual
```

**Process:**
1. Generates markdown for each command
2. Prepends Jekyll front matter:
   ```yaml
   ---
   layout: manual
   permalink: /:path/:basename
   ---
   ```
3. Links to relative URLs
4. Outputs to `./dist/manual/*.md`

**Used in:** Release workflow to publish docs to cli.github.com

### Shell Completion Generation

**Method:** Cobra built-in completion

**Invocation:**
```bash
gh completion -s bash  # bash
gh completion -s fish  # fish
gh completion -s zsh   # zsh
```

**Output Locations (after `make completions`):**
- Bash: `share/bash-completion/completions/gh`
- Fish: `share/fish/vendor_completions.d/gh.fish`
- Zsh: `share/zsh/site-functions/_gh`

---

## Testing Infrastructure

### Unit Tests

**Location:** Colocated with source (`*.go` → `*_test.go`)

**Running:**
```bash
go test ./...           # All packages
go test -race ./...     # With race detector
go test -v ./...        # Verbose output
```

**Test Utilities:**
- `pkg/httpmock` - HTTP response mocking
- `pkg/iostreams.Test()` - I/O stream testing
- `stretchr/testify` - Assertions and test utilities

### Acceptance Tests

**Location:** `acceptance/` directory

**Running:**
```bash
GH_ACCEPTANCE_HOST=github.com \
GH_ACCEPTANCE_ORG=<org> \
GH_ACCEPTANCE_TOKEN=<token> \
go test -tags=acceptance ./acceptance

# Single test:
GH_ACCEPTANCE_SCRIPT=pr-view.txtar \
go test -tags=acceptance -run ^TestPullRequests$ ./acceptance
```

**Requirements:**
- GitHub credentials (requires real API access)
- Org with test repositories
- Environment variables for authentication

**Test Format:** `.txtar` files (text archive format) - sequential command execution specs

---

## Development Workflow

### Quick Start for Development

**1. Build the binary:**
```bash
make bin/gh
./bin/gh version
```

**2. Run tests:**
```bash
# Unit tests only
go test ./...

# With race detection
go test -race ./...

# Specific package
go test ./pkg/cmd/issue/...

# Specific test
go test -run TestIssueList ./pkg/cmd/issue/list/
```

**3. Lint code:**
```bash
golangci-lint run
```

**4. Clean build:**
```bash
make clean
make bin/gh
```

### Development Environment Setup

**Prerequisites:**
| Tool | Version | Command |
|------|---------|---------|
| Go | 1.25.5 | `go version` |
| git | Latest | (for version detection) |
| golangci-lint | v2.6.0 | `golangci-lint --version` |
| make | 4.0+ | `make --version` |

**Initial Setup:**
```bash
# Clone repo
git clone https://github.com/cli/cli.git
cd cli

# Install dependencies
go mod download

# Build
make bin/gh

# Verify
./bin/gh --version
```

### Development Patterns

**Adding a New Command:**
1. Create `pkg/cmd/<name>/<name>.go`
2. Implement `NewCmd<Name>(f *cmdutil.Factory) *cobra.Command`
3. Register in `pkg/cmd/root/root.go`: `cmd.AddCommand(...)`
4. Add tests in `pkg/cmd/<name>/<name>_test.go`

**Using Factory:**
```go
func (opts *Options) Run() error {
    cfg, err := opts.Config()
    httpClient, err := opts.HttpClient()
    baseRepo, err := opts.BaseRepo()
    // ...
}
```

**Testing Commands:**
```go
func TestMyCommand(t *testing.T) {
    f, out, _, _ := test.NewFactory()
    cmd := NewCmdExample(f)

    cmd.SetArgs([]string{"arg1"})
    err := cmd.Execute()

    assert.NoError(t, err)
    assert.Contains(t, out.String(), "expected output")
}
```

---

## Build Performance Optimization

### Build Caching

**Incremental Build:** Only rebuilds if source files modified
```go
func (t time.Time) bool {
    err := filepath.Walk(".", func(path string, info os.FileInfo, err error) error {
        if strings.HasSuffix(path, ".go") && !strings.HasSuffix(path, "_test.go") {
            if info.ModTime().After(t) {
                foundLater = true
            }
        }
        return nil
    })
}
```

**Build Output:** `script/build.go` prints:
```
script/build: `bin/gh` is up to date.  # If already built
```

### Go Build Optimization

**Flags Used:**
- `-trimpath` - Removes all file system paths from binary (reproducible + smaller)
- `-race` (in tests) - Detects race conditions (slight overhead)
- `-ldflags` - Link-time variable injection (zero runtime cost)

**Startup Performance:**
```go
// in internal/build/build.go
_ = os.Setenv("TCELL_MINIMIZE", "1")  // Saves 30-40ms startup
```

---

## Reproducible Builds

### Achieving Reproducibility

**Prerequisites:**
1. Same Go version (locked in go.mod)
2. Same source code (locked in git)
3. Deterministic build flags
4. Optional: SOURCE_DATE_EPOCH for timestamp

**Build Command for Reproducible Build:**
```bash
SOURCE_DATE_EPOCH=1234567890 \
  go build -trimpath \
  -ldflags="-X github.com/cli/cli/v2/internal/build.Version=v2.45.0 \
             -X github.com/cli/cli/v2/internal/build.Date=2025-01-28" \
  -o bin/gh \
  ./cmd/gh
```

**Verification:**
```bash
# Build twice with same environment
build1=$(md5 bin/gh)
make clean && make bin/gh
build2=$(md5 bin/gh)

# Should be identical
[[ "$build1" == "$build2" ]] && echo "Reproducible!"
```

---

## Cross-Platform Considerations

### Platform-Specific Concerns

**Executable Extension:**
```makefile
EXE =
ifeq ($(shell go env GOOS),windows)
EXE = .exe
endif
```

**Path Handling:**
- Unix: Uses `/` path separator
- Windows: Handled automatically by Go's `filepath` package
- Build script: Normalizes with `filepath.ToSlash()`

**CGO Handling:**
```makefile
CGO_CPPFLAGS ?= ${CPPFLAGS}
CGO_CFLAGS ?= ${CFLAGS}
CGO_LDFLAGS ?= $(filter -g -L% -l% -O%,${LDFLAGS})
```

**Platform Detection in script/build.go:**
```go
func isWindowsTarget() bool {
    if os.Getenv("GOOS") == "windows" {
        return true
    }
    if runtime.GOOS == "windows" {
        return true
    }
    return false
}
```

### Cross-Compilation

**Build Linux binary on macOS:**
```bash
GOOS=linux GOARCH=amd64 make bin/gh
```

**Build Windows binary on Linux:**
```bash
GOOS=windows GOARCH=amd64 make bin/gh
```

**Available Platforms:**
- Linux (amd64, arm64, 386, etc.)
- macOS (amd64, arm64)
- Windows (amd64, arm64, 386)

---

## Security Considerations

### Build-Time Security

**OAuth Credentials:**
- Optional compile-time injection via `-ldflags`
- Never stored in source code
- Set only in CI/CD for official builds
- Injected into: `github.com/cli/cli/v2/internal/authflow`

**Dependency Scanning:**
- `govulncheck` in CI validates Go vulnerability database
- `go-licenses` audits dependency licenses
- golangci-lint configured with gosec (disabled due to volume, but available)

### Runtime Security

**Factory Pattern Benefits:**
- Centralized dependency injection enables security checks
- Allows mocking for testing without real API calls
- Clear contract for authentication requirements

**Configuration Security:**
- Credentials stored in OS keyring when available
- Environment variables for temporary auth
- Config files with restricted permissions

---

## Deployment Model

### Release Distribution

**Release Process:**
1. Tag code: `git tag v2.45.0`
2. Manual trigger: GitHub Actions deployment workflow
3. Build artifacts for all platforms (Linux, macOS, Windows)
4. Generate release notes and documentation
5. Publish to GitHub Releases, Homebrew, Scoop, etc.

**Distribution Channels:**
- GitHub Releases (zip/tar.gz)
- Homebrew (macOS, Linux)
- Scoop (Windows)
- apt/yum repositories (Linux)
- MSI installer (Windows)
- Docker image (optional)

**Artifact Signing:**
- GoReleaser with Cosign (provenance attestation)
- SLSA build level 3 compliance

---

## Operational Recommendations

### Required Infrastructure Components

1. **Go 1.25.5 runtime** - Specified in go.mod
2. **golangci-lint v2.6.0** - Code quality enforcement
3. **git** - Version detection and source control
4. **GitHub Actions** - CI/CD automation (already in use)
5. **GoReleaser v2.13.1** - Release orchestration

### Simplification Opportunities

1. **Docker Support**: Could add Dockerfile for containerized builds
   - Would standardize build environment
   - Eliminate "works on my machine" issues
   - Risk: Added complexity for single-binary tool

2. **Build Caching**: Could use GitHub Actions cache more aggressively
   - Already uses Go's built-in incremental builds
   - Could cache go mod download

3. **Performance**: Already optimized
   - Uses Go's fast compilation
   - Startup time optimized (TCELL_MINIMIZE)

### Monitoring Build Health

**Key Metrics:**
- Build time (should be <30s)
- Test coverage (current state unknown)
- Linting issues (golangci-lint should report zero)
- Dependency vulnerabilities (govulncheck)
- License compliance (licenses-check)

### Cost Considerations

- **GitHub Actions**: Minutes-based billing (5,000 free/month)
  - Current usage: ~10 min per build × matrix (3 OS) = ~30 min per commit
  - Recommendation: Matrix testing sustainable within free tier

- **GoReleaser**: Free open-source version used

- **Storage**: Artifacts deleted after 7 days (retention: 7)

---

## Configuration Management

### Environment Variables for Runtime

**At Execution Time:**
| Variable | Purpose | Example |
|----------|---------|---------|
| `GH_TOKEN` | GitHub authentication | `github_pat_...` |
| `GH_HOST` | GitHub instance | `github.com` or custom |
| `GH_EDITOR` | Default editor | `vim`, `nano` |
| `GH_PAGER` | Default pager | `less`, `more` |
| `GH_DEBUG` | Debug output | `api`, `http`, etc. |
| `GH_PATH` | Override gh executable | `/path/to/gh` |
| `GH_COBRA` | Cobra debug flags | `1` |

### Configuration Files

**Location:** `~/.config/gh/config.yml` (XDG spec) or platform-specific

**Sections:**
- `hosts`: GitHub instance configurations
- `users`: Authenticated user information
- `extensions`: Installed extensions configuration

---

## Summary: Building and Deploying

### Quick Reference Commands

**Development:**
```bash
make bin/gh                    # Build binary
make test                      # Run tests
make clean                     # Clean artifacts
golangci-lint run              # Lint code
```

**Documentation:**
```bash
make manpages                  # Generate man pages
make completions               # Generate shell completions
go run ./cmd/gen-docs --website --doc-path ./docs
```

**Installation:**
```bash
make install                   # Install to /usr/local (Unix)
make install DESTDIR=/tmp prefix=/opt  # Custom location
```

**Release (Manual):**
```bash
git tag v2.45.0
git push origin v2.45.0
# Then trigger deployment.yml via GitHub UI with tag name
```

**Cross-Compile:**
```bash
GOOS=linux GOARCH=amd64 make bin/gh    # Linux AMD64
GOOS=darwin GOARCH=arm64 make bin/gh   # macOS ARM64
GOOS=windows GOARCH=amd64 make bin/gh  # Windows AMD64
```

---

## Appendix: File Reference

**Build System Files:**
- `Makefile` - Task definitions (117 lines)
- `script/build.go` - Build orchestrator (246 lines)
- `go.mod` - Module definition with 61 direct dependencies
- `go.sum` - Dependency checksums

**Entry Points:**
- `cmd/gh/main.go` - Binary entry point (13 lines)
- `internal/ghcmd/cmd.go` - CLI initialization (Main function)
- `pkg/cmd/factory/default.go` - Factory creation
- `pkg/cmd/root/root.go` - Command tree root

**Configuration:**
- `.golangci.yml` - Linting configuration
- `.github/workflows/*.yml` - CI/CD workflows

**Documentation Generation:**
- `cmd/gen-docs/main.go` - Documentation generator
- `pkg/cmd/completion/completion.go` - Shell completion

**Version Injection:**
- `internal/build/build.go` - Version constants

---

**Generated by Infrastructure Analyzer**
Focus: Command Factory Pattern - Build, Tooling, and Infrastructure
