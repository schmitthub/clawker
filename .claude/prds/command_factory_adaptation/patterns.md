# Patterns & Conventions

> Generated by patterns-analyzer for github/cli

## Pattern Summary

```
Design Patterns: 8 identified (Factory, Builder, Strategy, Template Method, Late Binding, Dependency Injection, Test Double Injection, Shallow Copy Specialization)
Naming Convention: camelCase variables, PascalCase types, kebab-case files
Error Handling: Sentinel errors + FlagError wrapper pattern
Async Model: Synchronous (Go CLI tool)
Pattern Consistency: High
```

## Design Patterns

### 1. Factory Pattern (Dependency Injection Container)

- **Type**: Creational
- **Purpose**: Centralized dependency injection for all CLI commands, enabling testability and late binding
- **Locations**: `pkg/cmdutil/factory.go` (definition), used universally in all `NewCmd*` functions
- **Implementation Notes**:
  - Mix of eager dependencies (concrete types: `IOStreams`, `GitClient`, `Browser`) and lazy dependencies (closures: `HttpClient`, `Config`, `BaseRepo`)
  - Lazy closures allow late evaluation and override via factory mutation
  - Factory is passed by reference but not mutated except for BaseRepo override in `repo_override.go`

**Example:**
```go
type Factory struct {
	AppVersion     string
	ExecutableName string

	// Eager dependencies - concrete instances
	Browser          browser.Browser
	ExtensionManager extensions.ExtensionManager
	GitClient        *git.Client
	IOStreams        *iostreams.IOStreams
	Prompter         prompter.Prompter

	// Lazy dependencies - closures evaluated when needed
	BaseRepo   func() (ghrepo.Interface, error)
	Branch     func() (string, error)
	Config     func() (gh.Config, error)
	HttpClient func() (*http.Client, error)
	PlainHttpClient func() (*http.Client, error)
	Remotes         func() (context.Remotes, error)
}
```

### 2. Builder Pattern (Command Options Struct)

- **Type**: Creational
- **Purpose**: Accumulate command configuration from factory, flags, and defaults before execution
- **Locations**: Every command has an `Options` struct (e.g., `ListOptions` in `pkg/cmd/pr/list/list.go`)
- **Implementation Notes**:
  - Options struct constructed in `NewCmd*` function
  - Populated from factory dependencies first
  - Cobra flag variables bind to Options fields
  - Additional fields for testability (e.g., `Now func() time.Time`, `Detector fd.Detector`)
  - Options is the single source of truth passed to the run function

**Example:**
```go
type ListOptions struct {
	// Factory dependencies (extracted immediately)
	HttpClient func() (*http.Client, error)
	IO         *iostreams.IOStreams
	BaseRepo   func() (ghrepo.Interface, error)
	Browser    browser.Browser
	Detector   fd.Detector

	// Flag-bound values
	WebMode      bool
	LimitResults int
	State        string
	BaseBranch   string
	HeadBranch   string
	Labels       []string
	Author       string
	Assignee     string
	Search       string
	Draft        *bool
	Exporter     cmdutil.Exporter

	// Test injection points
	Now func() time.Time
}
```

### 3. Strategy Pattern (Exporter Interface)

- **Type**: Behavioral
- **Purpose**: Pluggable output formatting (JSON, jq-filtered, templated)
- **Locations**: `pkg/cmdutil/json_flags.go`
- **Implementation Notes**:
  - `Exporter` interface with `Write(io, data)` method
  - `jsonExporter` implements reflection-based field selection
  - Commands check `if opts.Exporter != nil` to conditionally export JSON instead of TTY formatting
  - Registered via `AddJSONFlags` helper which hooks into cobra's PreRunE

**Example:**
```go
type Exporter interface {
	Fields() []string
	Write(io *iostreams.IOStreams, data interface{}) error
}

// In command logic:
if opts.Exporter != nil {
	return opts.Exporter.Write(opts.IO, listResult.PullRequests)
}
// Otherwise render table/TTY output
```

### 4. Template Method Pattern (NewCmd* + runFunc Delegation)

- **Type**: Behavioral
- **Purpose**: Standardized command construction with customizable execution logic
- **Locations**: All `NewCmd*` functions follow this pattern
- **Implementation Notes**:
  - `NewCmd*` function signature: `func NewCmd<Name>(f *cmdutil.Factory, runF func(*Options) error) *cobra.Command`
  - `NewCmd*` handles: cobra setup, flag registration, options construction, validation
  - `RunE` handler performs: late validation, factory override support, delegation to either `runF` (test) or `<name>Run` (production)
  - Pattern enables complete test control without executing cobra machinery

**Example:**
```go
func NewCmdList(f *cmdutil.Factory, runF func(*ListOptions) error) *cobra.Command {
	opts := &ListOptions{
		IO:         f.IOStreams,
		HttpClient: f.HttpClient,
		Browser:    f.Browser,
		Now:        time.Now,
	}

	cmd := &cobra.Command{
		Use:   "list",
		Short: "List pull requests in a repository",
		RunE: func(cmd *cobra.Command, args []string) error {
			// Support `-R, --repo` override
			opts.BaseRepo = f.BaseRepo

			// Validation
			if opts.LimitResults < 1 {
				return cmdutil.FlagErrorf("invalid value for --limit: %v", opts.LimitResults)
			}

			// Conditional delegation
			if runF != nil {
				return runF(opts)
			}
			return listRun(opts)
		},
	}

	// Flag registration
	cmd.Flags().BoolVarP(&opts.WebMode, "web", "w", false, "...")
	cmd.Flags().IntVarP(&opts.LimitResults, "limit", "L", 30, "...")
	cmdutil.StringEnumFlag(cmd, &opts.State, "state", "s", "open", []string{"open", "closed", "merged", "all"}, "...")

	return cmd
}
```

### 5. Late Binding Pattern (RunE + Factory Closure Evaluation)

- **Type**: Structural/Behavioral
- **Purpose**: Defer dependency resolution until command execution, enabling per-execution customization
- **Locations**: All `RunE` handlers, factory closures
- **Implementation Notes**:
  - Factory closures (e.g., `HttpClient`, `BaseRepo`) not evaluated during `NewCmd*`
  - `RunE` is the first point of evaluation (cobra's execution phase)
  - Allows `EnableRepoOverride` to mutate `f.BaseRepo` between command registration and execution
  - Critical for supporting `-R, --repo` flag which must override the default base repo lookup

**Example:**
```go
// In NewCmdList:
RunE: func(cmd *cobra.Command, args []string) error {
	// Late binding: override factory closure based on flag
	opts.BaseRepo = f.BaseRepo

	// Validation happens at execution time
	if opts.LimitResults < 1 {
		return cmdutil.FlagErrorf("invalid value for --limit: %v", opts.LimitResults)
	}

	if runF != nil {
		return runF(opts)
	}
	return listRun(opts)
}

// In listRun:
baseRepo, err := opts.BaseRepo() // Closure evaluated here
```

### 6. Test Double Injection Pattern

- **Type**: Testing/Structural
- **Purpose**: Allow tests to bypass production logic via injected run functions
- **Locations**: Every command's `NewCmd*` function and test files
- **Implementation Notes**:
  - `runF` parameter in `NewCmd*` functions
  - Tests pass custom `runF` to assert against `Options` or provide canned responses
  - Production code passes `nil`, causing fallthrough to actual implementation
  - Enables unit testing of flag parsing and option construction without HTTP calls or git operations

**Example:**
```go
// Test code:
cmd := NewCmdList(factory, func(opts *ListOptions) error {
	opts.Now = fakeNow
	opts.Detector = detector
	return listRun(opts)
})

// The test runF intercepts and modifies opts before calling the real listRun,
// allowing test-specific configuration without mutating factory
```

### 7. Shallow Copy Specialization (Factory Override)

- **Type**: Structural
- **Purpose**: Specialize factory for specific contexts without deep cloning
- **Locations**: `pkg/cmdutil/repo_override.go`, used in `EnableRepoOverride`
- **Implementation Notes**:
  - Factory passed by pointer allows selective field mutation
  - `f.BaseRepo = OverrideBaseRepoFunc(f, repoOverride)` replaces closure in-place
  - Mutation is safe because it happens in `PersistentPreRunE`, before command `RunE`
  - Only `BaseRepo` closure is ever replaced; other fields remain shared

**Example:**
```go
func OverrideBaseRepoFunc(f *Factory, override string) func() (ghrepo.Interface, error) {
	if override == "" {
		override = os.Getenv("GH_REPO")
	}
	if override != "" {
		return func() (ghrepo.Interface, error) {
			return ghrepo.FromFullName(override)
		}
	}
	return f.BaseRepo // Return original closure if no override
}

// In EnableRepoOverride:
cmd.PersistentPreRunE = func(cmd *cobra.Command, args []string) error {
	repoOverride, _ := cmd.Flags().GetString("repo")
	f.BaseRepo = OverrideBaseRepoFunc(f, repoOverride) // Mutation
	return nil
}
```

### 8. Shared Utilities Pattern (Domain-Specific Helper Packages)

- **Type**: Code Organization
- **Purpose**: Extract common logic within command groups to `shared/` packages
- **Locations**: `pkg/cmd/*/shared/` directories (e.g., `pkg/cmd/pr/shared/`)
- **Implementation Notes**:
  - Shared package per command group (pr, issue, auth, etc.)
  - Contains: display utilities, API query helpers, survey/prompt functions, validation logic
  - Often depends on factory for construction (e.g., `shared.NewFinder(factory)`)
  - Enables commands to remain focused on flag parsing and orchestration

**Example:**
```go
// pkg/cmd/pr/shared/finder.go
type PRFinder interface {
	Find(opts FindOptions) (*api.PullRequest, ghrepo.Interface, error)
}

func NewFinder(factory *cmdutil.Factory) PRFinder {
	return &finder{
		baseRepoFn:      factory.BaseRepo,
		branchFn:        factory.Branch,
		httpClient:      factory.HttpClient,
		gitConfigClient: factory.GitClient,
		remotesFn:       factory.Remotes,
		progress:        factory.IOStreams,
	}
}

// In command:
opts.Finder = shared.NewFinder(f)
```

## Coding Conventions

### Naming

| Element | Convention | Example |
|---------|------------|---------|
| Variables | camelCase | `httpClient`, `baseRepo`, `opts` |
| Functions | camelCase (exported: PascalCase) | `listRun`, `NewCmdList` |
| Structs | PascalCase | `Factory`, `ListOptions`, `CreateContext` |
| Interfaces | PascalCase (often -er suffix) | `Exporter`, `PRFinder`, `GitConfigClient` |
| Files | lowercase with underscores | `list.go`, `list_test.go`, `json_flags.go` |
| Packages | lowercase, single word or abbreviation | `cmdutil`, `iostreams`, `ghrepo` |
| Constants | PascalCase (Go convention) | `SilentError`, `CancelError` |
| Factory Fields (Eager) | PascalCase | `IOStreams`, `GitClient`, `Browser` |
| Factory Fields (Lazy) | PascalCase, func type | `HttpClient func() (*http.Client, error)` |

### Code Structure

- **Function length tendency**: Short to medium (10-50 lines typical, 100-200 for complex commands)
- **Options struct size**: Medium (10-20 fields typical)
- **Nesting depth**: Shallow to moderate (1-3 levels typical, avoid deep nesting)
- **Comments**: Moderate (package-level docs, complex logic explanations, minimal inline)
- **File organization**: Single command per file, co-located tests (`list.go` + `list_test.go`)

### Flag Registration Patterns

**Standard Flags (via cobra):**
```go
cmd.Flags().BoolVarP(&opts.WebMode, "web", "w", false, "List pull requests in the web browser")
cmd.Flags().IntVarP(&opts.LimitResults, "limit", "L", 30, "Maximum number of items to fetch")
cmd.Flags().StringVarP(&opts.Author, "author", "A", "", "Filter by author")
cmd.Flags().StringSliceVarP(&opts.Labels, "label", "l", nil, "Filter by label")
```

**Custom Flag Types (via cmdutil helpers):**
```go
// Enum flag with validation
cmdutil.StringEnumFlag(cmd, &opts.State, "state", "s", "open",
	[]string{"open", "closed", "merged", "all"}, "Filter by state")

// Nil-able bool (distinguishes unset from false)
cmdutil.NilBoolFlag(cmd, &opts.Draft, "draft", "d", "Filter by draft state")

// Nil-able string
cmdutil.NilStringFlag(cmd, &opts.SomeField, "name", "n", "Description")

// JSON export flags (--json, --jq, --template)
cmdutil.AddJSONFlags(cmd, &opts.Exporter, api.PullRequestFields)
```

**Branch Completion Registration:**
```go
_ = cmdutil.RegisterBranchCompletionFlags(f.GitClient, cmd, "base", "head")
```

## Algorithmic Patterns

### Lazy Closure Evaluation Strategy

- **Purpose**: Defer expensive operations (API calls, git queries) until needed
- **Complexity**: O(1) construction, O(actual-operation) on first call
- **Location**: Factory struct lazy fields
- **Key Insight**: Enables factory to be constructed once at CLI root level and specialized per-command via closure replacement

### Options Struct Population (Builder-like)

**Order of operations:**
1. Construct empty Options struct
2. Populate from factory (eager dependencies copied, lazy closures assigned)
3. Cobra binds flag variables to Options fields
4. RunE validates flags and may override factory closures (e.g., `opts.BaseRepo = f.BaseRepo`)
5. Delegate to run function with fully-populated Options

**Rationale**: Separates construction from validation from execution, enabling clean testing and late binding

### Flag Validation Strategy

**Two-phase validation:**
1. **Syntax validation (cobra phase)**: Type coercion, enum checking (via custom flag types)
2. **Semantic validation (RunE phase)**: Cross-flag conflicts, value range checks, required combinations

**Example:**
```go
RunE: func(cmd *cobra.Command, args []string) error {
	// Semantic validation
	if opts.LimitResults < 1 {
		return cmdutil.FlagErrorf("invalid value for --limit: %v", opts.LimitResults)
	}

	if cmd.Flags().Changed("author") && cmd.Flags().Changed("app") {
		return cmdutil.FlagErrorf("specify only `--author` or `--app`")
	}

	if err := cmdutil.MutuallyExclusive(
		"specify only one of `--editor` or `--web`",
		opts.EditorMode, opts.WebMode,
	); err != nil {
		return err
	}

	// ... execution
}
```

## Error Handling Pattern

### Sentinel Errors

```go
// pkg/cmdutil/errors.go
var SilentError = errors.New("SilentError")    // Exit 1, no message
var CancelError = errors.New("CancelError")    // User cancelled
var PendingError = errors.New("PendingError")  // Something pending
```

**Convention:**
- Return sentinel directly: `return cmdutil.SilentError`
- Check with `errors.Is()`: `if errors.Is(err, cmdutil.CancelError) { ... }`
- Used for control flow rather than exceptional conditions

### FlagError Wrapper

```go
type FlagError struct {
	err error
}

func FlagErrorf(format string, args ...interface{}) error {
	return FlagErrorWrap(fmt.Errorf(format, args...))
}

// Usage:
return cmdutil.FlagErrorf("invalid value for --limit: %v", opts.LimitResults)
```

**Convention:**
- Wrap all flag validation errors with `FlagError`
- CLI framework detects `*FlagError` and displays usage message
- Use `FlagErrorf` for formatted messages

### Error Propagation

```go
// Pattern 1: Early return with context
httpClient, err := opts.HttpClient()
if err != nil {
	return err  // Propagate as-is or wrap with fmt.Errorf
}

// Pattern 2: Wrap with context
if err := someOperation(); err != nil {
	return fmt.Errorf("error doing X: %w", err)
}

// Pattern 3: Ignore expected errors
ucc, _ := opts.GitClient.UncommittedChangeCount(ctx)
```

**Rationale**: Go idiomatic error handling, no exceptions, prefer early returns

## Testing Patterns

### Test Structure (runCommand Helper Pattern)

```go
func runCommand(rt http.RoundTripper, detector fd.Detector, isTTY bool, cli string) (*test.CmdOut, error) {
	ios, _, stdout, stderr := iostreams.Test()
	ios.SetStdoutTTY(isTTY)
	ios.SetStdinTTY(isTTY)
	ios.SetStderrTTY(isTTY)

	browser := &browser.Stub{}
	factory := &cmdutil.Factory{
		IOStreams: ios,
		Browser:   browser,
		HttpClient: func() (*http.Client, error) {
			return &http.Client{Transport: rt}, nil
		},
		BaseRepo: func() (ghrepo.Interface, error) {
			return ghrepo.New("OWNER", "REPO"), nil
		},
	}

	cmd := NewCmdList(factory, func(opts *ListOptions) error {
		opts.Now = fakeNow
		opts.Detector = detector
		return listRun(opts)
	})

	argv, err := shlex.Split(cli)
	if err != nil {
		return nil, err
	}
	cmd.SetArgs(argv)

	cmd.SetIn(&bytes.Buffer{})
	cmd.SetOut(io.Discard)
	cmd.SetErr(io.Discard)

	_, err = cmd.ExecuteC()
	return &test.CmdOut{
		OutBuf:     stdout,
		ErrBuf:     stderr,
		BrowsedURL: browser.BrowsedURL(),
	}, err
}

// Test usage:
func TestPRList(t *testing.T) {
	http := initFakeHTTP()
	defer http.Verify(t)

	http.Register(httpmock.GraphQL(`query PullRequestList\b`),
		httpmock.FileResponse("./fixtures/prList.json"))

	output, err := runCommand(http, nil, true, "")
	if err != nil {
		t.Fatal(err)
	}

	assert.Equal(t, expectedOutput, output.String())
}
```

**Convention:**
- `runCommand` helper constructs minimal factory with test doubles
- Uses `iostreams.Test()` for capturing stdout/stderr
- Uses `httpmock.Registry` for API stubbing
- `runF` parameter modifies options before calling real implementation
- Fixtures stored in `./fixtures/*.json` for GraphQL responses

### Mocking Strategies

**HTTP Mocking (httpmock package):**
```go
http := &httpmock.Registry{}
defer http.Verify(t)

// Stub with fixture file
http.Register(
	httpmock.GraphQL(`query PullRequestList\b`),
	httpmock.FileResponse("./fixtures/prList.json"))

// Stub with inline response + assertions
http.Register(
	httpmock.GraphQL(`query PullRequestList\b`),
	httpmock.GraphQLQuery(`{}`, func(_ string, params map[string]interface{}) {
		assert.Equal(t, []interface{}{"OPEN", "CLOSED", "MERGED"}, params["state"])
	}))
```

**IOStreams Mocking:**
```go
ios, _, stdout, stderr := iostreams.Test()
ios.SetStdoutTTY(true)  // Simulate terminal
ios.SetStdinTTY(true)
ios.SetStderrTTY(true)

// Later:
assert.Equal(t, "expected output", stdout.String())
```

**Browser Mocking:**
```go
browser := &browser.Stub{}
factory.Browser = browser

// Later:
assert.Equal(t, "https://...", browser.BrowsedURL())
```

### Table-Driven Tests

```go
func TestPRList_filteringAuthor(t *testing.T) {
	tests := []struct {
		name          string
		cli           string
		expectedQuery string
	}{
		{
			name:          "author @me",
			cli:           `--author "@me"`,
			expectedQuery: `author:@me repo:OWNER/REPO state:open type:pr`,
		},
		{
			name:          "author user",
			cli:           `--author "monalisa"`,
			expectedQuery: `author:monalisa repo:OWNER/REPO state:open type:pr`,
		},
		{
			name:          "app author",
			cli:           `--app "dependabot"`,
			expectedQuery: `author:app/dependabot repo:OWNER/REPO state:open type:pr`,
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			http := initFakeHTTP()
			defer http.Verify(t)

			http.Register(
				httpmock.GraphQL(`query PullRequestSearch\b`),
				httpmock.GraphQLQuery(`{}`, func(_ string, params map[string]interface{}) {
					assert.Equal(t, test.expectedQuery, params["q"].(string))
				}))

			_, err := runCommand(http, detector, true, test.cli)
			assert.Error(t, err)
		})
	}
}
```

## Pattern Consistency Assessment

| Area | Consistency | Notes |
|------|-------------|-------|
| Naming | High | camelCase/PascalCase consistently applied; file naming uniformly `command.go` + `command_test.go` |
| Factory Pattern | High | All commands use `NewCmd*(f *Factory, runF ...)` signature; Options struct uniformly extracts factory deps |
| Flag Registration | High | Standard cobra flags + custom cmdutil helpers (`StringEnumFlag`, `NilBoolFlag`, `AddJSONFlags`) universally used |
| Error Handling | High | FlagError for validation, sentinel errors for control flow, early returns with wrapping |
| Testing | High | `runCommand` helper pattern, httpmock for API stubbing, iostreams.Test() for output capture |
| Options Struct | Medium-High | Some variation in field ordering; test injection fields (Now, Detector) not always present; mostly consistent |
| Shared Utilities | Medium-High | Well-organized per command group; some duplication across groups (e.g., display logic) |
| Code Structure | High | Single command per file, co-located tests, shallow nesting, short functions |

## Inconsistencies

### 1. Options Struct Test Injection Fields

**Location**: Various command Options structs

**Description**: Some commands include test-specific fields like `Now func() time.Time` and `Detector fd.Detector`, while others construct these internally in the run function. For example:
- `pkg/cmd/pr/list/list.go` has `Now func() time.Time` in Options
- `pkg/cmd/pr/create/create.go` has `Detector fd.Detector` in Options
- Some commands don't expose these at all

**Recommendation**: Standardize whether test injection fields belong in Options or are constructed internally.

### 2. BaseRepo Late Binding Location

**Location**: Various `RunE` handlers

**Description**: Some commands assign `opts.BaseRepo = f.BaseRepo` in RunE to support `-R, --repo` override:
```go
// pkg/cmd/pr/list/list.go line 91
opts.BaseRepo = f.BaseRepo
```

Others assume BaseRepo is already correctly bound from factory. This is intentional (to support repo override), but not uniformly documented.

**Recommendation**: Document in code comments why this late binding happens (supports `-R` override).

### 3. Shared Package Naming

**Location**: `pkg/cmd/*/shared/` directories

**Description**: Shared packages are named `shared` which causes import aliasing:
```go
import (
	issueShared "github.com/cli/cli/v2/pkg/cmd/issue/shared"
	prShared "github.com/cli/cli/v2/pkg/cmd/pr/shared"
)
```

**Recommendation**: Consider domain-specific package names (e.g., `prutil`, `issueutil`) to avoid aliasing, or accept the current pattern as intentional isolation.

### 4. Factory Closure vs Concrete Type Choice

**Location**: Factory struct field definitions

**Description**: No clear rule for when to use closure vs concrete type. Generally:
- Closures: Dependencies requiring late evaluation or override capability (HttpClient, Config, BaseRepo)
- Concrete: Dependencies that are stable and don't require late binding (IOStreams, Browser, GitClient)

But the rationale isn't always obvious (e.g., why is GitClient concrete but HttpClient a closure?).

**Recommendation**: Document in Factory struct comments why each field is eager vs lazy.

## Adaptation Recommendations

### Essential Patterns (Must Preserve)

1. **Factory + Options Pattern**: The two-struct pattern (Factory for DI, Options for command config) is fundamental to testability and code organization.
2. **NewCmd* Signature**: `func NewCmd*(f *Factory, runF func(*Options) error) *cobra.Command` enables test double injection and is deeply embedded.
3. **RunE Bridge**: The validation + delegation logic in RunE handlers is critical for late binding and repo override support.
4. **FlagError Wrapper**: Required for cobra integration (usage message display on validation failure).
5. **Lazy Factory Closures**: Enables repo override and late evaluation; cannot be removed without breaking `-R` flag.

### Style Patterns (Recommended)

1. **File Naming**: `command.go` + `command_test.go` co-location aids navigation.
2. **Shared Packages**: `pkg/cmd/*/shared/` organization reduces coupling between commands while sharing domain logic.
3. **Custom Flag Helpers**: `StringEnumFlag`, `NilBoolFlag`, `AddJSONFlags` improve UX and reduce boilerplate.
4. **httpmock Pattern**: Consistent API stubbing improves test clarity.
5. **runCommand Helper**: Reduces test boilerplate significantly.

### Anti-patterns to Avoid

1. **Deep Nesting**: Commands with >3 levels of nesting are harder to test and reason about. Prefer early returns and extracted helper functions.
2. **Mutating Factory After Construction**: Only `BaseRepo` should be mutated (via `EnableRepoOverride`). Other mutations break assumptions about shared factory state.
3. **Large Options Structs**: Options with >25 fields likely indicate the command is doing too much. Consider splitting or extracting subcommands.
4. **Global State in Shared Packages**: Some shared packages use package-level variables for test stubbing (e.g., `finderForRunCommandStyleTests` in `pkg/cmd/pr/shared/finder.go`). This is acknowledged as technical debt; new code should avoid this pattern.
5. **Skipping RunF Test Injection**: Commands without `runF` parameter are harder to unit test. Always include even if current tests don't use it.

## Integration Notes

### Factory Lazy Evaluation Pattern

The Factory's lazy closures are critical for supporting dynamic configuration:

1. **CLI Initialization**: Factory constructed once at root command level with default closures
2. **Command Registration**: `NewCmd*` functions extract factory fields but don't evaluate closures
3. **Repo Override Hook**: `EnableRepoOverride` installs `PersistentPreRunE` that mutates `f.BaseRepo`
4. **Command Execution**: `RunE` executes, assigns `opts.BaseRepo = f.BaseRepo` (now potentially overridden)
5. **Closure Evaluation**: Run function calls `opts.BaseRepo()`, evaluating the (potentially overridden) closure

This enables `gh pr list -R owner/repo` to work without propagating repo override logic into every command.

### Options Struct as Boundary

The Options struct serves as a clean boundary between:
- **Cobra/CLI concerns**: Flag parsing, validation, command tree
- **Business logic**: API calls, git operations, output formatting

This enables:
- **Unit Testing**: Pass Options directly to run functions with canned data
- **Acceptance Testing**: Construct Options from CLI strings via cobra
- **Testability**: runF parameter intercepts and modifies Options before calling real implementation

### Shared Package Organization

Commands within a domain (pr, issue, etc.) share utilities but remain independently testable:
- **Display Logic**: `pkg/cmd/pr/shared/display.go` contains formatting helpers
- **API Queries**: `pkg/cmd/pr/shared/params.go` contains query builders
- **Surveys**: `pkg/cmd/pr/shared/survey.go` contains interactive prompts
- **Finders**: `pkg/cmd/pr/shared/finder.go` contains PR lookup logic

This organization:
- Reduces coupling (commands don't depend on each other)
- Enables reuse (multiple commands use shared.PRFinder)
- Maintains testability (shared packages have their own test files)

### Custom Flag Types as DSL

The custom flag types (`StringEnumFlag`, `NilBoolFlag`, `AddJSONFlags`) form a domain-specific language for flag registration:

```go
// Standard cobra (primitive types only)
cmd.Flags().StringVarP(&opts.State, "state", "s", "open", "Filter by state")

// Custom DSL (adds validation, completion, enum enforcement)
cmdutil.StringEnumFlag(cmd, &opts.State, "state", "s", "open",
	[]string{"open", "closed", "merged", "all"}, "Filter by state")

// Nil-able types (distinguishes unset from false/empty)
cmdutil.NilBoolFlag(cmd, &opts.Draft, "draft", "d", "Filter by draft state")

// Complex multi-flag registration (JSON export)
cmdutil.AddJSONFlags(cmd, &opts.Exporter, api.PullRequestFields)
```

This DSL:
- Reduces flag registration boilerplate
- Enforces consistency (all enum flags have same validation logic)
- Improves UX (automatic shell completion for enums)
- Centralizes flag logic (easier to change behavior globally)

## Key Insights

### Why Late Binding Matters

The Factory's lazy closures enable a powerful capability: **per-execution customization without per-command code**. The `-R, --repo` flag demonstrates this:

- Without late binding: Every command would need code like `if repoFlag != "" { baseRepo = parseRepo(repoFlag) }`
- With late binding: One `PersistentPreRunE` hook mutates `f.BaseRepo`, and all commands automatically see the override

This pattern scales to other global flags (auth tokens, hosts, etc.) without polluting command logic.

### Why Options Struct Exists

Go doesn't have named parameters or default arguments. The Options struct serves as a substitute, providing:

1. **Named Configuration**: `opts.LimitResults` is clearer than a positional `int` parameter
2. **Default Values**: Assigned during Options construction in `NewCmd*`
3. **Test Injection**: Additional fields like `Now` and `Detector` for test control
4. **Single Responsibility**: The run function has one parameter, one responsibility

### Why runF Parameter Exists

The `runF func(*Options) error` parameter enables **surgical test injection**:

- **Without runF**: Tests must construct full cobra command, parse flags, execute, stub HTTP/git
- **With runF**: Tests can construct minimal factory, pass custom runF to intercept and modify Options, then call real implementation with test doubles installed

This is the key to the project's high test coverage without slow integration tests.

### Why Shared Packages Aren't Cross-Domain

Each command group (pr, issue, auth, etc.) has its own `shared/` package rather than a single global shared package. This is intentional:

- **Domain Isolation**: PR logic doesn't leak into issue commands
- **Independent Testing**: Changes to pr/shared don't affect issue tests
- **Clear Ownership**: Each command group owns its shared utilities
- **Acceptable Duplication**: Some duplication (e.g., display helpers) is preferable to tight coupling

The cost (some duplication) is outweighed by the benefit (loose coupling).

## Summary

The GitHub CLI's command factory pattern is a sophisticated application of dependency injection, late binding, and separation of concerns. The key innovations are:

1. **Two-Struct Pattern**: Factory (DI container) + Options (command config) cleanly separates concerns
2. **Lazy Factory Closures**: Enable per-execution customization (repo override) without per-command code
3. **Test Double Injection**: `runF` parameter enables unit testing without slow integration tests
4. **Custom Flag DSL**: Reduces boilerplate and enforces consistency across 100+ commands
5. **Shared Package Organization**: Balances reuse with loose coupling via domain-specific shared packages

The patterns are consistently applied across the entire codebase, with only minor inconsistencies (test injection fields, shared package naming). The architecture successfully scales to 100+ commands while maintaining testability and code clarity.

For adapting this pattern to other projects:
- **Essential**: Factory + Options, runF parameter, late binding closures, FlagError wrapper
- **Recommended**: Custom flag helpers, shared packages, runCommand test helper
- **Avoid**: Deep nesting, factory mutation beyond BaseRepo, large Options structs, global state
