# Testing Strategy

> Generated by testing-analyzer for GitHub CLI Command Factory pattern

## Testing Summary

```
Test Framework: Go standard testing + testify/assert
Test Location: Co-located with source files (*_test.go)
Test Types: Unit (command tests), Integration (HTTP tests), E2E (acceptance tests)
Coverage Tool: Go built-in coverage
CI Integration: Yes (GitHub Actions)
```

## Test Infrastructure

### Framework Configuration

**Primary Testing Stack:**
- Go standard `testing` package
- `github.com/stretchr/testify` v1.11.1 for assertions
- `github.com/google/shlex` for CLI argument parsing in tests
- `github.com/cli/go-internal/testscript` for acceptance tests
- `github.com/MakeNowJust/heredoc` for multi-line string expectations

**Key Test Dependencies:**
```go
import (
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
    "github.com/google/shlex"
)
```

### Directory Structure

Tests are co-located with implementation:
```
pkg/cmd/pr/list/
├── list.go              # Implementation
├── list_test.go         # Command-level tests (flag parsing, output)
├── http_test.go         # Integration tests (API interactions)
└── fixtures/
    ├── prList.json      # GraphQL response fixtures
    └── prListWithDuplicates.json

pkg/httpmock/
├── registry.go          # HTTP mock registry
├── stub.go              # Matchers and responders
└── legacy.go            # Legacy helper stubs

pkg/iostreams/
└── iostreams.go         # Contains Test() helper

test/
└── helpers.go           # Shared test utilities (CmdOut, ExpectLines)

acceptance/
├── acceptance_test.go   # Acceptance test runner
└── testdata/
    ├── pr/
    │   ├── pr-view.txtar
    │   └── pr-create.txtar
    └── issue/
```

## Test Types

### Unit Tests (Command Tests)

**Location**: `pkg/cmd/*/list_test.go`, `pkg/cmd/*/create_test.go`, etc.
**Count**: Primary test type, hundreds across codebase
**Scope**: Command flag parsing, option wiring, TTY/non-TTY behavior, output formatting

**Characteristics:**
- Test the cobra command creation via `NewCmd*` functions
- Use `runF` parameter injection to override command execution
- Mock all external dependencies via Factory fields
- Verify flag parsing produces correct options
- Test TTY vs non-TTY output differences
- Validate error handling for invalid flag combinations

**Example:**
```go
func TestPRList(t *testing.T) {
    http := initFakeHTTP()
    defer http.Verify(t)

    http.Register(
        httpmock.GraphQL(`query PullRequestList\b`),
        httpmock.FileResponse("./fixtures/prList.json"))

    output, err := runCommand(http, nil, true, "")
    if err != nil {
        t.Fatal(err)
    }

    assert.Equal(t, heredoc.Doc(`
        Showing 3 of 3 open pull requests in OWNER/REPO

        ID   TITLE                  BRANCH         CREATED AT
        #32  New feature            feature        about 3 hours ago
        #29  Fixed bad bug          hubot:bug-fix  about 1 month ago
        #28  Improve documentation  docs           about 2 years ago
    `), output.String())
    assert.Equal(t, ``, output.Stderr())
}
```

### Integration Tests (HTTP Tests)

**Location**: `pkg/cmd/*/http_test.go`
**Scope**: API client interactions, pagination, GraphQL query construction
**Setup**: Direct API client usage with httpmock, no full command execution

**Characteristics:**
- Test the underlying API functions (not the full command)
- Verify GraphQL/REST request construction
- Test pagination logic
- Validate query parameters
- Check request body content

**Example:**
```go
func TestIssueList(t *testing.T) {
    reg := &httpmock.Registry{}
    httpClient := &http.Client{}
    httpmock.ReplaceTripper(httpClient, reg)
    client := api.NewClientFromHTTP(httpClient)

    reg.Register(
        httpmock.GraphQL(`query IssueList\b`),
        httpmock.StringResponse(`
            { "data": { "repository": {
                "hasIssuesEnabled": true,
                "issues": {
                    "nodes": [],
                    "pageInfo": {
                        "hasNextPage": true,
                        "endCursor": "ENDCURSOR"
                    }
                }
            } } }
        `),
    )
    reg.Register(
        httpmock.GraphQL(`query IssueList\b`),
        httpmock.StringResponse(`
            { "data": { "repository": {
                "hasIssuesEnabled": true,
                "issues": {
                    "nodes": [],
                    "pageInfo": {
                        "hasNextPage": false,
                        "endCursor": "ENDCURSOR"
                    }
                }
            } } }
        `),
    )

    repo, _ := ghrepo.FromFullName("OWNER/REPO")
    filters := prShared.FilterOptions{
        Entity: "issue",
        State:  "open",
    }
    _, err := listIssues(client, repo, filters, 251)
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }

    // Verify pagination: 251 items requires 2 requests (100 + 151)
    if len(reg.Requests) != 2 {
        t.Fatalf("expected 2 HTTP requests, seen %d", len(reg.Requests))
    }

    // Verify first request
    var reqBody struct {
        Query     string
        Variables map[string]interface{}
    }
    bodyBytes, _ := io.ReadAll(reg.Requests[0].Body)
    _ = json.Unmarshal(bodyBytes, &reqBody)
    if reqLimit := reqBody.Variables["limit"].(float64); reqLimit != 100 {
        t.Errorf("expected 100, got %v", reqLimit)
    }
    if _, cursorPresent := reqBody.Variables["endCursor"]; cursorPresent {
        t.Error("did not expect first request to pass 'endCursor'")
    }

    // Verify second request has cursor
    bodyBytes, _ = io.ReadAll(reg.Requests[1].Body)
    _ = json.Unmarshal(bodyBytes, &reqBody)
    if endCursor := reqBody.Variables["endCursor"].(string); endCursor != "ENDCURSOR" {
        t.Errorf("expected %q, got %q", "ENDCURSOR", endCursor)
    }
}
```

### End-to-End Tests (Acceptance Tests)

**Location**: `acceptance/`
**Scope**: Full CLI workflows with real GitHub API (test environment)
**Setup**: testscript-based txtar files

**Characteristics:**
- Test complete user workflows
- Run against real GitHub test organization
- Require `GH_ACCEPTANCE_HOST`, `GH_ACCEPTANCE_ORG`, `GH_ACCEPTANCE_TOKEN`
- Use testscript format (txtar archives)
- Include setup, execution, and cleanup
- Tagged with build constraint `//go:build acceptance`

**Example (pr-view.txtar):**
```bash
# Use gh as a credential helper
exec gh auth setup-git

# Create a repository with a file so it has a default branch
exec gh repo create $ORG/$SCRIPT_NAME-$RANDOM_STRING --add-readme --private

# Defer repo cleanup
defer gh repo delete --yes $ORG/$SCRIPT_NAME-$RANDOM_STRING

# Clone the repo
exec gh repo clone $ORG/$SCRIPT_NAME-$RANDOM_STRING

# Prepare a branch to PR
cd $SCRIPT_NAME-$RANDOM_STRING
exec git checkout -b feature-branch
exec git commit --allow-empty -m 'Empty Commit'
exec git push -u origin feature-branch

# Create the PR
exec gh pr create --title 'Feature Title' --body 'Feature Body'
stdout2env PR_URL

# View the PR
exec gh pr view $PR_URL
stdout 'Feature Title'
```

## Test Patterns

### Structure Pattern: runCommand Helper

The standard pattern for command tests uses a helper function that:
1. Creates test IOStreams
2. Constructs a minimal Factory with mocked dependencies
3. Calls `NewCmd*` with a `runF` override
4. Parses CLI arguments with shlex
5. Executes the command
6. Returns captured output

```go
func runCommand(rt http.RoundTripper, detector fd.Detector, isTTY bool, cli string) (*test.CmdOut, error) {
    ios, _, stdout, stderr := iostreams.Test()
    ios.SetStdoutTTY(isTTY)
    ios.SetStdinTTY(isTTY)
    ios.SetStderrTTY(isTTY)

    browser := &browser.Stub{}
    factory := &cmdutil.Factory{
        IOStreams: ios,
        Browser:   browser,
        HttpClient: func() (*http.Client, error) {
            return &http.Client{Transport: rt}, nil
        },
        BaseRepo: func() (ghrepo.Interface, error) {
            return ghrepo.New("OWNER", "REPO"), nil
        },
    }

    fakeNow := func() time.Time {
        return time.Date(2022, time.August, 24, 23, 50, 0, 0, time.UTC)
    }

    cmd := NewCmdList(factory, func(opts *ListOptions) error {
        opts.Now = fakeNow
        opts.Detector = detector
        return listRun(opts)
    })

    argv, err := shlex.Split(cli)
    if err != nil {
        return nil, err
    }
    cmd.SetArgs(argv)

    cmd.SetIn(&bytes.Buffer{})
    cmd.SetOut(io.Discard)
    cmd.SetErr(io.Discard)

    _, err = cmd.ExecuteC()
    return &test.CmdOut{
        OutBuf:     stdout,
        ErrBuf:     stderr,
        BrowsedURL: browser.BrowsedURL(),
    }, err
}
```

### Fixture Pattern: JSON Response Files

GraphQL responses are stored as JSON files in `fixtures/` subdirectories:

```go
http.Register(
    httpmock.GraphQL(`query PullRequestList\b`),
    httpmock.FileResponse("./fixtures/prList.json"))
```

Fixture files contain complete GraphQL responses:
```json
{
  "data": {
    "repository": {
      "pullRequests": {
        "totalCount": 3,
        "nodes": [
          {
            "number": 32,
            "title": "New feature",
            "url": "https://github.com/monalisa/hello/pull/32",
            "createdAt": "2022-08-24T20:01:12Z",
            "headRefName": "feature",
            "state": "OPEN",
            "isDraft": true
          }
        ],
        "pageInfo": {
          "hasNextPage": false,
          "endCursor": ""
        }
      }
    }
  }
}
```

### Mocking Pattern: HTTP Registry

The `httpmock` package provides a Registry that acts as an http.RoundTripper:

**Registry Lifecycle:**
```go
func TestSomething(t *testing.T) {
    // 1. Create registry
    http := &httpmock.Registry{}
    defer http.Verify(t)  // Ensure all stubs matched

    // 2. Register stubs
    http.Register(
        httpmock.GraphQL(`query Pattern\b`),  // Matcher
        httpmock.FileResponse("fixture.json"))  // Responder

    // 3. Use in test
    output, err := runCommand(http, nil, true, "")

    // 4. Verify called (defer ensures this)
}
```

**Matchers:**
- `GraphQL(pattern string)` - Matches GraphQL queries by regex
- `REST(method, path string)` - Matches REST endpoints
- `MatchAny()` - Matches any request
- Custom matchers: `func(req *http.Request) bool`

**Responders:**
- `FileResponse(path)` - Returns file contents
- `StringResponse(body)` - Returns inline string
- `JSONResponse(obj)` - Returns JSON-encoded object
- `StatusStringResponse(code, body)` - Returns with status code
- `GraphQLQuery(body, callback)` - Calls callback with query variables

**Advanced Patterns:**

Callback-based verification:
```go
http.Register(
    httpmock.GraphQL(`query PullRequestList\b`),
    httpmock.GraphQLQuery(`{}`, func(_ string, params map[string]interface{}) {
        assert.Equal(t, []interface{}{"OPEN", "CLOSED", "MERGED"},
                     params["state"].([]interface{}))
    }))
```

Request inspection:
```go
// After test execution
bodyBytes, _ := io.ReadAll(http.Requests[0].Body)
var reqBody struct {
    Query     string
    Variables map[string]interface{}
}
json.Unmarshal(bodyBytes, &reqBody)
// Assert on request content
```

## Test Utilities

### Custom Helpers

| Helper | Location | Purpose |
|--------|----------|---------|
| `iostreams.Test()` | pkg/iostreams/iostreams.go | Creates test IOStreams with buffers |
| `httpmock.Registry` | pkg/httpmock/registry.go | HTTP request mocking registry |
| `browser.Stub` | internal/browser/stub.go | Browser operation stub |
| `test.CmdOut` | test/helpers.go | Command output wrapper |
| `test.ExpectLines` | test/helpers.go | Line-by-line output verification |
| `initFakeHTTP()` | Per-package test files | Returns new httpmock.Registry |

### IOStreams Test Pattern

The iostreams package provides a `Test()` helper that returns:
1. An IOStreams instance
2. Input buffer (stdin)
3. Output buffer (stdout)
4. Error buffer (stderr)

```go
func Test() (*IOStreams, *bytes.Buffer, *bytes.Buffer, *bytes.Buffer) {
    in := &bytes.Buffer{}
    out := &bytes.Buffer{}
    errOut := &bytes.Buffer{}
    io := &IOStreams{
        In: &fdReader{
            fd:         0,
            ReadCloser: io.NopCloser(in),
        },
        Out:    &fdWriter{fd: 1, Writer: out},
        ErrOut: &fdWriter{fd: 2, Writer: errOut},
        term:   &fakeTerm{},
    }
    io.SetStdinTTY(false)
    io.SetStdoutTTY(false)
    io.SetStderrTTY(false)
    return io, in, out, errOut
}
```

**Usage in Tests:**
```go
ios, stdin, stdout, stderr := iostreams.Test()

// Write to stdin for prompt responses
stdin.WriteString("my input\n")

// Set TTY mode
ios.SetStdoutTTY(true)

// After command execution
output := stdout.String()
errors := stderr.String()
```

### CmdOut Helper

Located in `test/helpers.go`, wraps command output:

```go
type CmdOut struct {
    OutBuf     *bytes.Buffer
    ErrBuf     *bytes.Buffer
    BrowsedURL string
}

func (c CmdOut) String() string {
    return c.OutBuf.String()
}

func (c CmdOut) Stderr() string {
    return c.ErrBuf.String()
}
```

Enables clean assertions:
```go
output, err := runCommand(...)
assert.Equal(t, expectedOutput, output.String())
assert.Equal(t, "", output.Stderr())
assert.Equal(t, "https://github.com/...", output.BrowsedURL)
```

## Coverage Approach

**Tool**: Go built-in coverage (`go test -cover`, `go test -coverprofile`)
**Threshold**: No explicit threshold enforced in CI
**Enforcement**: Manual review
**Exclusions**:
- Acceptance tests (require credentials, run separately)
- Main entry points
- Platform-specific code not under test

**Running Coverage:**
```bash
# All tests
go test ./...

# With coverage
go test -cover ./...

# Coverage profile
go test -coverprofile=coverage.out ./pkg/...
go tool cover -html=coverage.out

# Single package
go test -cover ./pkg/cmd/pr/list/

# Acceptance tests (separate)
GH_ACCEPTANCE_HOST=github.com \
GH_ACCEPTANCE_ORG=<org> \
GH_ACCEPTANCE_TOKEN=<token> \
go test -tags=acceptance ./acceptance
```

## CI Configuration

**Platform**: GitHub Actions (inferred from repository context)

**Test Execution Strategy:**
- Unit tests run on all PRs
- No mocked external services (all mocks in-process)
- Acceptance tests run separately with credentials
- Tests parallelized by package (`go test ./...` natural parallelism)

**Expected CI Commands:**
```bash
# Lint
golangci-lint run

# Unit tests
go test ./...

# Acceptance tests (separate job with secrets)
GH_ACCEPTANCE_HOST=github.com \
GH_ACCEPTANCE_ORG=${{ secrets.TEST_ORG }} \
GH_ACCEPTANCE_TOKEN=${{ secrets.TEST_TOKEN }} \
go test -tags=acceptance ./acceptance
```

**Failure Handling:**
- Tests fail fast on first error within a package
- Parallel packages continue on failure
- httpmock.Verify failures indicate unused stubs (setup errors)

## Quality Assessment

### Strengths

1. **Excellent Dependency Injection**: Factory pattern enables comprehensive mocking without touching real APIs
2. **Clear Test Organization**: Co-located tests, separate http_test.go for integration tests
3. **Rich HTTP Mocking**: httpmock package provides flexible, type-safe request/response mocking
4. **TTY-aware Testing**: Tests explicitly cover TTY vs non-TTY behavior differences
5. **Fixture-based Approach**: JSON fixtures keep test data manageable and reviewable
6. **Comprehensive Verification**: `http.Verify(t)` ensures all registered stubs were used
7. **Clean Output Testing**: IOStreams.Test() provides clean buffer-based output capture
8. **Time Injection**: Tests inject fake time functions for reproducible timestamps
9. **Table-driven Tests**: Complex flag combinations tested via table-driven approach
10. **Real E2E Tests**: Acceptance tests validate against actual GitHub API

### Concerns

1. **No Coverage Enforcement**: No minimum coverage threshold or gates
2. **Test Duplication**: runCommand helpers duplicated across packages (not DRY)
3. **Large Test Functions**: Some table-driven tests are very long (300+ lines)
4. **Fixture Maintenance**: JSON fixtures can become stale as API evolves
5. **Limited Negative Testing**: More error path coverage could be beneficial
6. **Regex-based Matching**: GraphQL matchers use regex which can be brittle
7. **Manual Verification**: Request body inspection requires manual JSON parsing
8. **Browser Stub Simplicity**: Browser stub doesn't verify URLs are called
9. **No Test Utilities Package**: Shared test helpers scattered across packages

### Testing Debt

**Areas with Insufficient Testing:**
- Error handling for API failures
- Network timeout scenarios
- Concurrent request handling
- Config file parsing edge cases
- Terminal dimension edge cases

**Brittle or Problematic Tests:**
- Regex-based GraphQL matching can match too broadly
- Tests coupled to exact timestamp formatting
- Hard-coded absolute paths in some test fixtures
- Some tests depend on fixture file locations (relative paths)

## Adaptation Recommendations

### Must Replicate

**Factory Mocking Pattern:**
```go
factory := &cmdutil.Factory{
    IOStreams: ios,
    HttpClient: func() (*http.Client, error) {
        return &http.Client{Transport: mockRegistry}, nil
    },
    BaseRepo: func() (ghrepo.Interface, error) {
        return ghrepo.New("OWNER", "REPO"), nil
    },
    Config: func() (gh.Config, error) {
        return config.NewBlankConfig(), nil
    },
}
```

**runF Override Pattern:**
```go
cmd := NewCmdList(factory, func(opts *ListOptions) error {
    // Inject test-specific dependencies
    opts.Now = fakeTimeFunc
    opts.Detector = testDetector
    // Call actual implementation
    return listRun(opts)
})
```

**HTTP Mocking Pattern:**
```go
http := &httpmock.Registry{}
defer http.Verify(t)
http.Register(matcher, responder)
```

**IOStreams Test Pattern:**
```go
ios, stdin, stdout, stderr := iostreams.Test()
ios.SetStdoutTTY(isTTY)
// ... use in factory
// ... assert on stdout.String(), stderr.String()
```

### Suggested Improvements

**1. Centralize Test Helpers:**
Create `pkg/cmdtest/` package with:
- `RunCommand()` helper to eliminate duplication
- `NewTestFactory()` with common defaults
- `AssertOutput()` for consistent output verification

**2. Structured GraphQL Matching:**
Instead of regex, use structured query matching:
```go
http.Register(
    httpmock.GraphQLOperation("PullRequestList"),
    httpmock.GraphQLResponse(fixture))
```

**3. Coverage Gates:**
Add to CI:
```bash
go test -coverprofile=coverage.out ./...
go tool cover -func=coverage.out | grep total | awk '{print $3}' | sed 's/%//' | \
  awk '{if ($1 < 70) exit 1}'
```

**4. Request Assertion Helpers:**
```go
// Instead of manual parsing
func AssertGraphQLVariables(t *testing.T, reg *httpmock.Registry, idx int,
                           assertions func(vars map[string]interface{}))
```

**5. Better Browser Mock:**
```go
browser := &browser.Stub{}
// ... test
browser.VerifyURL(t, "https://github.com/OWNER/REPO/pull/123")
```

### Test Infrastructure Needs

**Phase 0 - Foundation (must have):**
- `pkg/httpmock` package (registry, matchers, responders)
- `pkg/iostreams.Test()` helper
- `test/helpers.go` with CmdOut type
- `internal/browser/Stub` type
- Factory struct with function fields

**Phase 1 - Core Testing (for each command):**
- `*_test.go` co-located with implementation
- `runCommand()` helper specific to command
- `initFakeHTTP()` helper
- `fixtures/` directory for GraphQL responses

**Phase 2 - Integration Testing (optional):**
- `http_test.go` for API-level tests
- Direct API client test utilities

**Phase 3 - Acceptance Testing (optional):**
- `acceptance/` directory
- testscript framework setup
- Test organization credentials

**Shared Across All Phases:**
- testify/assert for assertions
- google/shlex for CLI parsing
- heredoc for multi-line expectations

## Key Testing Conventions

### Test File Naming
- Unit/command tests: `<command>_test.go`
- Integration tests: `http_test.go`
- Shared test utilities: `test.go`
- Acceptance tests: `acceptance_test.go`

### Test Function Naming
- Command tests: `TestCommandName` (e.g., `TestPRList`)
- Variant tests: `TestCommandName_variant` (e.g., `TestPRList_nontty`)
- Integration tests: `TestFunctionName` (e.g., `TestIssueList`)

### Test Organization
- Each package has its own test helpers
- HTTP mocking always uses Registry pattern
- Table-driven tests for flag combinations
- Separate tests for TTY vs non-TTY
- Integration tests in separate files

### Assertion Style
- Use `testify/assert` for non-fatal assertions
- Use `testify/require` for fatal assertions (setup errors)
- Use `t.Fatal()` for unexpected errors in simple tests
- Use heredoc.Doc for multi-line expected output

### Mock Verification
- Always `defer http.Verify(t)` after creating httpmock.Registry
- Browser stubs provide `BrowsedURL()` for verification
- Request inspection via `http.Requests` slice

### Time Handling
- Inject time functions via options: `opts.Now = fakeTimeFunc`
- Use fixed timestamps for reproducible output
- Example: `time.Date(2022, time.August, 24, 23, 50, 0, 0, time.UTC)`

### Flag Testing
- Parse flags via `shlex.Split()` for realistic argument handling
- Test error cases with `wantsErr: true` in table tests
- Verify options struct fields, not just command execution

### Output Testing
- Capture via IOStreams buffers
- Compare full output (not partial matches) when possible
- Test both stdout and stderr separately
- Include empty assertions: `assert.Equal(t, "", output.Stderr())`
