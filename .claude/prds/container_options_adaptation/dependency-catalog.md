# Dependency Catalog: Docker CLI Container Options Pattern

> Generated by dependency-mapper for docker-cli container options DRY pattern
>
> This catalog documents all external dependencies used by Docker CLI's container options pattern implementation, focusing on how commands like `run`, `create`, and others share option parsing logic.

---

## Executive Summary

The Docker CLI container options pattern is built on **7 key external dependencies** that work together to provide a reusable, type-safe flag parsing system. The pattern separates flag definition from value conversion and validation, allowing multiple commands to share identical option parsing logic.

**Key Categories:**
- **Flag Parsing**: spf13/pflag + spf13/cobra
- **Type System**: github.com/moby/moby/api/types (container, network, mount)
- **Value Parsing**: github.com/docker/go-connections + github.com/docker/go-units
- **Container Device Interface**: tags.cncf.io/container-device-interface

---

## Dependency Summary

```
Total Dependencies: 7 external (direct), 15+ transitive (significant)
Primary Package Manager: Go modules (vendor.mod)
Lock File Present: Yes (vendor.mod + vendor/ directory)
Critical for Pattern: YES - Architecture depends heavily on these libraries
```

---

## Core Dependencies

### 1. spf13/pflag
**Version**: 1.0.10
**Category**: Core Framework - Flag Parsing
**Repository**: https://github.com/spf13/pflag

#### Purpose
The foundational library for defining and parsing command-line flags in Docker CLI. Implements Go's flag.FlagSet interface with extended functionality for command-line argument handling.

#### Key Features Used

1. **FlagSet Registration** (`flags *pflag.FlagSet`)
   - Used in `addFlags()` function at line 149
   - All flag registration happens through pflag methods:
     ```
     flags.VarP(&copts.attach, "attach", "a", "Attach to STDIN...")
     flags.StringVar(&copts.hostname, "hostname", "h", "...")
     flags.Var(&copts.memory, "memory", "m", "Memory limit")
     ```

2. **Custom Value Types** (implements `pflag.Value` interface)
   - Requires implementation of three methods:
     - `Set(string) error` - Parse flag value
     - `String() string` - Display current value
     - `Type() string` - Return type name for help text
   - Custom types like `ListOpts`, `MemBytes`, `MountOpt` all implement this interface

3. **Flag Annotations**
   - API version tracking:
     ```
     flags.SetAnnotation("gpus", "version", []string{"1.40"})
     flags.SetAnnotation("health-start-period", "version", []string{"1.29"})
     ```
   - OS type filtering (Windows-specific flags):
     ```
     flags.SetAnnotation("cpu-count", "ostype", []string{"windows"})
     flags.SetAnnotation("io-maxbandwidth", "ostype", []string{"windows"})
     ```

4. **Flag Change Detection**
   - The pattern uses `flags.Changed("flagname")` to distinguish user-provided vs default values
   - Critical for optional configurations

5. **Built-in Flag Types**
   - Var/VarP - Custom Value types
   - StringVar/StringVarP - String flags
   - BoolVar/BoolVarP - Boolean flags
   - IntVar, Int64Var - Integer variants
   - IPVar - IP address parsing
   - DurationVar - Time duration parsing
   - Uint16Var, Uint64Var - Unsigned variants

#### How It Fits the Pattern
```
Command (run.go)
    │
    ├─► flags := command.Flags()  // pflag.FlagSet
    │
    ├─► copts := addFlags(flags)
    │   └─► Uses pflag.FlagSet methods to register flags
    │
    └─► flags.Parse(args)         // pflag parses arguments
        └─► Calls Set() on all custom Value types
```

#### Features Used in Implementation
- **68 total flags** registered across the container pattern
- **25+ custom Value types** (ListOpts, MemBytes, MountOpt, NetworkOpt, etc.)
- **15+ flag annotations** for version/OS type metadata
- Flag mutations: MarkHidden(), MarkDeprecated()

#### Replaceability
**Difficulty**: Moderate to Difficult
- pflag is Go's de-facto standard for CLI flag parsing
- Alternatives: go's built-in `flag` package (minimal), urfave/cli (different design), kong (struct-based)
- Deep integration in flag registration and value parsing
- Would require complete refactor of `addFlags()` function

#### Alternatives
| Alternative | Pros | Cons | When to Use |
|-----------|------|------|------------|
| Go's `flag` | Simpler, no dependencies | Very basic, no help, no custom values | Trivial CLIs only |
| urfave/cli | Full-featured, integrated help | Different API, less customizable | Simple, unified CLI |
| kong | Declarative, struct-based | Less customizable annotations, newer | New Go projects |

#### License
BSD 3-Clause

---

### 2. spf13/cobra
**Version**: 1.10.2
**Category**: Core Framework - Command Orchestration
**Repository**: https://github.com/spf13/cobra

#### Purpose
Provides the command structure and hierarchy for Docker CLI. Cobra wraps pflag with higher-level command management including subcommands, help generation, and shell completion.

#### Key Features Used

1. **Command Registration Pattern**
   ```go
   // In cli/command/container/run.go
   newRunCommand := func(dockerCli command.Cli) *cobra.Command {
       // Creates container options
       copts := addFlags(flags)
       // ...
   }

   // init() function auto-registers the command
   func init() {
       commands.Register(newRunCommand)
   }
   ```

2. **Command Hierarchy**
   - Root: `docker` command
   - Primary: `docker container` group
   - Sub-commands: `run`, `create`, `start`, `stop`, `etc.`
   - Cobra manages parent-child relationships and help propagation

3. **Help System Integration**
   - Automatic help generation from descriptions and pflag annotations
   - Help for flags, subcommands, examples
   - API version annotations inform help output

4. **Shell Completion**
   - `ListOpts.GetSlice()` implements `cobra.SliceValue` for multi-value completion
   - Allows bash/zsh/fish completion for repeated flags like `-e`, `-v`, `-p`

5. **Pre/Post Run Hooks**
   - Commands use RunE for error handling
   - Validation happens in parse() or before container creation

#### How It Fits the Pattern
Cobra provides the command framework; pflag provides flag parsing within each command:

```
Docker Root Command (cobra.Command)
    │
    ├─► docker container (cmd group)
    │   │
    │   ├─► container run (cobra.Command)
    │   │   └─► flags.FlagSet (pflag)
    │   │       └─► copts = addFlags(flags)
    │   │
    │   ├─► container create (cobra.Command)
    │   │   └─► flags.FlagSet (pflag)
    │   │       └─► copts = addFlags(flags)  // SAME FUNCTION!
    │   │
    │   └─► container start (cobra.Command)
    │       └─► flags.FlagSet (pflag)
```

#### Integration Points
- Each command's `Command` has a `flags *pflag.FlagSet`
- `addFlags()` registers all flags on that FlagSet
- Cobra calls command's `RunE()` after pflag parses arguments
- Cobra provides help automatically from pflag registrations

#### Replaceability
**Difficulty**: Difficult
- Cobra is purpose-built for hierarchical CLIs
- Deep integration with command registration and help system
- Docker's command structure relies on Cobra's parent-child command model

#### Alternatives
| Alternative | Pros | Cons |
|-----------|------|------|
| urfave/cli | Lighter weight | Less powerful for complex hierarchies |
| click (Python) | Great for Python | Different language |

#### License
Apache 2.0

---

### 3. github.com/moby/moby/api/types/container
**Version**: 1.53.0
**Category**: API Types - Container Configuration
**Repository**: https://github.com/moby/moby/tree/master/api/types

#### Purpose
Defines the Docker API data structures for container configuration. Represents the container's configuration (Config), runtime settings (HostConfig), and health checking. This is the "output" of the parsing pipeline.

#### Key Types Used

1. **container.Config** - Container configuration
   - ImageID, Entrypoint, Cmd, User, WorkingDir
   - Env, Labels, Volumes, ExposedPorts
   - Hostname, Domainname, AttachStdin, AttachStdout, AttachStderr
   - Tty, OpenStdin, StdinOnce, OnBuild, HealthCheck
   - See line 645 in opts.go for construction

2. **container.HostConfig** - Runtime/host-level settings
   - Binds (volume mounts), Links, LxcConf, Memory, MemorySwap
   - CpuShares, CpuPeriod, CpuQuota, CpusetCpus, CpusetMems
   - Devices, DeviceCgroupRules, DeviceRequests (GPUs)
   - NetworkMode, IpcMode, PidMode, UTSMode, CgroupnsMode
   - Privileged, CapAdd, CapDrop, SecurityOpt
   - RestartPolicy, LogConfig, Sysctls, Ulimits
   - See line 669 in opts.go for construction

3. **container.PidMode, UTSMode, UsernsMode, CgroupnsMode**
   - Type aliases for string values
   - Used at lines 518, 523, 528, 533 in opts.go
   - Examples: `container.PidMode(copts.pidMode)`

4. **container.DeviceMapping** - Device mount specification
   - PathOnHost, PathInContainer, CgroupPermissions
   - Line 488 in opts.go: `make([]container.DeviceMapping, ...)`
   - Line 995: parseDevice() function returns this type

5. **container.DeviceRequest** - GPU/device requests
   - Driver, Count, DeviceIDs, Capabilities
   - Line 606 in opts.go for CDI device handling

6. **container.Resources** - Resource limits
   - Memory, MemoryReservation, MemorySwap
   - CPUShares, CPUPeriod, CPUQuota, CPURealtimePeriod, CPURealtimeRuntime
   - NanoCPUs, BlkioWeight, BlkioWeightDevice
   - DeviceReadBps, DeviceReadIOps, DeviceWriteBps, DeviceWriteIOps
   - Ulimits, PidsLimit
   - Line 613 in opts.go for construction

7. **container.HealthConfig** - Health check configuration
   - Test (command), Interval, Timeout, Retries, StartPeriod, StartInterval
   - Lines 561-594 in opts.go

8. **container.LogConfig** - Logging configuration
   - Type (driver name), Config (key-value options)
   - Line 701 in opts.go

#### Enum-like Values
Constants used for restart policies, isolation types, etc.:
```
container.RestartPolicyDisabled
container.RestartPolicyAlways
container.RestartPolicyUnlessStopped
container.RestartPolicyOnFailure
```

#### How It Fits the Pattern
The containerOptions struct (line 48-145) holds intermediate parsed values. The parse() function converts these to container API types:

```
Flag Input (--memory 1g, --cpu-shares 512, etc.)
    │
    ├─► containerOptions struct (holds string values)
    │   └─► Created by addFlags()
    │
    ├─► containerOptions validation
    │   └─► Done in parse() function
    │
    └─► container.Config + container.HostConfig + container.Resources
        └─► Final API types sent to Docker daemon
```

#### Replaceability
**Difficulty**: Very Difficult
- These are the official Docker API types
- Defined by Moby (Docker's open-source core)
- Any alternative would require custom serialization/API compatibility
- Deep integration throughout the codebase

#### License
Apache 2.0

---

### 4. github.com/moby/moby/api/types/network
**Version**: 1.53.0
**Category**: API Types - Network Configuration
**Repository**: https://github.com/moby/moby/tree/master/api/types

#### Purpose
Defines Docker API types for network configuration, port mappings, and endpoint configuration. Handles network mode, port bindings, DNS, and network attachment options.

#### Key Types Used

1. **network.PortSet** - Set of exposed ports
   - Represents ports the container listens on
   - Line 459 in opts.go: `network.PortSet{}`
   - Used to build ExposedPorts in container.Config

2. **network.PortMap** - Port binding configuration
   - Maps exposed ports to host port bindings
   - Line 436 in opts.go: `portBindings := network.PortMap{}`
   - Structure: `map[PortBinding][]PortBinding`

3. **network.PortBinding** - Single port binding
   - HostIp, HostPort - where to listen on host
   - Line 451: `network.PortBinding{HostIp: hostIP, HostPort: hostPort}`

4. **network.Port** - Protocol+port representation
   - Encodes "port/protocol" (e.g., "8080/tcp", "53/udp")
   - Line 438, 461: `network.ParsePort(string(port))`
   - Used as map keys in PortSet and PortMap

5. **network.NetworkingConfig** - Network configuration for container
   - EndpointsConfig - which networks to connect to
   - Line 737: Building NetworkingConfig from parsed network options
   - Maps network name to EndpointSettings

6. **network.EndpointSettings** - Per-network endpoint configuration
   - IPAddress, IPPrefixLen, Gateway
   - IPv6Address, GlobalIPv6Address, GlobalIPv6PrefixLen
   - MacAddress, NetworkID
   - IPAMConfig (custom IP settings)
   - Links (legacy), Aliases (DNS names)
   - Line 872 in opts.go: `network.EndpointSettings{}`

7. **network.EndpointIPAMConfig** - Custom IP assignment
   - IPv4Address, IPv6Address
   - Line 884: Populates from LinkLocalIPs and parsed IPs

8. **network.HardwareAddr** - MAC address
   - Converts parsed MAC address strings
   - Line 895: `network.HardwareAddr(ma)`

#### Parsing Functions
- `network.ParsePort()` - Line 438: Parse single port string
- `network.ParsePortRange()` - Line 472: Parse port range (1000-2000)

#### How It Fits the Pattern
Network options are parsed separately from container options:

```
CLI Flags (--publish, --dns, --network, --ip, etc.)
    │
    ├─► containerOptions struct (holds raw values)
    │
    └─► parseNetworkOpts() function (line 750)
        └─► Returns map[string]*network.EndpointSettings
            └─► Used in network.NetworkingConfig
                └─► Part of final container creation request
```

#### Special Function: parseNetworkAttachmentOpt
- Line 859: Converts `opts.NetworkAttachmentOpts` to `network.EndpointSettings`
- Handles network drivers and user-defined network configuration
- Validates network mode vs options combination

#### Replaceability
**Difficulty**: Very Difficult (same as container types)
- Official Docker API types
- Network configuration must match daemon expectations
- Deep integration with network creation and container attachment

#### License
Apache 2.0

---

### 5. github.com/moby/moby/api/types/mount
**Version**: 1.53.0
**Category**: API Types - Mount/Volume Configuration
**Repository**: https://github.com/moby/moby/tree/master/api/types

#### Purpose
Defines types for container volume/mount configuration. Provides structured representation of bind mounts, named volumes, and tmpfs mounts.

#### Key Types Used

1. **mount.Mount** - Detailed mount configuration
   - Type (bind, volume, tmpfs, npipe, cluster)
   - Source, Target (host path, container path)
   - ReadOnly, BindOptions, VolumeOptions, TmpfsOptions
   - Used for modern `--mount` flag parsing
   - See `opts/mount.go` for detailed parsing

2. **mount.TypeBind, mount.TypeVolume, mount.TypeTmpfs**
   - Enum-like string constants for mount types
   - Line 383 in opts.go: `if parsed.Type == string(mount.TypeBind)`

3. **mount.BindOptions** - Bind mount specific options
   - Propagation settings (rprivate, rslave, rshared, rprivate)
   - NonRecursive - whether to recursively bind

4. **mount.VolumeOptions** - Named volume specific options
   - NoCopy - whether to copy data from image
   - Labels, DriverConfig - volume driver parameters

5. **mount.TmpfsOptions** - tmpfs mount options
   - SizeBytes, Mode - permission bits for tmpfs

#### Integration with HostConfig
- Used in `container.HostConfig.Mounts` - newer, structured format
- Legacy format uses `Binds` (list of strings)
- Both formats are supported for compatibility

#### How It Fits the Pattern
Mounts use the most complex parsing in the pattern:

```
--mount type=bind,source=/host,target=/container,readonly
--volume /host/path:/container/path:ro
--tmpfs /tmp:size=1gb,mode=1777
    │
    ├─► opts.MountOpt custom type
    │   └─► Implements pflag.Value
    │
    └─► mount.Mount structs
        └─► Validated and stored in container.HostConfig.Mounts
```

#### Replaceability
**Difficulty**: Very Difficult (same as container/network types)
- Official Docker API types
- Mount configuration must serialize correctly to daemon
- Complex validation logic depends on mount type

#### License
Apache 2.0

---

### 6. github.com/docker/go-connections
**Version**: 0.6.0
**Category**: Utilities - Network Handling
**Repository**: https://github.com/docker/go-connections

#### Purpose
Provides Docker-specific network utilities for port parsing, NAT configuration, and address handling. Bridges between CLI input and Docker's network model.

#### Key Components

1. **nat.ParsePortSpecs()** - Primary function used
   - Line 432 in opts.go
   - Input: Array of port specs like ["8080:80/tcp", "53/udp"]
   - Output: Two maps:
     - `nat.PortSet` - Exposed ports (what container listens on)
     - `nat.PortMap` - Port bindings (how to reach container)
   - Handles port range expansion, protocol specification
   - Example: "8080-8090:9090-9100" expands to multiple entries

2. **nat.PortSet** - Set of exposed ports
   - Implemented as `map[nat.Port]struct{}`
   - nat.Port is string type like "8080/tcp"

3. **nat.PortMap** - Port binding map
   - Maps exposed port to list of host bindings
   - Implemented as `map[nat.Port][]nat.PortBinding`

4. **nat.PortBinding** - Single port binding
   - HostIP (empty for all interfaces, "127.0.0.1" for localhost)
   - HostPort (empty for random port assignment)
   - Example: HostIP="0.0.0.0", HostPort="8080"

5. **nat.SplitPort()** - Parse port/protocol from string
   - Input: "8080/tcp" or "8080/udp"
   - Output: port (8080) and protocol ("tcp" or "udp")

#### Usage Pattern
```
CLI Input: --publish 8080:80/tcp --publish 3306:3306
    │
    ├─► Stored in containerOptions.publish (ListOpts)
    │
    └─► In parse() function:
        ├─► convertToStandardNotation() - formats port specs
        └─► nat.ParsePortSpecs(convertedOpts)
            ├─► Returns nat.PortSet for container.Config.ExposedPorts
            └─► Returns nat.PortMap for container.HostConfig.PortBindings
```

#### convertToStandardNotation() Function
- Line 399 in opts.go
- Converts various port format representations to standard format
- Handles single ports, port ranges, IP binding
- Normalizes input before passing to nat.ParsePortSpecs()

#### Special Cases Handled
- Port range expansion: "8000-8003:9000-9003" → four separate bindings
- Protocol specification: default is "tcp" if omitted
- IP-specific binding: "127.0.0.1:8080:80" binds only to localhost
- Random port assignment: "8080:0/tcp" picks random host port

#### Replaceability
**Difficulty**: Moderate
- Handles Docker-specific port mapping semantics
- Could implement custom port parsing but would need extensive testing
- Alternatives: Write custom port parser, use net.SplitHostPort() + regex

#### Alternatives
| Approach | Pros | Cons |
|---------|------|------|
| Custom regex/parsing | Full control | Complex, error-prone |
| net.SplitHostPort() | Go stdlib | Doesn't handle port ranges, protocols |
| netip package (Go 1.18+) | Modern IP handling | Limited port range support |

#### License
Apache 2.0

---

### 7. github.com/docker/go-units
**Version**: 0.5.0
**Category**: Utilities - Value Parsing
**Repository**: https://github.com/docker/go-units

#### Purpose
Provides parsing utilities for Docker-specific value formats: binary sizes (1MB, 1GiB), ulimits, and other size/limit specifications. Crucial for memory, storage, and resource limit parsing.

#### Key Functions Used

1. **units.RAMInBytes(value string)** - Parse memory specifications
   - Input: "512MB", "1GB", "1073741824" (bytes), "1g", "256m"
   - Output: int64 number of bytes
   - Uses binary (1024) not decimal (1000) for sizing
   - Used in:
     - Line 421: MemBytes.Set() - parse --memory flag
     - Line 441: MemSwapBytes.Set() - parse --memory-swap flag
     - Line 456: MemSwapBytes validation
     - Line 153 in mount.go: Parse tmpfs size in mount options

2. **units.BytesSize(float64)** - Format bytes as human-readable string
   - Inverse of RAMInBytes()
   - Line 414 in opts.go: MemBytes.String() - show current memory value
   - Formats: "512MB", "1GB", "1.5GB"
   - Used for displaying parsed values in help/error messages

3. **units.ParseUlimit(value string)** - Parse ulimit specifications
   - Input: "nofile=1024:2048" (soft:hard)
   - Parses ulimit name and soft/hard limits
   - Line 28 in ulimit.go: `units.ParseUlimit(val)`
   - Validates ulimit names and ranges

#### Usage in Custom Types

**MemBytes type** - Represents memory size value
- Implements pflag.Value interface
- Set() parses using units.RAMInBytes()
- String() formats using units.BytesSize()
- Used for --memory, --memory-reservation flags

**MemSwapBytes type** - Represents total memory+swap
- Similar to MemBytes but allows "-1" for unlimited
- Line 451: Special handling for "-1" vs parsed values
- Line 456: units.RAMInBytes() for numeric values

**Throttle device parsing** - Bandwidth limits
- Line 25 in throttledevice.go: `units.RAMInBytes(v)`
- Parses device I/O bandwidth (8MB/s means 8388608 bytes/sec)

#### Validation Role
The library validates input during parsing:
- Rejects invalid formats (not a number, unrecognized suffix)
- Enforces suffix conventions (b, k, m, g, kb, mb, gb)
- Converts to canonical form (bytes)

#### Size Format Examples
- Bytes: "1048576", "1073741824" (no suffix)
- Kilobytes: "1k", "1KB", "1024K"
- Megabytes: "512m", "512M", "512MB"
- Gigabytes: "1g", "1G", "1GB"
- Terabytes: "1t", "1T", "1TB"

Note: Uses binary (1024) not decimal (1000)

#### Replaceability
**Difficulty**: Easy to Moderate
- Pure parsing logic, no integration with Docker daemon
- Could be replaced with custom parsing using regexp + strconv
- Would need comprehensive testing for all size format variants

#### Alternatives
| Approach | Pros | Cons |
|---------|------|------|
| Custom regex | Full control | Must handle all formats, sizes |
| humanize package | Similar functionality | Different API, different size conventions |
| strconv.ParseInt | Minimal dependency | No unit suffix support |

#### License
Apache 2.0

---

### 8. tags.cncf.io/container-device-interface
**Version**: 1.1.0
**Category**: Device Management - CDI Support
**Repository**: https://github.com/container-orchestrated-devices/container-device-interface

#### Purpose
Supports Container Device Interface (CDI) for standardized device allocation in containers. Used for GPU, accelerator, and specialized hardware device specification.

#### Key Functions Used

1. **cdi.IsQualifiedName(device string)** - Check if device is CDI-qualified
   - Line 491 in opts.go
   - CDI names format: "vendor.com/class=device" (e.g., "nvidia.com/gpu=0")
   - Returns true if device matches CDI naming convention
   - Distinguishes CDI devices from traditional /dev/xxx device paths

#### How It Fits the Pattern
GPU/device handling with CDI support:

```
CLI Input: --device /dev/nvidia0 --gpus all
           --device nvidia.com/gpu=0
    │
    ├─► Stored in containerOptions.devices (ListOpts)
    │
    └─► In parse() function (line 488-510):
        ├─► For each device:
        │   ├─► cdi.IsQualifiedName(device) → true
        │   │   └─► Treat as CDI device (modern)
        │   └─► else → treat as /dev path (traditional)
        │
        └─► container.DeviceRequest for DeviceRequests
            └─► Modern GPU allocation mechanism
```

#### DeviceRequest Structure
- Populated when CDI devices detected
- Fields:
  - Driver: "nvidia" for GPU, etc.
  - Count: number of devices
  - DeviceIDs: specific device IDs
  - Capabilities: "gpu", "compute", "graphics", etc.

#### Legacy Device Support
Traditional device paths still supported:
- `/dev/nvidia0`, `/dev/dri/card0`, etc.
- Parsed into `container.DeviceMapping` array
- HostPath, ContainerPath, CgroupPermissions

#### Integration with GPU Options
Works alongside:
- `--gpus` flag (line 74 in opts.go)
- `--device` flag with CDI names
- Alternative to older device mapping
- Enables modern container runtimes (containerd, cri-o) support

#### Replaceability
**Difficulty**: Low to Moderate
- Only used for device name validation, not core parsing
- Could replace with simple string format check
- Modern container image requires some CDI awareness
- Could defer to runtime if no special handling needed

#### Alternatives
| Approach | Pros | Cons |
|---------|------|------|
| Regex validation | Simple | Less standardized, no library support |
| Skip validation | Minimal code | Risk of malformed device names |
| OCI spec | Standard | Heavier library dependency |

#### License
Apache 2.0

---

## Secondary Dependencies (Internal to Docker CLI)

### Internal Packages Used in the Pattern

1. **github.com/docker/cli/internal/lazyregexp**
   - Line 21, 46 in opts.go
   - Lazy-compiled regular expressions
   - Used for device validation, domain name validation
   - Example: deviceCgroupRuleRegexp at line 46

2. **github.com/docker/cli/internal/volumespec**
   - Line 22 in opts.go
   - Volume mount path parsing
   - Separates source:target:options format

3. **github.com/docker/cli/opts** (the package itself!)
   - Line 23 in opts.go
   - Defines the custom Value types
   - See next section for details

4. **github.com/docker/cli/pkg/kvfile**
   - Line imported in parse.go
   - Reads environment variables from files (--env-file)

---

## Custom Option Types (pflag.Value Implementations)

The `opts/` package defines 15+ custom types that implement `pflag.Value`. These are the bridge between CLI input and Docker API types.

### Core List and Map Types

#### ListOpts - Repeatable flags
- **Fields**: values []string, validator ValidatorFctType
- **Used for**: -e ENV, -v VOLUME, -p PORT, -l LABEL, etc.
- **Methods**: Set(value), String(), Type(), GetSlice(), GetAll()
- **Features**: Optional validation function per ListOpts instance
- **Example**:
  ```go
  copts.env = opts.NewListOpts(opts.ValidateEnv)
  // Allows: docker run -e VAR=value -e VAR2=value2 image
  ```

#### MapOpts - Key-value flags
- **Fields**: values map[string]string, validator ValidatorFctType
- **Used for**: --sysctl, --log-opt, --storage-opt
- **Example**: `--sysctl net.ipv4.ip_forward=1 --sysctl kernel.shm_max=67108864`
- **Validation**: Optional validator function for values

#### FilterOpt - Advanced filtering
- **Fields**: filter client.Filters (from moby/moby)
- **Used for**: Filter specifications in API calls
- **Note**: Uses moby client library for type compatibility

### Numeric and Size Types

#### MemBytes - Memory size with units
- **Implements**: `pflag.Value`
- **Set()**: Parses "512MB", "1GB" using units.RAMInBytes()
- **String()**: Formats bytes back to human-readable using units.BytesSize()
- **Type()**: Returns "bytes"
- **Special**: Value() method returns int64 for API

#### MemSwapBytes - Total memory+swap
- **Extends**: MemBytes behavior
- **Special case**: Allows "-1" for unlimited
- **Validation**: Checks if value is "-1" before parsing as bytes

#### NanoCPUs - CPU fraction in nanoseconds
- **Parses**: "1.5", "0.5", "2"
- **Internal**: Stored as int64 nanoseconds (1.5 CPUs = 1500000000 nanos)
- **Used for**: --cpus flag
- **Precision**: Supports fractional CPU allocation

### Device and Network Types

#### MountOpt - Modern mount specification
- **Complex parsing**: CSV format per mount
- **Handles**: type, source, target, readonly, bind-options, volume-options, tmpfs-options
- **Output**: mount.Mount structs
- **Example**: `--mount type=bind,source=/host,target=/container,readonly`

#### NetworkOpt - Network attachment specification
- **Parsing**: driver, driver-opts, network name
- **Maps to**: network.EndpointSettings
- **CSV format**: name=value pairs
- **Example**: `--network mynet:ip=172.20.0.2,ip6=2001:db8::33`

#### UlimitOpt - Resource limits
- **Parses**: "nofile=1024:2048" format
- **Uses**: units.ParseUlimit() for validation
- **Values**: Soft and hard limits
- **Common**: nofile, nproc, memlock, etc.

#### WeightdeviceOpt - Block I/O weight per device
- **Format**: "/dev/sda:500" (device:weight)
- **Maps to**: container.WeightDevice
- **Range**: 10-1000 for weights

#### ThrottledeviceOpt - I/O bandwidth throttling
- **Format**: "/dev/sda:10MB" (device:rate)
- **Uses**: units.RAMInBytes() for parsing rate
- **Types**: Read BPS, Write BPS, Read IOps, Write IOps

#### GpuOpts - GPU device specification
- **Parses**: "all", "0", "0,1" format
- **Maps to**: container.DeviceRequest for GPUs
- **Modern**: Alternative to legacy device mapping

### Validators (ValidatorFctType)

The opts package provides validators for common flag types:
- `ValidateEnv` - Environment variable format
- `ValidateLabel` - Label format (key=value)
- `ValidateIPAddress` - IP address format
- `ValidateDNSSearch` - DNS domain format
- `ValidateExtraHost` - host:ip format
- `ValidateLink` - container:alias format
- `ValidateThrottleBpsDevice` - device:bandwidth format
- `ValidateThrottleIOpsDevice` - device:iops format
- `ValidateWeightDevice` - device:weight format
- `ValidateSysctl` - sysctl name=value format

---

## Dependency Relationships and Transitive Dependencies

### Direct Usage Chain
```
pflag (flag parsing)
    │
    ├─► Custom Value types (ListOpts, MemBytes, MountOpt, etc.)
    │   │
    │   ├─► units (size parsing) for MemBytes, UlimitOpt, etc.
    │   │
    │   ├─► moby/moby/api/types (output structs)
    │   │   │
    │   │   ├─► container types
    │   │   ├─► network types
    │   │   └─► mount types
    │   │
    │   └─► go-connections (nat, port handling)
    │
    └─► cobra (command framework)
        └─► contains pflag.FlagSet
```

### Critical Integration Points

1. **pflag.Value Interface** (3 methods)
   - All custom types must implement
   - Set() called during flag.Parse()
   - String() called for help/display
   - Type() called for help text

2. **Moby API Types** (output)
   - Final destination of all parsed values
   - Must match API spec exactly
   - Version-specific fields

3. **Validators** (optional)
   - Run during Set() call
   - Can reject invalid input immediately
   - Support early validation before parse()

### Version Constraints

From vendor.mod:
```
spf13/pflag v1.0.10
spf13/cobra v1.10.2
moby/moby/api v1.53.0
moby/moby/client v0.2.2
docker/go-connections v0.6.0
docker/go-units v0.5.0
container-device-interface v1.1.0
```

Compatibility notes:
- pflag 1.0.x is stable (no major changes since 1.0)
- cobra 1.10.x is latest; 1.x is standard
- moby/moby tracks Docker API version (1.53.0 = Docker 26.0 API)
- No known conflicts between versions

---

## Risk Areas and Maintenance Notes

### 1. Moby/Moby API Version Coupling
- **Risk**: Medium
- **Issue**: Container types tied to Docker API version in vendor.mod
- **Mitigation**: Version annotations in flags indicate minimum API requirement
- **Note**: CalVer versioning in docker-cli complicates version tracking

### 2. pflag Interface Contract
- **Risk**: Low
- **Issue**: pflag.Value interface is stable; unlikely to change
- **Mitigation**: Interface is well-established Go pattern
- **Note**: Docker CLI can skip major version updates safely

### 3. Unit Parsing Inconsistencies
- **Risk**: Medium
- **Issue**: go-units uses binary (1024) not decimal (1000) for sizing
- **Mitigation**: Explicitly documented in --memory help text
- **Note**: Matches Docker daemon behavior, important for consistency

### 4. Network Mode Validation
- **Risk**: Low to Medium
- **Issue**: NetworkMode string can have various formats (host, bridge, container:name, custom)
- **Mitigation**: Validation happens in parse() function
- **Note**: UserDefined mode check for network-scoped options

### 5. Device Naming Conventions
- **Risk**: Low
- **Issue**: CDI names vs /dev paths require careful validation
- **Mitigation**: cdi.IsQualifiedName() provides clear check
- **Note**: Legacy devices still supported for backward compatibility

---

## Adaptation Recommendations for Custom CLI

### For Building a Docker-like CLI

#### Minimal Core Pattern (3 dependencies)
```
pflag for flag parsing
custom Value types (implement pflag.Value)
data structs to match your API
```

#### Recommended Pattern (7 dependencies)
```
pflag for flags (required)
cobra for commands (recommended)
API type package (your own)
Network utilities (custom or minimal)
Unit parsing (custom or use go-units)
CDI support (optional, for device integration)
```

#### Recommended Stack by Language

**Go** (Docker's choice)
- **Flags**: pflag (best in class)
- **Commands**: cobra (industry standard)
- **Units**: go-units (Docker-compatible)
- **Networks**: go-connections (or custom)
- **Types**: Define your own API types

**Python**
- **Flags**: click, argparse-continuation, or typer
- **Commands**: click (built-in support)
- **Units**: pint (unit conversion), humanize
- **Networks**: ipaddress (stdlib), netaddr
- **Types**: dataclasses, pydantic

**Rust**
- **Flags**: clap (industry standard), structopt
- **Commands**: clap (hierarchical)
- **Units**: humanize, bytesize crates
- **Networks**: standard library networking
- **Types**: structs with derives

**TypeScript/Node.js**
- **Flags**: yargs, commander, oclif
- **Commands**: oclif (plugin system)
- **Units**: bytes, humanize-duration
- **Networks**: native net module, ip package
- **Types**: TypeScript interfaces

#### Key Pattern Elements to Replicate

1. **Separate Concerns**
   - Flag registration (addFlags)
   - Flag parsing validation (pflag.Value.Set)
   - Conversion to API types (parse function)
   - Multiple commands share addFlags/parse

2. **Type Safety**
   - Custom Value types for complex inputs
   - Validators run during flag parsing, not later
   - Early rejection of invalid input

3. **Metadata in Flags**
   - Version annotations (which API versions support flag)
   - OS type filtering (Windows vs Linux flags)
   - Hidden/deprecated flags

4. **Value Transformation**
   - Input: String from CLI ("1GB", "10.0.0.1", "/host:/container")
   - Intermediate: containerOptions struct with raw values
   - Output: API types (container.Config, container.HostConfig, etc.)

---

## Summary Table: All Dependencies

| Name | Version | Category | Purpose | Replaceability | License |
|------|---------|----------|---------|---|---|
| spf13/pflag | 1.0.10 | Flag Parsing | Core flag registration and custom Value types | Difficult | BSD 3-Clause |
| spf13/cobra | 1.10.2 | Command Framework | Command hierarchy, help, completion | Difficult | Apache 2.0 |
| moby/moby/api/types/container | 1.53.0 | API Types | Container configuration structs | Very Difficult | Apache 2.0 |
| moby/moby/api/types/network | 1.53.0 | API Types | Network configuration structs | Very Difficult | Apache 2.0 |
| moby/moby/api/types/mount | 1.53.0 | API Types | Mount/volume configuration structs | Very Difficult | Apache 2.0 |
| docker/go-connections | 0.6.0 | Network Utilities | Port parsing and NAT configuration | Moderate | Apache 2.0 |
| docker/go-units | 0.5.0 | Value Parsing | Size/limit parsing (MB, GB, ulimit) | Easy to Moderate | Apache 2.0 |
| container-device-interface | 1.1.0 | Device Interface | CDI device name validation | Low to Moderate | Apache 2.0 |

---

## Architecture Diagram: Complete Data Flow

```
INPUT LAYER
├─ CLI Arguments: --memory 1G --cpus 1.5 --publish 8080:80 --volume /host:/container
├─ Environment: DOCKER_HOST, DOCKER_TLS_VERIFY, etc.
└─ Configuration: ~/.docker/config.json

            │
            ▼

PFLAG PARSING LAYER (spf13/pflag)
├─ Flag registration: flags.Var(&copts.memory, "memory", "...")
├─ pflag.Value.Set() called for each flag
│  └─ Calls validator function if defined
├─ Early validation (rejected input stops parsing)
└─ Result: containerOptions struct with string values

            │
            ▼

VALUE CONVERSION LAYER (docker/go-units + docker/go-connections)
├─ MemBytes("1G") → 1073741824 (via units.RAMInBytes)
├─ NanoCPUs("1.5") → 1500000000 (nanoseconds)
├─ PublishOpts(["8080:80"]) → nat.ParsePortSpecs()
├─ MountOpt parsing (CSV format) → mount.Mount
└─ NetworkOpt parsing → network.EndpointSettings

            │
            ▼

VALIDATION & API TYPE ASSEMBLY LAYER (parse function)
├─ Device validation: cdi.IsQualifiedName() check
├─ Network mode validation
├─ Port range validation
├─ Device path resolution
├─ Health check assembly
└─ Result: container.Config, container.HostConfig, network.NetworkingConfig

            │
            ▼

COMMAND EXECUTION LAYER (spf13/cobra)
├─ RunE() function called
├─ API client calls created container with Config/HostConfig/NetworkingConfig
└─ Response: Container ID or error

            │
            ▼

OUTPUT LAYER
└─ Display container ID, warnings, or error messages
```

---

## Feature Isolation Analysis

### What Can Be Replaced?

#### Easy to Replace
- **docker/go-units** - Pure parsing library
  - Could implement custom size parser
  - 100+ lines of regex + math

- **docker/go-connections/nat** - Port mapping
  - Could implement custom port parser
  - Key functions: ParsePortSpecs, ParsePort

- **container-device-interface** - CDI validation
  - Could replace with simple regex for CDI naming
  - Only used in one place (line 491)

#### Difficult to Replace
- **spf13/pflag** - Too integrated
  - 68 flags registered throughout addFlags()
  - Custom Value type interface deeply used
  - Would require rewriting addFlags()

- **moby/moby API types** - Cannot replace without API change
  - These are the Docker API data structures
  - Daemon expects specific JSON/protobuf format
  - No alternative representation possible

#### Medium Difficulty
- **spf13/cobra** - Possible but would lose structure
  - Cobra command structure used for help, completion
  - Could use simpler command framework
  - Would lose hierarchical command help

---

## Conclusion

The Docker CLI container options pattern is built on a **solid foundation of mature, stable dependencies**:

1. **pflag** - Standard Go CLI flag library (no viable replacement)
2. **cobra** - Command framework (replaceable but loses functionality)
3. **Moby API types** - Docker API definition (cannot be replaced)
4. **go-connections & go-units** - Docker-specific utilities (replaceable with effort)
5. **CDI support** - Modern device interface (low usage, optional)

The **key insight** is the separation of concerns:
- Flag registration (pflag)
- Value parsing (pflag.Value interface)
- Type conversion (custom types)
- API assembly (parse function)
- Command execution (cobra)

This pattern allows multiple commands (run, create, etc.) to **reuse identical flag definitions and parsing logic** while maintaining type safety and early validation. The design is **replicable in other languages** with equivalent libraries.

For **adaptation to other CLIs**, focus on:
1. Choosing a flag library that supports custom types
2. Separating parsing from validation
3. Defining your own API types (don't try to reuse moby/moby types)
4. Implementing the Value interface equivalent for complex types
5. Centralizing parsing logic in reusable functions

---

**Document generated**: 2026-01-27
**Docker CLI version analyzed**: v27.x (CalVer)
**Analysis depth**: Complete with code references
