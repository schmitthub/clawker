# API Surface

> Generated by api-surface-analyzer for docker/docker-cli

## API Surface Summary

```
API Types: Library (Go package)
Total Public Exports: 40+ types and functions
Primary Package: cli/command/container (opts.go)
Supporting Package: opts/ (19 files with custom flag types)
Integration: pflag.Value interface for command-line parsing
Versioning: No semantic versioning (CalVer), stable interface patterns
```

This document describes the public API surface of Docker CLI's container options pattern - a reusable architecture for defining and parsing container-related command-line flags.

## Core Pattern: Two-Phase Option Handling

### Phase 1: Flag Registration - `addFlags()` function

**Location:** `cli/command/container/opts.go:149-329`

```go
func addFlags(flags *pflag.FlagSet) *containerOptions
```

**Description:** Registers all container-related flags with a pflag.FlagSet and returns a configured containerOptions struct.

**Parameters:**
| Name | Type | Required | Description |
|------|------|----------|-------------|
| flags | *pflag.FlagSet | yes | The flag set to register flags with |

**Returns:** `*containerOptions` - Initialized struct containing all option values

**Usage Pattern:**
```go
flags := pflag.NewFlagSet("container", pflag.ContinueOnError)
copts := addFlags(flags)
flags.Parse(args)
// copts now contains parsed values
```

**Key Characteristics:**
- Initializes 60+ container option fields
- Creates custom option types (ListOpts, MapOpts, etc.) with validators
- Registers flags using pflag's Var/VarP methods
- Sets API version annotations for version-specific flags
- Returns pointer to containerOptions for later parsing

### Phase 2: Container Config Generation - `parse()` function

**Location:** `cli/command/container/opts.go:342-741`

```go
func parse(flags *pflag.FlagSet, copts *containerOptions, serverOS string) (*containerConfig, error)
```

**Description:** Converts containerOptions into Docker API structs (Config, HostConfig, NetworkingConfig).

**Parameters:**
| Name | Type | Required | Description |
|------|------|----------|-------------|
| flags | *pflag.FlagSet | yes | Flag set used for change detection (flags.Changed) |
| copts | *containerOptions | yes | Parsed container options from addFlags() |
| serverOS | string | yes | Target daemon OS ("linux", "windows") for validation |

**Returns:** `(*containerConfig, error)` where containerConfig contains:
```go
type containerConfig struct {
    Config           *container.Config          // Basic container config
    HostConfig       *container.HostConfig      // Host-specific config
    NetworkingConfig *network.NetworkingConfig  // Network endpoints
}
```

**Error Handling:**
- Returns validation errors for invalid option combinations
- Validates device paths based on serverOS
- Checks constraint violations (swappiness range, restart policy conflicts, etc.)

**Example:**
```go
serverInfo, _ := client.Ping(ctx)
containerCfg, err := parse(flags, copts, serverInfo.OSType)
if err != nil {
    return fmt.Errorf("invalid options: %w", err)
}
// Use containerCfg with Docker API
```

## Public Types

### 1. containerOptions (internal but key pattern)

**Location:** `cli/command/container/opts.go:48-146`

**Description:** Aggregates all container creation options. While not exported, it defines the pattern for option structs.

**Structure Pattern:**
```go
type containerOptions struct {
    // List-based options (repeatable flags)
    attach       opts.ListOpts
    volumes      opts.ListOpts
    env          opts.ListOpts

    // Map-based options (key=value flags)
    sysctls      *opts.MapOpts
    annotations  *opts.MapOpts

    // Specialized option types
    mounts       opts.MountOpt
    ulimits      *opts.UlimitOpt
    gpus         opts.GpuOpts

    // Memory/CPU types
    memory       opts.MemBytes
    cpus         opts.NanoCPUs

    // Simple types
    privileged   bool
    hostname     string
    cpuShares    int64
    // ... 60+ total fields
}
```

**Key Pattern:** Mix of custom types implementing pflag.Value for complex parsing.

### 2. containerConfig (internal struct)

**Location:** `cli/command/container/opts.go:331-335`

**Description:** Result of parse(), contains Docker API-ready structs.

```go
type containerConfig struct {
    Config           *container.Config
    HostConfig       *container.HostConfig
    NetworkingConfig *network.NetworkingConfig
}
```

## Custom Option Types (opts/ package)

All custom types implement the pflag.Value interface:

```go
type Value interface {
    String() string      // Return string representation
    Set(string) error    // Parse and set value from string
    Type() string        // Return type name for help text
}
```

### ListOpts - Repeatable String Options

**Location:** `opts/opts.go:23-129`

```go
type ListOpts struct {
    values    *[]string
    validator ValidatorFctType
}

func NewListOpts(validator ValidatorFctType) ListOpts
func NewListOptsRef(values *[]string, validator ValidatorFctType) *ListOpts
```

**Methods:**
| Method | Returns | Description |
|--------|---------|-------------|
| Set(value string) error | error | Validates and appends value to list |
| String() string | string | Returns string representation |
| Type() string | string | Returns "list" |
| GetSlice() []string | []string | Returns underlying slice |
| GetMap() map[string]struct{} | map | Returns deduplicated map |
| GetAllOrEmpty() []string | []string | Returns slice or empty slice (never nil) |
| Get(key string) bool | bool | Checks if value exists |
| Len() int | int | Returns count of values |
| WithValidator(ValidatorFctType) *ListOpts | *ListOpts | Sets validator |

**Example:**
```go
// Create with validator
envOpts := opts.NewListOpts(opts.ValidateEnv)
flags.VarP(&envOpts, "env", "e", "Set environment variables")
// After parsing:
envVars := envOpts.GetSlice() // ["KEY=value", "VAR=data"]
```

**Validator Signature:**
```go
type ValidatorFctType func(val string) (string, error)
```

Validator receives raw value, returns transformed value or error.

### MapOpts - Key-Value Options

**Location:** `opts/opts.go:131-175`

```go
type MapOpts struct {
    values    map[string]string
    validator ValidatorFctType
}

func NewMapOpts(values map[string]string, validator ValidatorFctType) *MapOpts
```

**Methods:**
| Method | Returns | Description |
|--------|---------|-------------|
| Set(value string) error | error | Parses "key=value", validates, stores |
| GetAll() map[string]string | map | Returns underlying map |
| String() string | string | Returns string representation |
| Type() string | string | Returns "map" |

**Example:**
```go
sysctls := opts.NewMapOpts(nil, opts.ValidateSysctl)
flags.Var(sysctls, "sysctl", "Sysctl options")
// After parsing --sysctl net.core.somaxconn=1024:
sysctlMap := sysctls.GetAll() // {"net.core.somaxconn": "1024"}
```

### MemBytes - Human-Readable Memory Sizes

**Location:** `opts/opts.go:405-444`

```go
type MemBytes int64

func (m *MemBytes) Set(value string) error  // Parses "128M", "2g", etc.
func (m *MemBytes) Value() int64            // Returns bytes as int64
func (m *MemBytes) String() string          // Returns human-readable format
func (m *MemBytes) Type() string            // Returns "bytes"
```

**Parsing:**
- Supports: b, k, m, g, kb, mb, gb (case-insensitive)
- Examples: "256M" → 268435456, "2g" → 2147483648
- Uses github.com/docker/go-units for parsing

**Example:**
```go
var memory opts.MemBytes
flags.VarP(&memory, "memory", "m", "Memory limit")
// After parsing --memory 512M:
bytes := memory.Value() // 536870912
```

### MemSwapBytes - Memory with -1 Support

**Location:** `opts/opts.go:446-480`

Similar to MemBytes but allows -1 for unlimited swap.

```go
type MemSwapBytes int64

func (m *MemSwapBytes) Set(value string) error
```

**Special Case:** "-1" is valid and represents unlimited swap.

### NanoCPUs - Fractional CPU Values

**Location:** `opts/opts.go:331-370`

```go
type NanoCPUs int64

func (c *NanoCPUs) Set(value string) error  // Parses "1.5" → 1500000000
func (c *NanoCPUs) Value() int64            // Returns nanocpus
func (c *NanoCPUs) String() string          // Returns decimal format
func ParseCPUs(value string) (int64, error) // Standalone parser
```

**Precision:** Converts decimal CPUs to nanocpus (1 CPU = 1e9 nanocpus)

**Example:**
```go
var cpus opts.NanoCPUs
flags.Var(&cpus, "cpus", "Number of CPUs")
// After parsing --cpus 2.5:
nanocpus := cpus.Value() // 2500000000
```

### UlimitOpt - Ulimit Configuration

**Location:** `opts/ulimit.go:11-63`

```go
type UlimitOpt struct {
    values *map[string]*container.Ulimit
}

func NewUlimitOpt(ref *map[string]*container.Ulimit) *UlimitOpt
```

**Methods:**
| Method | Returns | Description |
|--------|---------|-------------|
| Set(val string) error | error | Parses ulimit (e.g., "nofile=1024:2048") |
| GetList() []*container.Ulimit | []*container.Ulimit | Returns sorted slice |
| String() string | string | Returns string representation |
| Type() string | string | Returns "ulimit" |

**Format:** `name=soft[:hard]`

**Example:**
```go
ulimits := opts.NewUlimitOpt(nil)
flags.Var(ulimits, "ulimit", "Ulimit options")
// After parsing --ulimit nofile=1024:2048:
list := ulimits.GetList() // []*container.Ulimit
```

### MountOpt - Mount Specifications

**Location:** `opts/mount.go:16-228`

```go
type MountOpt struct {
    values []mounttypes.Mount
}
```

**Methods:**
| Method | Returns | Description |
|--------|---------|-------------|
| Set(value string) error | error | Parses CSV mount spec |
| Value() []mounttypes.Mount | []mounttypes.Mount | Returns mount slice |
| String() string | string | Returns string representation |
| Type() string | string | Returns "mount" |

**Mount Spec Format (CSV):**
```
type=<type>,source=<path>,target=<path>[,option=value,...]
```

**Supported Keys:**
| Key | Description | Example |
|-----|-------------|---------|
| type | Mount type (volume, bind, tmpfs, image) | type=bind |
| source, src | Source path/volume | source=/host/path |
| target, dst, destination | Container path | target=/container/path |
| readonly, ro | Read-only flag | readonly=true |
| bind-propagation | Bind propagation mode | bind-propagation=shared |
| bind-recursive | Recursive bind mode | bind-recursive=enabled |
| volume-driver | Volume driver | volume-driver=local |
| volume-opt | Volume driver options | volume-opt=type=nfs |
| tmpfs-size | Tmpfs size | tmpfs-size=100M |
| tmpfs-mode | Tmpfs mode | tmpfs-mode=1777 |

**Example:**
```go
var mounts opts.MountOpt
flags.Var(&mounts, "mount", "Attach a filesystem mount")
// After parsing --mount type=bind,source=/data,target=/data,readonly:
mountList := mounts.Value() // []mounttypes.Mount
```

### NetworkOpt - Network Attachments

**Location:** `opts/network.go:24-158`

```go
type NetworkOpt struct {
    options []NetworkAttachmentOpts
}

type NetworkAttachmentOpts struct {
    Target       string
    Aliases      []string
    DriverOpts   map[string]string
    Links        []string
    IPv4Address  netip.Addr
    IPv6Address  netip.Addr
    LinkLocalIPs []netip.Addr
    MacAddress   string
    GwPriority   int
}
```

**Methods:**
| Method | Returns | Description |
|--------|---------|-------------|
| Set(value string) error | error | Parses network name or CSV spec |
| Value() []NetworkAttachmentOpts | []NetworkAttachmentOpts | Returns network configs |
| NetworkMode() string | string | Returns first network name |
| String() string | string | Returns empty string |
| Type() string | string | Returns "network" |

**Format:**
- Simple: `bridge` (just network name)
- Advanced: `name=mynet,alias=web,ip=172.20.0.2` (CSV)

**Advanced Options:**
| Key | Description |
|-----|-------------|
| name | Network name/ID |
| alias | Network-scoped alias |
| ip | IPv4 address |
| ip6 | IPv6 address |
| mac-address | MAC address |
| link-local-ip | Link-local IP |
| driver-opt | Driver-specific options |
| gw-priority | Gateway priority |

**Example:**
```go
var netMode opts.NetworkOpt
flags.Var(&netMode, "network", "Connect to network")
// After parsing --network name=mynet,ip=172.20.0.5:
nets := netMode.Value() // []NetworkAttachmentOpts
```

### WeightdeviceOpt - Block IO Weight Devices

**Location:** `opts/weightdevice.go:38-84`

```go
type WeightdeviceOpt struct {
    values    []*blkiodev.WeightDevice
    validator ValidatorWeightFctType
}

func NewWeightdeviceOpt(validator ValidatorWeightFctType) WeightdeviceOpt
```

**Format:** `/dev/sda:500` (device:weight)

**Validation:**
- Weight must be 0 or 10-1000
- Device path must start with `/dev/`

**Example:**
```go
opt := opts.NewWeightdeviceOpt(opts.ValidateWeightDevice)
flags.Var(&opt, "blkio-weight-device", "Block IO weight")
// After parsing --blkio-weight-device /dev/sda:500:
devices := opt.GetList() // []*blkiodev.WeightDevice
```

### ThrottledeviceOpt - Block IO Throttling

**Location:** `opts/throttledevice.go:57-105`

```go
type ThrottledeviceOpt struct {
    values    []*blkiodev.ThrottleDevice
    validator ValidatorThrottleFctType
}

func NewThrottledeviceOpt(validator ValidatorThrottleFctType) ThrottledeviceOpt
```

**Validators:**
- `ValidateThrottleBpsDevice`: For bytes/sec (supports units: kb, mb, gb)
- `ValidateThrottleIOpsDevice`: For IO operations/sec (integer only)

**Format:**
- BPS: `/dev/sda:1mb` (device:rate with unit)
- IOPS: `/dev/sda:1000` (device:rate)

**Example:**
```go
readBps := opts.NewThrottledeviceOpt(opts.ValidateThrottleBpsDevice)
flags.Var(&readBps, "device-read-bps", "Limit read rate")
// After parsing --device-read-bps /dev/sda:10mb:
devices := readBps.GetList() // []*blkiodev.ThrottleDevice
```

### GpuOpts - GPU Device Requests

**Location:** `opts/gpus.go:13-118`

```go
type GpuOpts struct {
    values []container.DeviceRequest
}
```

**Methods:**
| Method | Returns | Description |
|--------|---------|-------------|
| Set(value string) error | error | Parses GPU request spec |
| Value() []container.DeviceRequest | []container.DeviceRequest | Returns device requests |
| String() string | string | Returns string representation |
| Type() string | string | Returns "gpu-request" |

**Format (CSV):**
```
all                           # All GPUs
2                             # 2 GPUs
driver=nvidia,count=all       # Explicit options
device=0,1,capabilities=gpu   # Specific devices
```

**Options:**
| Key | Description | Example |
|-----|-------------|---------|
| driver | GPU driver | driver=nvidia |
| count | GPU count or "all" | count=2 |
| device | Device IDs (comma-separated) | device=0,1 |
| capabilities | Capabilities (comma-separated) | capabilities=compute,utility |
| options | Driver-specific options | options=key=value |

**Example:**
```go
var gpus opts.GpuOpts
flags.Var(&gpus, "gpus", "GPU devices to add")
// After parsing --gpus all:
requests := gpus.Value() // []container.DeviceRequest
```

### FilterOpt - Filter Options

**Location:** `opts/opts.go:283-329`

```go
type FilterOpt struct {
    filter client.Filters  // map[string][]string
}

func NewFilterOpt() FilterOpt
```

**Methods:**
| Method | Returns | Description |
|--------|---------|-------------|
| Set(value string) error | error | Parses "key=value" filter |
| Value() client.Filters | client.Filters | Returns filters map |
| String() string | string | Returns JSON representation |
| Type() string | string | Returns "filter" |

**Format:** `name=value`

**Example:**
```go
filters := opts.NewFilterOpt()
flags.Var(&filters, "filter", "Filter output")
// After parsing --filter name=mycontainer --filter status=running:
filterMap := filters.Value() // map[string][]string{"name": ["mycontainer"], "status": ["running"]}
```

## Validator Functions

Validators transform and validate input strings. They're used with ListOpts and MapOpts.

**Signature:**
```go
type ValidatorFctType func(val string) (string, error)
```

### Built-in Validators

**Location:** `opts/opts.go`, `opts/env.go`, `opts/hosts.go`

| Function | Purpose | Example Input → Output |
|----------|---------|------------------------|
| ValidateIPAddress | Validates IP addresses | "192.168.1.1" → "192.168.1.1" |
| ValidateDNSSearch | Validates DNS search domains | "example.com" → "example.com" |
| ValidateLabel | Validates labels (key=value) | "app=web" → "app=web" |
| ValidateSysctl | Validates sysctl settings | "net.core.somaxconn=1024" → "net.core.somaxconn=1024" |
| ValidateEnv | Validates environment vars | "KEY" → "KEY=value" (from env) |
| ValidateLink | Validates container links | "db:database" → "db:database" |
| ValidateExtraHost | Validates extra hosts | "host=1.2.3.4" → "host:1.2.3.4" |

**ValidateEnv Special Behavior:**
```go
func ValidateEnv(val string) (string, error)
```
- If value has `=`, returns as-is
- If no `=`, looks up environment variable and returns `KEY=value`
- Allows passing environment variables through to container

**Example:**
```go
envOpts := opts.NewListOpts(opts.ValidateEnv)
// User passes: --env PATH
// Validator returns: "PATH=/usr/local/bin:/usr/bin:/bin"
```

**ValidateExtraHost Format Transformation:**
```go
func ValidateExtraHost(val string) (string, error)
```
- Accepts: `host=ip` or `host:ip`
- Returns: Always `host:ip` (colon format for API)
- Supports: IPv4, IPv6, and special `host-gateway` name

### Custom Validator Pattern

**Example - Custom Domain Validator:**
```go
func validateCustomDomain(val string) (string, error) {
    if !strings.HasSuffix(val, ".local") {
        return "", fmt.Errorf("domain must end with .local")
    }
    return strings.ToLower(val), nil
}

// Usage:
domains := opts.NewListOpts(validateCustomDomain)
```

## Utility Functions

### Parse Functions

**Location:** `opts/parse.go`

#### ReadKVStrings
```go
func ReadKVStrings(files []string, override []string) ([]string, error)
```

**Description:** Reads key=value pairs from files and merges with overrides.

**Parameters:**
| Name | Type | Description |
|------|------|-------------|
| files | []string | Paths to files containing key=value lines |
| override | []string | Key=value strings that override file values |

**Returns:** Merged slice of key=value strings

**Example:**
```go
labels, err := opts.ReadKVStrings(
    []string{"/path/to/labels.txt"},
    []string{"env=prod", "version=1.2"},
)
```

#### ReadKVEnvStrings
```go
func ReadKVEnvStrings(files []string, override []string) ([]string, error)
```

**Description:** Like ReadKVStrings but resolves values from environment if not specified.

**Example:**
```go
// File contains: DATABASE_URL
// Environment has: DATABASE_URL=postgres://...
envVars, err := opts.ReadKVEnvStrings(
    []string{"/path/to/env.txt"},
    []string{"DEBUG=true"},
)
// Result includes: DATABASE_URL=postgres://...
```

#### ConvertKVStringsToMap
```go
func ConvertKVStringsToMap(values []string) map[string]string
```

**Description:** Converts `["key=value"]` to `{"key":"value"}`

**Example:**
```go
m := opts.ConvertKVStringsToMap([]string{"a=1", "b=2"})
// m = map[string]string{"a": "1", "b": "2"}
```

#### ConvertKVStringsToMapWithNil
```go
func ConvertKVStringsToMapWithNil(values []string) map[string]*string
```

**Description:** Converts to map but uses nil for keys without values.

**Use Case:** Distinguish between `FOO=` (empty string) and `FOO` (unset/inherit)

**Example:**
```go
m := opts.ConvertKVStringsToMapWithNil([]string{"A=value", "B"})
// m = map[string]*string{"A": &"value", "B": nil}
```

#### ParseRestartPolicy
```go
func ParseRestartPolicy(policy string) (container.RestartPolicy, error)
```

**Description:** Parses restart policy strings.

**Format:** `mode[:max-retry-count]`

**Examples:**
| Input | Output |
|-------|--------|
| "no" | RestartPolicy{Name: "no"} |
| "always" | RestartPolicy{Name: "always"} |
| "on-failure:5" | RestartPolicy{Name: "on-failure", MaximumRetryCount: 5} |

#### ParseLink
```go
func ParseLink(val string) (string, string, error)
```

**Description:** Parses container link format.

**Format:** `container:alias`

**Returns:** (container, alias, error)

**Example:**
```go
container, alias, err := opts.ParseLink("redis:db")
// container = "redis", alias = "db"
```

#### ParseCPUs
```go
func ParseCPUs(value string) (int64, error)
```

**Description:** Parses CPU count to nanocpus.

**Example:**
```go
nano, err := opts.ParseCPUs("2.5")
// nano = 2500000000
```

## Command Integration Pattern

### How Commands Consume These APIs

**Pattern used by `docker run`, `docker create`, etc.:**

```go
// 1. Create flag set
flags := pflag.NewFlagSet("run", pflag.ContinueOnError)

// 2. Register all container flags
copts := addFlags(flags)

// 3. Add command-specific flags
flags.String("name", "", "Container name")

// 4. Parse arguments
flags.Parse(args)

// 5. Get server OS for validation
serverInfo, _ := client.Ping(ctx)

// 6. Convert to API structs
containerCfg, err := parse(flags, copts, serverInfo.OSType)

// 7. Use with Docker API
resp, err := client.ContainerCreate(ctx,
    containerCfg.Config,
    containerCfg.HostConfig,
    containerCfg.NetworkingConfig,
    nil,
    containerName,
)
```

**Key Files:**
- `cli/command/container/run.go`: runRun() function (lines 86-117)
- `cli/command/container/create.go`: runCreate() function (lines 97-132)

**Both follow pattern:**
1. Call `addFlags()` to register options
2. Parse proxy environment config
3. Ping daemon to get OS type
4. Call `parse()` to get containerConfig
5. Use config with Docker API

## Extension Points

### 1. Adding New Option Types

**Pattern:** Implement pflag.Value interface

```go
type CustomOpt struct {
    value CustomType
}

func (o *CustomOpt) String() string {
    // Return string representation
    return fmt.Sprintf("%v", o.value)
}

func (o *CustomOpt) Set(val string) error {
    // Parse string into internal value
    parsed, err := parseCustom(val)
    if err != nil {
        return err
    }
    o.value = parsed
    return nil
}

func (o *CustomOpt) Type() string {
    // Return type name for help text
    return "custom"
}

func (o *CustomOpt) Value() CustomType {
    // Getter for parsed value
    return o.value
}
```

**Usage:**
```go
// In addFlags():
var customOpt CustomOpt
flags.Var(&customOpt, "custom", "Custom option")

// In parse():
customValue := copts.customOpt.Value()
```

### 2. Adding New Container Options

**Pattern:** Extend containerOptions struct and update both phases

**Step 1 - Add to containerOptions struct:**
```go
type containerOptions struct {
    // ... existing fields
    newOption opts.ListOpts  // New field
}
```

**Step 2 - Initialize in addFlags():**
```go
func addFlags(flags *pflag.FlagSet) *containerOptions {
    copts := &containerOptions{
        // ... existing initializers
        newOption: opts.NewListOpts(customValidator),
    }

    // Register flag
    flags.Var(&copts.newOption, "new-option", "Description")

    return copts
}
```

**Step 3 - Use in parse():**
```go
func parse(flags *pflag.FlagSet, copts *containerOptions, serverOS string) (*containerConfig, error) {
    // ... existing parsing

    // Extract and transform new option
    newValues := copts.newOption.GetSlice()

    // Add to appropriate API struct
    config.NewField = newValues  // or transform as needed

    // ... rest of parsing
}
```

### 3. Custom Validators

**Pattern:** Function matching ValidatorFctType signature

```go
func ValidateCustomFormat(val string) (string, error) {
    // Validation logic
    if !isValid(val) {
        return "", fmt.Errorf("invalid format: %s", val)
    }
    // Optional transformation
    return transform(val), nil
}

// Usage:
customOpts := opts.NewListOpts(ValidateCustomFormat)
```

**Validator Best Practices:**
- Return transformed value (e.g., normalized format)
- Provide clear error messages
- Handle edge cases (empty strings, whitespace)
- Document expected format

### 4. Extending Existing Option Types

**ListOpts Extension - Add Helper Methods:**

```go
// Helper to filter values
func (opts *ListOpts) Filter(predicate func(string) bool) []string {
    result := []string{}
    for _, v := range opts.GetSlice() {
        if predicate(v) {
            result = append(result, v)
        }
    }
    return result
}
```

**MapOpts Extension - Add Validation:**

```go
// Wrap MapOpts with additional validation
type ValidatedMapOpts struct {
    *opts.MapOpts
    requiredKeys []string
}

func (v *ValidatedMapOpts) Validate() error {
    all := v.GetAll()
    for _, key := range v.requiredKeys {
        if _, ok := all[key]; !ok {
            return fmt.Errorf("required key missing: %s", key)
        }
    }
    return nil
}
```

## API Stability and Versioning

### Versioning Strategy

**No Semantic Versioning:** Docker CLI uses CalVer (Calendar Versioning), not SemVer. There's no go.mod, only vendor.mod.

**API Version Annotations:**
```go
flags.SetAnnotation("flag-name", "version", []string{"1.40"})
```

Indicates minimum Docker API version required for flag.

**OS-Specific Flags:**
```go
flags.SetAnnotation("cpu-count", "ostype", []string{"windows"})
```

Indicates flag is only valid for specific OS.

### Stability Guarantees

**Stable Interfaces:**
- `pflag.Value` interface (String, Set, Type methods)
- Public constructors (NewListOpts, NewMapOpts, etc.)
- Validator function signatures
- Parse utility functions

**Internal Implementation:**
- containerOptions struct is unexported (internal)
- parse() function is unexported (internal to package)
- Field names and structure can change

**Deprecation Pattern:**
```go
var stub opts.MemBytes
flags.Var(&stub, "kernel-memory", "Kernel memory limit (deprecated)")
_ = flags.MarkDeprecated("kernel-memory", "and no longer supported by the kernel")
```

Uses pflag's built-in deprecation marking.

### Backward Compatibility

**Default Values:**
```go
if copts.swappiness == -1 {
    // Don't set swappiness (daemon default)
}
```

Sentinel values preserve backward compatibility with older daemons.

**Conditional Fields:**
```go
if flags.Changed("stop-timeout") {
    config.StopTimeout = &copts.stopTimeout
}
```

Only set fields when explicitly provided by user.

**API Version Checks:**
Commands ping daemon to get API version and conditionally enable features.

### Migration Path

**For Option Type Changes:**

1. **Add new type alongside old:**
```go
type containerOptions struct {
    oldOption opts.ListOpts  // Keep for compatibility
    newOption NewOptionType  // New implementation
}
```

2. **Deprecate old flag:**
```go
flags.MarkDeprecated("old-flag", "use --new-flag instead")
```

3. **In parse(), support both:**
```go
if flags.Changed("new-flag") {
    // Use new
} else if flags.Changed("old-flag") {
    // Use old (deprecated path)
}
```

4. **Remove after grace period**

## Real-World Usage Examples

### Example 1: Basic Container Creation

```go
import (
    "github.com/docker/cli/cli/command/container"
    "github.com/docker/cli/opts"
    "github.com/spf13/pflag"
)

func createContainer() error {
    flags := pflag.NewFlagSet("create", pflag.ContinueOnError)
    copts := container.addFlags(flags)  // Note: addFlags is unexported in real code

    // Simulate parsing: docker run -d --name web -p 80:80 -e DEBUG=1 nginx
    args := []string{
        "-d",
        "--name", "web",
        "-p", "80:80",
        "-e", "DEBUG=1",
        "nginx",
    }

    flags.Parse(args)

    // Get server OS
    serverInfo, _ := client.Ping(ctx)

    // Parse into API structs
    containerCfg, err := parse(flags, copts, serverInfo.OSType)
    if err != nil {
        return err
    }

    // Create container
    resp, err := client.ContainerCreate(ctx,
        containerCfg.Config,
        containerCfg.HostConfig,
        containerCfg.NetworkingConfig,
        nil,
        "web",
    )

    return err
}
```

### Example 2: Custom Option Type

```go
// Define custom option type for duration ranges
type DurationRangeOpt struct {
    min, max time.Duration
}

func (d *DurationRangeOpt) String() string {
    return fmt.Sprintf("%v-%v", d.min, d.max)
}

func (d *DurationRangeOpt) Set(val string) error {
    parts := strings.Split(val, "-")
    if len(parts) != 2 {
        return fmt.Errorf("invalid range format: %s", val)
    }

    var err error
    d.min, err = time.ParseDuration(parts[0])
    if err != nil {
        return err
    }
    d.max, err = time.ParseDuration(parts[1])
    if err != nil {
        return err
    }

    if d.min > d.max {
        return fmt.Errorf("min > max in range: %s", val)
    }

    return nil
}

func (d *DurationRangeOpt) Type() string {
    return "duration-range"
}

// Usage:
var retryRange DurationRangeOpt
flags.Var(&retryRange, "retry-range", "Retry backoff range")
// User: --retry-range 1s-30s
```

### Example 3: Reusable Validator

```go
// Validator for semantic version strings
func ValidateSemver(val string) (string, error) {
    // Simple regex check (use proper semver lib in production)
    matched, _ := regexp.MatchString(`^\d+\.\d+\.\d+$`, val)
    if !matched {
        return "", fmt.Errorf("invalid semver: %s", val)
    }
    return val, nil
}

// Usage with ListOpts
versionOpts := opts.NewListOpts(ValidateSemver)
flags.Var(&versionOpts, "version", "Semantic versions")

// Usage with MapOpts
versionMap := opts.NewMapOpts(nil, ValidateSemver)
flags.Var(versionMap, "version-map", "Version mappings")
```

### Example 4: Complex Mount Configuration

```go
var mounts opts.MountOpt
flags.Var(&mounts, "mount", "Mount specification")

// User provides:
// --mount type=bind,source=/host/data,target=/data,readonly
// --mount type=volume,source=myvolume,target=/app,volume-driver=nfs

// After parsing:
mountList := mounts.Value()
for _, m := range mountList {
    fmt.Printf("Type: %s, Source: %s, Target: %s, RO: %v\n",
        m.Type, m.Source, m.Target, m.ReadOnly)

    if m.VolumeOptions != nil {
        fmt.Printf("  Volume driver: %s\n", m.VolumeOptions.DriverConfig.Name)
    }
}
```

## Extension Patterns for Adaptation

### Pattern 1: Wrap-and-Extend

Reuse Docker's option types with custom validation:

```go
type ExtendedContainerOptions struct {
    baseOpts    *dockerContainer.containerOptions
    customField CustomType
}

func (e *ExtendedContainerOptions) AddFlags(flags *pflag.FlagSet) {
    // Reuse Docker's flag registration
    e.baseOpts = dockerContainer.addFlags(flags)

    // Add custom flags
    flags.Var(&e.customField, "custom", "Custom option")
}
```

### Pattern 2: Compose Custom Options

Build new option structs using Docker's types:

```go
type ApplicationOptions struct {
    Container struct {
        Memory       opts.MemBytes
        CPUs         opts.NanoCPUs
        Env          opts.ListOpts
    }
    Database struct {
        Host     string
        Port     int
        Replicas opts.ListOpts
    }
}

func (a *ApplicationOptions) RegisterFlags(flags *pflag.FlagSet) {
    a.Container.Env = opts.NewListOpts(opts.ValidateEnv)
    flags.VarP(&a.Container.Memory, "memory", "m", "Container memory")
    flags.Var(&a.Container.Env, "env", "Environment variables")

    a.Database.Replicas = opts.NewListOpts(validateDBHost)
    flags.StringVar(&a.Database.Host, "db-host", "localhost", "Database host")
    flags.Var(&a.Database.Replicas, "db-replica", "Database replicas")
}
```

### Pattern 3: Extract Core Option Types

Use Docker's option types in non-container contexts:

```go
type JobConfiguration struct {
    Memory       opts.MemBytes    // Reuse memory parsing
    CPUs         opts.NanoCPUs    // Reuse CPU parsing
    Environment  opts.ListOpts    // Reuse env var handling
    Labels       opts.MapOpts     // Reuse label handling
    Mounts       opts.MountOpt    // Reuse mount parsing
}

func NewJobConfiguration() *JobConfiguration {
    return &JobConfiguration{
        Environment: opts.NewListOpts(opts.ValidateEnv),
        Labels:      *opts.NewMapOpts(nil, opts.ValidateLabel),
    }
}
```

## Testing Considerations

### Unit Testing Option Types

**Pattern:** Test Set, String, and Value methods

```go
func TestMemBytesSet(t *testing.T) {
    var m opts.MemBytes

    tests := []struct {
        input    string
        expected int64
        wantErr  bool
    }{
        {"128M", 134217728, false},
        {"2g", 2147483648, false},
        {"invalid", 0, true},
    }

    for _, tt := range tests {
        err := m.Set(tt.input)
        if (err != nil) != tt.wantErr {
            t.Errorf("Set(%q) error = %v, wantErr %v", tt.input, err, tt.wantErr)
        }
        if !tt.wantErr && m.Value() != tt.expected {
            t.Errorf("Value() = %v, want %v", m.Value(), tt.expected)
        }
    }
}
```

### Testing Validators

```go
func TestValidateEnv(t *testing.T) {
    os.Setenv("TEST_VAR", "test_value")
    defer os.Unsetenv("TEST_VAR")

    tests := []struct {
        input    string
        expected string
        wantErr  bool
    }{
        {"KEY=value", "KEY=value", false},
        {"TEST_VAR", "TEST_VAR=test_value", false},
        {"", "", true},  // Empty key
    }

    for _, tt := range tests {
        got, err := opts.ValidateEnv(tt.input)
        if (err != nil) != tt.wantErr {
            t.Errorf("ValidateEnv(%q) error = %v, wantErr %v", tt.input, err, tt.wantErr)
        }
        if got != tt.expected {
            t.Errorf("ValidateEnv(%q) = %q, want %q", tt.input, got, tt.expected)
        }
    }
}
```

### Integration Testing parse()

```go
func TestParse(t *testing.T) {
    flags := pflag.NewFlagSet("test", pflag.ContinueOnError)
    copts := addFlags(flags)

    // Set up args
    args := []string{
        "--memory", "512M",
        "--cpus", "2.0",
        "-e", "FOO=bar",
        "--label", "app=web",
    }

    flags.Parse(args)

    // Parse
    cfg, err := parse(flags, copts, "linux")
    if err != nil {
        t.Fatalf("parse() error = %v", err)
    }

    // Verify
    if cfg.HostConfig.Memory != 536870912 {
        t.Errorf("Memory = %v, want 536870912", cfg.HostConfig.Memory)
    }

    if cfg.HostConfig.NanoCPUs != 2000000000 {
        t.Errorf("NanoCPUs = %v, want 2000000000", cfg.HostConfig.NanoCPUs)
    }

    if cfg.Config.Env[0] != "FOO=bar" {
        t.Errorf("Env = %v, want [FOO=bar]", cfg.Config.Env)
    }
}
```

## Adaptation Recommendations

### Core Interface to Replicate

**Essential Components:**

1. **Option Type System:**
   - ListOpts for repeatable string options
   - MapOpts for key-value options
   - MemBytes for memory sizes
   - Custom types implementing pflag.Value

2. **Validator System:**
   - ValidatorFctType function signature
   - Common validators (IP, env, label)
   - Composition with option types

3. **Two-Phase Pattern:**
   - Registration phase (addFlags)
   - Parsing phase (parse)
   - Separation of CLI concerns from API concerns

4. **Utility Functions:**
   - ReadKVStrings for file-based config
   - ConvertKVStringsToMap for transformation
   - Type-specific parsers (ParseCPUs, etc.)

### Optional Interface

**Can be omitted or simplified:**

- Container-specific validators (device paths, etc.)
- OS-specific validation logic
- Complex mount/network parsing (use simpler alternatives)
- Docker API version annotations
- Proxy configuration merging

### Extension Considerations

**For New Applications:**

1. **Custom Option Types:** Follow pflag.Value interface
2. **Validator Composition:** Chain multiple validators
3. **Middleware Pattern:** Wrap option types with pre/post-processing
4. **Configuration Sources:** Extend ReadKVStrings for multiple sources
5. **Type Safety:** Consider using generics for type-safe options

**Recommended Additions:**

- JSON/YAML unmarshaling for option types
- Environment variable overrides
- Configuration file support
- Default value inheritance
- Option groups/categories for organization

## Architecture Insights

### Design Strengths

1. **Separation of Concerns:**
   - Flag registration separate from parsing
   - CLI parsing separate from API struct generation
   - Validation separate from storage

2. **Composability:**
   - Small, focused option types
   - Validators can be reused
   - Option types can be embedded

3. **Type Safety:**
   - Custom types prevent invalid states
   - Compile-time checks for method signatures
   - Value() methods provide typed access

4. **Extensibility:**
   - Easy to add new option types
   - Validators are pluggable
   - pflag.Value is a minimal interface

5. **Validation at Parse Time:**
   - Errors caught early
   - Clear error messages
   - Per-option validation

### Design Trade-offs

1. **Complexity:**
   - Two-phase pattern requires understanding both phases
   - Many small types to manage
   - Validation logic spread across package

2. **Type Proliferation:**
   - ~15 custom option types
   - Each implements 3-4 methods
   - Boilerplate for simple types

3. **String-Based Parsing:**
   - All values pass through strings
   - Parsing can be expensive
   - Type conversion overhead

4. **Tight Docker Coupling:**
   - containerOptions maps closely to Docker API
   - Hard to reuse for non-Docker contexts
   - Validates Docker-specific constraints

5. **Unexported Core Functions:**
   - addFlags() and parse() are unexported
   - Cannot directly reuse pattern
   - Must copy or extract pattern

### Recommended Improvements for Adaptation

1. **Export Core Pattern:**
```go
// Make pattern reusable
type OptionSet interface {
    AddFlags(*pflag.FlagSet) error
    Parse(*pflag.FlagSet) (Config, error)
}
```

2. **Generic Option Types:**
```go
// Type-safe option with generics
type Option[T any] struct {
    value     T
    parser    func(string) (T, error)
    validator func(T) error
}
```

3. **Builder Pattern:**
```go
// Fluent API for option registration
opts := NewOptionBuilder().
    AddMemory("memory", "512M").
    AddCPUs("cpus", 2.0).
    AddEnv("env", ValidateEnv).
    Build()
```

4. **Middleware Support:**
```go
// Option middleware for cross-cutting concerns
type OptionMiddleware func(Setter) Setter

opts := NewOptions().
    WithMiddleware(LoggingMiddleware).
    WithMiddleware(ValidationMiddleware)
```

5. **Structured Configuration:**
```go
// Support multiple config sources
cfg := LoadConfiguration().
    FromFile("config.yaml").
    FromEnv("APP_").
    FromFlags(flags).
    Build()
```

## Summary

The Docker CLI container options pattern provides a robust, extensible system for command-line option handling. Key strengths include:

- **Reusable option types** implementing pflag.Value interface
- **Composable validators** for input validation and transformation
- **Two-phase design** separating flag registration from parsing
- **Type safety** through custom types for complex values
- **Rich parsing** supporting memory sizes, CPUs, mounts, networks, etc.

The pattern is well-suited for adaptation to other CLI applications requiring complex option handling, though the specific container-centric types may need to be generalized for broader use cases.
