// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package project

import (
	"context"
	"sync"
)

// Ensure, that ProjectMock does implement Project.
// If this is not the case, regenerate this file with moq.
var _ Project = &ProjectMock{}

// ProjectMock is a mock implementation of Project.
//
//	func TestSomethingThatUsesProject(t *testing.T) {
//
//		// make and configure a mocked Project
//		mockedProject := &ProjectMock{
//			AddWorktreeFunc: func(ctx context.Context, branch string, base string) (WorktreeState, error) {
//				panic("mock out the AddWorktree method")
//			},
//			CreateWorktreeFunc: func(ctx context.Context, branch string, base string) (string, error) {
//				panic("mock out the CreateWorktree method")
//			},
//			GetWorktreeFunc: func(ctx context.Context, branch string) (WorktreeState, error) {
//				panic("mock out the GetWorktree method")
//			},
//			ListWorktreesFunc: func(ctx context.Context) ([]WorktreeState, error) {
//				panic("mock out the ListWorktrees method")
//			},
//			NameFunc: func() string {
//				panic("mock out the Name method")
//			},
//			PruneStaleWorktreesFunc: func(ctx context.Context, dryRun bool) (*PruneStaleResult, error) {
//				panic("mock out the PruneStaleWorktrees method")
//			},
//			RecordFunc: func() (ProjectRecord, error) {
//				panic("mock out the Record method")
//			},
//			RemoveWorktreeFunc: func(ctx context.Context, branch string) error {
//				panic("mock out the RemoveWorktree method")
//			},
//			RepoPathFunc: func() string {
//				panic("mock out the RepoPath method")
//			},
//		}
//
//		// use mockedProject in code that requires Project
//		// and then make assertions.
//
//	}
type ProjectMock struct {
	// AddWorktreeFunc mocks the AddWorktree method.
	AddWorktreeFunc func(ctx context.Context, branch string, base string) (WorktreeState, error)

	// CreateWorktreeFunc mocks the CreateWorktree method.
	CreateWorktreeFunc func(ctx context.Context, branch string, base string) (string, error)

	// GetWorktreeFunc mocks the GetWorktree method.
	GetWorktreeFunc func(ctx context.Context, branch string) (WorktreeState, error)

	// ListWorktreesFunc mocks the ListWorktrees method.
	ListWorktreesFunc func(ctx context.Context) ([]WorktreeState, error)

	// NameFunc mocks the Name method.
	NameFunc func() string

	// PruneStaleWorktreesFunc mocks the PruneStaleWorktrees method.
	PruneStaleWorktreesFunc func(ctx context.Context, dryRun bool) (*PruneStaleResult, error)

	// RecordFunc mocks the Record method.
	RecordFunc func() (ProjectRecord, error)

	// RemoveWorktreeFunc mocks the RemoveWorktree method.
	RemoveWorktreeFunc func(ctx context.Context, branch string) error

	// RepoPathFunc mocks the RepoPath method.
	RepoPathFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// AddWorktree holds details about calls to the AddWorktree method.
		AddWorktree []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Branch is the branch argument value.
			Branch string
			// Base is the base argument value.
			Base string
		}
		// CreateWorktree holds details about calls to the CreateWorktree method.
		CreateWorktree []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Branch is the branch argument value.
			Branch string
			// Base is the base argument value.
			Base string
		}
		// GetWorktree holds details about calls to the GetWorktree method.
		GetWorktree []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Branch is the branch argument value.
			Branch string
		}
		// ListWorktrees holds details about calls to the ListWorktrees method.
		ListWorktrees []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Name holds details about calls to the Name method.
		Name []struct {
		}
		// PruneStaleWorktrees holds details about calls to the PruneStaleWorktrees method.
		PruneStaleWorktrees []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DryRun is the dryRun argument value.
			DryRun bool
		}
		// Record holds details about calls to the Record method.
		Record []struct {
		}
		// RemoveWorktree holds details about calls to the RemoveWorktree method.
		RemoveWorktree []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Branch is the branch argument value.
			Branch string
		}
		// RepoPath holds details about calls to the RepoPath method.
		RepoPath []struct {
		}
	}
	lockAddWorktree         sync.RWMutex
	lockCreateWorktree      sync.RWMutex
	lockGetWorktree         sync.RWMutex
	lockListWorktrees       sync.RWMutex
	lockName                sync.RWMutex
	lockPruneStaleWorktrees sync.RWMutex
	lockRecord              sync.RWMutex
	lockRemoveWorktree      sync.RWMutex
	lockRepoPath            sync.RWMutex
}

// AddWorktree calls AddWorktreeFunc.
func (mock *ProjectMock) AddWorktree(ctx context.Context, branch string, base string) (WorktreeState, error) {
	if mock.AddWorktreeFunc == nil {
		panic("ProjectMock.AddWorktreeFunc: method is nil but Project.AddWorktree was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Branch string
		Base   string
	}{
		Ctx:    ctx,
		Branch: branch,
		Base:   base,
	}
	mock.lockAddWorktree.Lock()
	mock.calls.AddWorktree = append(mock.calls.AddWorktree, callInfo)
	mock.lockAddWorktree.Unlock()
	return mock.AddWorktreeFunc(ctx, branch, base)
}

// AddWorktreeCalls gets all the calls that were made to AddWorktree.
// Check the length with:
//
//	len(mockedProject.AddWorktreeCalls())
func (mock *ProjectMock) AddWorktreeCalls() []struct {
	Ctx    context.Context
	Branch string
	Base   string
} {
	var calls []struct {
		Ctx    context.Context
		Branch string
		Base   string
	}
	mock.lockAddWorktree.RLock()
	calls = mock.calls.AddWorktree
	mock.lockAddWorktree.RUnlock()
	return calls
}

// CreateWorktree calls CreateWorktreeFunc.
func (mock *ProjectMock) CreateWorktree(ctx context.Context, branch string, base string) (string, error) {
	if mock.CreateWorktreeFunc == nil {
		panic("ProjectMock.CreateWorktreeFunc: method is nil but Project.CreateWorktree was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Branch string
		Base   string
	}{
		Ctx:    ctx,
		Branch: branch,
		Base:   base,
	}
	mock.lockCreateWorktree.Lock()
	mock.calls.CreateWorktree = append(mock.calls.CreateWorktree, callInfo)
	mock.lockCreateWorktree.Unlock()
	return mock.CreateWorktreeFunc(ctx, branch, base)
}

// CreateWorktreeCalls gets all the calls that were made to CreateWorktree.
// Check the length with:
//
//	len(mockedProject.CreateWorktreeCalls())
func (mock *ProjectMock) CreateWorktreeCalls() []struct {
	Ctx    context.Context
	Branch string
	Base   string
} {
	var calls []struct {
		Ctx    context.Context
		Branch string
		Base   string
	}
	mock.lockCreateWorktree.RLock()
	calls = mock.calls.CreateWorktree
	mock.lockCreateWorktree.RUnlock()
	return calls
}

// GetWorktree calls GetWorktreeFunc.
func (mock *ProjectMock) GetWorktree(ctx context.Context, branch string) (WorktreeState, error) {
	if mock.GetWorktreeFunc == nil {
		panic("ProjectMock.GetWorktreeFunc: method is nil but Project.GetWorktree was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Branch string
	}{
		Ctx:    ctx,
		Branch: branch,
	}
	mock.lockGetWorktree.Lock()
	mock.calls.GetWorktree = append(mock.calls.GetWorktree, callInfo)
	mock.lockGetWorktree.Unlock()
	return mock.GetWorktreeFunc(ctx, branch)
}

// GetWorktreeCalls gets all the calls that were made to GetWorktree.
// Check the length with:
//
//	len(mockedProject.GetWorktreeCalls())
func (mock *ProjectMock) GetWorktreeCalls() []struct {
	Ctx    context.Context
	Branch string
} {
	var calls []struct {
		Ctx    context.Context
		Branch string
	}
	mock.lockGetWorktree.RLock()
	calls = mock.calls.GetWorktree
	mock.lockGetWorktree.RUnlock()
	return calls
}

// ListWorktrees calls ListWorktreesFunc.
func (mock *ProjectMock) ListWorktrees(ctx context.Context) ([]WorktreeState, error) {
	if mock.ListWorktreesFunc == nil {
		panic("ProjectMock.ListWorktreesFunc: method is nil but Project.ListWorktrees was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListWorktrees.Lock()
	mock.calls.ListWorktrees = append(mock.calls.ListWorktrees, callInfo)
	mock.lockListWorktrees.Unlock()
	return mock.ListWorktreesFunc(ctx)
}

// ListWorktreesCalls gets all the calls that were made to ListWorktrees.
// Check the length with:
//
//	len(mockedProject.ListWorktreesCalls())
func (mock *ProjectMock) ListWorktreesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListWorktrees.RLock()
	calls = mock.calls.ListWorktrees
	mock.lockListWorktrees.RUnlock()
	return calls
}

// Name calls NameFunc.
func (mock *ProjectMock) Name() string {
	if mock.NameFunc == nil {
		panic("ProjectMock.NameFunc: method is nil but Project.Name was just called")
	}
	callInfo := struct {
	}{}
	mock.lockName.Lock()
	mock.calls.Name = append(mock.calls.Name, callInfo)
	mock.lockName.Unlock()
	return mock.NameFunc()
}

// NameCalls gets all the calls that were made to Name.
// Check the length with:
//
//	len(mockedProject.NameCalls())
func (mock *ProjectMock) NameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockName.RLock()
	calls = mock.calls.Name
	mock.lockName.RUnlock()
	return calls
}

// PruneStaleWorktrees calls PruneStaleWorktreesFunc.
func (mock *ProjectMock) PruneStaleWorktrees(ctx context.Context, dryRun bool) (*PruneStaleResult, error) {
	if mock.PruneStaleWorktreesFunc == nil {
		panic("ProjectMock.PruneStaleWorktreesFunc: method is nil but Project.PruneStaleWorktrees was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		DryRun bool
	}{
		Ctx:    ctx,
		DryRun: dryRun,
	}
	mock.lockPruneStaleWorktrees.Lock()
	mock.calls.PruneStaleWorktrees = append(mock.calls.PruneStaleWorktrees, callInfo)
	mock.lockPruneStaleWorktrees.Unlock()
	return mock.PruneStaleWorktreesFunc(ctx, dryRun)
}

// PruneStaleWorktreesCalls gets all the calls that were made to PruneStaleWorktrees.
// Check the length with:
//
//	len(mockedProject.PruneStaleWorktreesCalls())
func (mock *ProjectMock) PruneStaleWorktreesCalls() []struct {
	Ctx    context.Context
	DryRun bool
} {
	var calls []struct {
		Ctx    context.Context
		DryRun bool
	}
	mock.lockPruneStaleWorktrees.RLock()
	calls = mock.calls.PruneStaleWorktrees
	mock.lockPruneStaleWorktrees.RUnlock()
	return calls
}

// Record calls RecordFunc.
func (mock *ProjectMock) Record() (ProjectRecord, error) {
	if mock.RecordFunc == nil {
		panic("ProjectMock.RecordFunc: method is nil but Project.Record was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRecord.Lock()
	mock.calls.Record = append(mock.calls.Record, callInfo)
	mock.lockRecord.Unlock()
	return mock.RecordFunc()
}

// RecordCalls gets all the calls that were made to Record.
// Check the length with:
//
//	len(mockedProject.RecordCalls())
func (mock *ProjectMock) RecordCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRecord.RLock()
	calls = mock.calls.Record
	mock.lockRecord.RUnlock()
	return calls
}

// RemoveWorktree calls RemoveWorktreeFunc.
func (mock *ProjectMock) RemoveWorktree(ctx context.Context, branch string) error {
	if mock.RemoveWorktreeFunc == nil {
		panic("ProjectMock.RemoveWorktreeFunc: method is nil but Project.RemoveWorktree was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Branch string
	}{
		Ctx:    ctx,
		Branch: branch,
	}
	mock.lockRemoveWorktree.Lock()
	mock.calls.RemoveWorktree = append(mock.calls.RemoveWorktree, callInfo)
	mock.lockRemoveWorktree.Unlock()
	return mock.RemoveWorktreeFunc(ctx, branch)
}

// RemoveWorktreeCalls gets all the calls that were made to RemoveWorktree.
// Check the length with:
//
//	len(mockedProject.RemoveWorktreeCalls())
func (mock *ProjectMock) RemoveWorktreeCalls() []struct {
	Ctx    context.Context
	Branch string
} {
	var calls []struct {
		Ctx    context.Context
		Branch string
	}
	mock.lockRemoveWorktree.RLock()
	calls = mock.calls.RemoveWorktree
	mock.lockRemoveWorktree.RUnlock()
	return calls
}

// RepoPath calls RepoPathFunc.
func (mock *ProjectMock) RepoPath() string {
	if mock.RepoPathFunc == nil {
		panic("ProjectMock.RepoPathFunc: method is nil but Project.RepoPath was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRepoPath.Lock()
	mock.calls.RepoPath = append(mock.calls.RepoPath, callInfo)
	mock.lockRepoPath.Unlock()
	return mock.RepoPathFunc()
}

// RepoPathCalls gets all the calls that were made to RepoPath.
// Check the length with:
//
//	len(mockedProject.RepoPathCalls())
func (mock *ProjectMock) RepoPathCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRepoPath.RLock()
	calls = mock.calls.RepoPath
	mock.lockRepoPath.RUnlock()
	return calls
}
