// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/schmitthub/clawker/internal/socketbridge"
	"sync"
)

// Ensure, that SocketBridgeManagerMock does implement socketbridge.SocketBridgeManager.
// If this is not the case, regenerate this file with moq.
var _ socketbridge.SocketBridgeManager = &SocketBridgeManagerMock{}

// SocketBridgeManagerMock is a mock implementation of socketbridge.SocketBridgeManager.
//
//	func TestSomethingThatUsesSocketBridgeManager(t *testing.T) {
//
//		// make and configure a mocked socketbridge.SocketBridgeManager
//		mockedSocketBridgeManager := &SocketBridgeManagerMock{
//			EnsureBridgeFunc: func(containerID string, gpgEnabled bool) error {
//				panic("mock out the EnsureBridge method")
//			},
//			IsRunningFunc: func(containerID string) bool {
//				panic("mock out the IsRunning method")
//			},
//			StopAllFunc: func() error {
//				panic("mock out the StopAll method")
//			},
//			StopBridgeFunc: func(containerID string) error {
//				panic("mock out the StopBridge method")
//			},
//		}
//
//		// use mockedSocketBridgeManager in code that requires socketbridge.SocketBridgeManager
//		// and then make assertions.
//
//	}
type SocketBridgeManagerMock struct {
	// EnsureBridgeFunc mocks the EnsureBridge method.
	EnsureBridgeFunc func(containerID string, gpgEnabled bool) error

	// IsRunningFunc mocks the IsRunning method.
	IsRunningFunc func(containerID string) bool

	// StopAllFunc mocks the StopAll method.
	StopAllFunc func() error

	// StopBridgeFunc mocks the StopBridge method.
	StopBridgeFunc func(containerID string) error

	// calls tracks calls to the methods.
	calls struct {
		// EnsureBridge holds details about calls to the EnsureBridge method.
		EnsureBridge []struct {
			// ContainerID is the containerID argument value.
			ContainerID string
			// GpgEnabled is the gpgEnabled argument value.
			GpgEnabled bool
		}
		// IsRunning holds details about calls to the IsRunning method.
		IsRunning []struct {
			// ContainerID is the containerID argument value.
			ContainerID string
		}
		// StopAll holds details about calls to the StopAll method.
		StopAll []struct {
		}
		// StopBridge holds details about calls to the StopBridge method.
		StopBridge []struct {
			// ContainerID is the containerID argument value.
			ContainerID string
		}
	}
	lockEnsureBridge sync.RWMutex
	lockIsRunning    sync.RWMutex
	lockStopAll      sync.RWMutex
	lockStopBridge   sync.RWMutex
}

// EnsureBridge calls EnsureBridgeFunc.
func (mock *SocketBridgeManagerMock) EnsureBridge(containerID string, gpgEnabled bool) error {
	if mock.EnsureBridgeFunc == nil {
		panic("SocketBridgeManagerMock.EnsureBridgeFunc: method is nil but SocketBridgeManager.EnsureBridge was just called")
	}
	callInfo := struct {
		ContainerID string
		GpgEnabled  bool
	}{
		ContainerID: containerID,
		GpgEnabled:  gpgEnabled,
	}
	mock.lockEnsureBridge.Lock()
	mock.calls.EnsureBridge = append(mock.calls.EnsureBridge, callInfo)
	mock.lockEnsureBridge.Unlock()
	return mock.EnsureBridgeFunc(containerID, gpgEnabled)
}

// EnsureBridgeCalls gets all the calls that were made to EnsureBridge.
// Check the length with:
//
//	len(mockedSocketBridgeManager.EnsureBridgeCalls())
func (mock *SocketBridgeManagerMock) EnsureBridgeCalls() []struct {
	ContainerID string
	GpgEnabled  bool
} {
	var calls []struct {
		ContainerID string
		GpgEnabled  bool
	}
	mock.lockEnsureBridge.RLock()
	calls = mock.calls.EnsureBridge
	mock.lockEnsureBridge.RUnlock()
	return calls
}

// IsRunning calls IsRunningFunc.
func (mock *SocketBridgeManagerMock) IsRunning(containerID string) bool {
	if mock.IsRunningFunc == nil {
		panic("SocketBridgeManagerMock.IsRunningFunc: method is nil but SocketBridgeManager.IsRunning was just called")
	}
	callInfo := struct {
		ContainerID string
	}{
		ContainerID: containerID,
	}
	mock.lockIsRunning.Lock()
	mock.calls.IsRunning = append(mock.calls.IsRunning, callInfo)
	mock.lockIsRunning.Unlock()
	return mock.IsRunningFunc(containerID)
}

// IsRunningCalls gets all the calls that were made to IsRunning.
// Check the length with:
//
//	len(mockedSocketBridgeManager.IsRunningCalls())
func (mock *SocketBridgeManagerMock) IsRunningCalls() []struct {
	ContainerID string
} {
	var calls []struct {
		ContainerID string
	}
	mock.lockIsRunning.RLock()
	calls = mock.calls.IsRunning
	mock.lockIsRunning.RUnlock()
	return calls
}

// StopAll calls StopAllFunc.
func (mock *SocketBridgeManagerMock) StopAll() error {
	if mock.StopAllFunc == nil {
		panic("SocketBridgeManagerMock.StopAllFunc: method is nil but SocketBridgeManager.StopAll was just called")
	}
	callInfo := struct {
	}{}
	mock.lockStopAll.Lock()
	mock.calls.StopAll = append(mock.calls.StopAll, callInfo)
	mock.lockStopAll.Unlock()
	return mock.StopAllFunc()
}

// StopAllCalls gets all the calls that were made to StopAll.
// Check the length with:
//
//	len(mockedSocketBridgeManager.StopAllCalls())
func (mock *SocketBridgeManagerMock) StopAllCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockStopAll.RLock()
	calls = mock.calls.StopAll
	mock.lockStopAll.RUnlock()
	return calls
}

// StopBridge calls StopBridgeFunc.
func (mock *SocketBridgeManagerMock) StopBridge(containerID string) error {
	if mock.StopBridgeFunc == nil {
		panic("SocketBridgeManagerMock.StopBridgeFunc: method is nil but SocketBridgeManager.StopBridge was just called")
	}
	callInfo := struct {
		ContainerID string
	}{
		ContainerID: containerID,
	}
	mock.lockStopBridge.Lock()
	mock.calls.StopBridge = append(mock.calls.StopBridge, callInfo)
	mock.lockStopBridge.Unlock()
	return mock.StopBridgeFunc(containerID)
}

// StopBridgeCalls gets all the calls that were made to StopBridge.
// Check the length with:
//
//	len(mockedSocketBridgeManager.StopBridgeCalls())
func (mock *SocketBridgeManagerMock) StopBridgeCalls() []struct {
	ContainerID string
} {
	var calls []struct {
		ContainerID string
	}
	mock.lockStopBridge.RLock()
	calls = mock.calls.StopBridge
	mock.lockStopBridge.RUnlock()
	return calls
}
