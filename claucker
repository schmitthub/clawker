#!/usr/bin/env bash
set -euo pipefail

# claucker - Convenience wrapper for running Claude Code containers
# Version: 1.0.0

# ============================================================================
# Default Configuration
# ============================================================================

SCRIPT_NAME="claucker"
SCRIPT_VERSION="1.0.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Default values
DEFAULT_TYPE="base"
TYPE="$DEFAULT_TYPE"
PROJECT_PATH="$(pwd)"
ENABLE_USER_CLAUDE=false
SYSTEM_CLAUDE_PATH=""
ENABLE_FIREWALL=false
ENABLE_RM=true
CONTAINER_NAME=""
VERBOSE=false
DEBUG=false

# Arrays for docker args and command args
DOCKER_ARGS=()
COMMAND_ARGS=()

# ============================================================================
# Color Output (optional, for better UX)
# ============================================================================

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

error() {
    echo -e "${RED}Error:${NC} $*" >&2
}

warning() {
    echo -e "${YELLOW}Warning:${NC} $*" >&2
}

success() {
    echo -e "${GREEN}$*${NC}"
}

debug() {
    if [[ "$DEBUG" == "true" ]]; then
        echo -e "[DEBUG] $*" >&2
    fi
}

# ============================================================================
# Help Message
# ============================================================================

show_help() {
    cat << EOF
Usage: $SCRIPT_NAME [OPTIONS] [COMMAND...]

Run Claude Code containers with simplified configuration.

OPTIONS:
    -t, --type TYPE         Container type: base, node, python, go, rust
                           (default: base)
    -p, --project PATH      Project directory to mount to /workspace
                           (default: current directory)
    -u, --user-claude       Mount ~/.claude to /home/claude/.claude
    -s, --system-claude PATH
                           Mount custom system Claude directory to
                           /home/claude/.system-claude
    -f, --firewall          Enable network isolation with firewall
    -n, --name NAME         Container name (optional)
    -r, --rm                Auto-remove container on exit (default: true)
    --no-rm                 Don't auto-remove container
    -v, --verbose           Show docker command before running
    -d, --debug             Enable debug output
    -h, --help              Show this help message
    --version               Show version information

DOCKER PASS-THROUGH:
    Use -- to pass additional flags to docker run.
    If passing both docker flags AND a command, use -- twice:

    $SCRIPT_NAME --type node -- --env NODE_ENV=prod -- npm start
                              ^  docker flags         ^  command

COMMAND EXECUTION:
    Any arguments after flags are passed as the command to run in the container.
    If no command is provided, runs interactively with Claude Code.

EXAMPLES:
    # Run base image interactively in current directory
    $SCRIPT_NAME

    # Run Node.js container with user config
    $SCRIPT_NAME --type node --user-claude

    # Run Python tests with firewall enabled
    $SCRIPT_NAME -t python -f pytest tests/

    # Custom project with system config
    $SCRIPT_NAME -p /path/to/project -s /etc/claude-config

    # Pass environment variables with command
    $SCRIPT_NAME -t node -- --env NODE_ENV=production -- npm start

    # Pass docker flags only (runs interactively)
    $SCRIPT_NAME -- --env DEBUG=1

    # Named container that persists after exit
    $SCRIPT_NAME -t rust --name my-rust-env --no-rm

    # Complex: Python with all features
    $SCRIPT_NAME -t python -u -f -p /my/project -- --env DEBUG=1 -- pytest

ENVIRONMENT:
    DOCKER_USERNAME         DockerHub username (required)
                           Set via: export DOCKER_USERNAME=your-username
                           Or create .env file: DOCKER_USERNAME=your-username

IMAGE NAMING:
    Images use format: \${DOCKER_USERNAME}/claude-container:{type}
    Example: ajschmitt/claude-container:node

For more information, visit:
    https://github.com/anthropics/claude-container

EOF
}

show_version() {
    echo "$SCRIPT_NAME version $SCRIPT_VERSION"
}

# ============================================================================
# Environment Setup
# ============================================================================

load_environment() {
    # Source .env file if it exists in script directory
    local env_file="$SCRIPT_DIR/.env"
    if [[ -f "$env_file" ]]; then
        debug "Loading environment from $env_file"
        # Check for insecure permissions (world-writable)
        if [[ "$(uname)" == "Darwin" ]]; then
            # macOS
            local perms=$(stat -f "%p" "$env_file" 2>/dev/null | tail -c 4)
        else
            # Linux
            local perms=$(stat -c "%a" "$env_file" 2>/dev/null)
        fi
        if [[ $perms =~ [2367]$ ]]; then
            warning ".env file has insecure permissions: $perms"
            warning "Consider: chmod 600 $env_file"
        fi
        # shellcheck disable=SC1090
        set -a
        source "$env_file"
        set +a
    fi

    # Validate DOCKER_USERNAME is set
    if [[ -z "${DOCKER_USERNAME:-}" ]]; then
        error "DOCKER_USERNAME not set"
        echo "Set it via one of these methods:" >&2
        echo "  1. export DOCKER_USERNAME=your-username" >&2
        echo "  2. Create $SCRIPT_DIR/.env with: DOCKER_USERNAME=your-username" >&2
        exit 1
    fi
}

# ============================================================================
# Validation Functions
# ============================================================================

validate_type() {
    local type=$1
    debug "Validating container type: $type"
    case "$type" in
        base|node|python|go|rust)
            return 0
            ;;
        *)
            error "Invalid container type: '$type'"
            echo "Valid types: base, node, python, go, rust" >&2
            return 1
            ;;
    esac
}

validate_directory() {
    local path=$1
    local name=$2

    if [[ ! -d "$path" ]]; then
        error "$name directory does not exist: $path"
        return 1
    fi

    # Convert to absolute path using subshell to avoid side effects
    (cd "$path" && pwd)
}

check_docker_running() {
    if ! docker info >/dev/null 2>&1; then
        error "Docker is not running"
        echo "Please start Docker and try again" >&2
        return 1
    fi
}

check_required_tools() {
    if ! command -v docker >/dev/null 2>&1; then
        error "docker command not found"
        echo "Please install Docker: https://docs.docker.com/get-docker/" >&2
        return 1
    fi
}

check_image_exists() {
    local image=$1

    # Check if image exists locally
    if docker image inspect "$image" >/dev/null 2>&1; then
        return 0
    fi

    # Try to pull the image
    warning "Image '$image' not found locally"
    echo "Attempting to pull from DockerHub..." >&2

    if docker pull "$image" >&2; then
        success "Successfully pulled $image"
        return 0
    else
        error "Failed to pull image: $image"
        echo "Build it locally with: make build-${TYPE}" >&2
        return 1
    fi
}

# ============================================================================
# Docker Command Builder
# ============================================================================

# Global array to hold the docker command
DOCKER_CMD=()

build_docker_command() {
    debug "Building docker command"
    DOCKER_CMD=("docker" "run")

    # Auto-remove flag
    if [[ "$ENABLE_RM" == "true" ]]; then
        DOCKER_CMD+=("--rm")
        debug "  Auto-remove enabled"
    fi

    # Interactive mode: use -it only if we have a TTY
    if [[ ${#COMMAND_ARGS[@]} -eq 0 ]]; then
        # Interactive mode
        if [[ -t 0 ]] && [[ -t 1 ]]; then
            DOCKER_CMD+=("-it")
            debug "  Interactive mode with TTY"
        else
            DOCKER_CMD+=("-i")
            debug "  Interactive mode without TTY"
        fi
    else
        # Command mode
        DOCKER_CMD+=("-i")
        debug "  Command mode"
    fi

    # Container name
    if [[ -n "$CONTAINER_NAME" ]]; then
        DOCKER_CMD+=("--name" "$CONTAINER_NAME")
    fi

    # Mount project directory to /workspace
    DOCKER_CMD+=("-v" "${PROJECT_PATH}:/workspace")
    debug "  Mounting project: $PROJECT_PATH"

    # Mount user Claude config if requested
    if [[ "$ENABLE_USER_CLAUDE" == "true" ]]; then
        local user_claude="$HOME/.claude"
        if [[ -d "$user_claude" ]]; then
            DOCKER_CMD+=("-v" "${user_claude}:/home/claude/.claude")
            debug "  Mounting user claude config: $user_claude"
        else
            warning "~/.claude directory not found, skipping user-claude mount"
        fi
    fi

    # Mount system Claude config if path provided
    if [[ -n "$SYSTEM_CLAUDE_PATH" ]]; then
        if [[ -d "$SYSTEM_CLAUDE_PATH" ]]; then
            DOCKER_CMD+=("-v" "${SYSTEM_CLAUDE_PATH}:/home/claude/.system-claude")
            debug "  Mounting system claude config: $SYSTEM_CLAUDE_PATH"
        else
            error "System Claude directory does not exist: $SYSTEM_CLAUDE_PATH"
            exit 1
        fi
    fi

    # Enable firewall if requested
    if [[ "$ENABLE_FIREWALL" == "true" ]]; then
        DOCKER_CMD+=("--cap-add=NET_ADMIN")
        debug "  Firewall enabled (NET_ADMIN capability added)"
    fi

    # Add custom docker arguments from pass-through
    if [[ ${#DOCKER_ARGS[@]} -gt 0 ]]; then
        DOCKER_CMD+=("${DOCKER_ARGS[@]}")
        debug "  Added ${#DOCKER_ARGS[@]} custom docker argument(s)"
    fi

    # Image name
    local image="${DOCKER_USERNAME}/claude-container:${TYPE}"
    DOCKER_CMD+=("$image")
    debug "  Using image: $image"

    # Handle firewall initialization + command wrapping
    if [[ "$ENABLE_FIREWALL" == "true" ]]; then
        if [[ ${#COMMAND_ARGS[@]} -eq 0 ]]; then
            # No command: run interactive shell after firewall init
            DOCKER_CMD+=("bash" "-c" "sudo /usr/local/bin/init-firewall.sh && claude")
            debug "  Firewall init + interactive claude"
        else
            # With command: properly escape each argument to prevent injection
            local escaped_cmd=""
            for arg in "${COMMAND_ARGS[@]}"; do
                escaped_cmd+="$(printf '%q ' "$arg")"
            done
            DOCKER_CMD+=("bash" "-c" "sudo /usr/local/bin/init-firewall.sh && $escaped_cmd")
            debug "  Firewall init + command: ${COMMAND_ARGS[*]}"
        fi
    else
        # No firewall: just add command args directly
        if [[ ${#COMMAND_ARGS[@]} -gt 0 ]]; then
            DOCKER_CMD+=("${COMMAND_ARGS[@]}")
            debug "  Command: ${COMMAND_ARGS[*]}"
        fi
    fi
}

# ============================================================================
# Argument Parsing
# ============================================================================

parse_arguments() {
    # Check if no arguments provided
    if [[ $# -eq 0 ]]; then
        return 0
    fi

    # Manual argument parsing (portable, no GNU getopt required)
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            --version)
                show_version
                exit 0
                ;;
            -t|--type)
                if [[ -z "${2:-}" ]] || [[ "$2" == -* ]]; then
                    error "--type requires an argument"
                    exit 1
                fi
                TYPE="$2"
                shift 2
                ;;
            -p|--project)
                if [[ -z "${2:-}" ]] || [[ "$2" == -* ]]; then
                    error "--project requires an argument"
                    exit 1
                fi
                PROJECT_PATH="$2"
                shift 2
                ;;
            -u|--user-claude)
                ENABLE_USER_CLAUDE=true
                shift
                ;;
            -s|--system-claude)
                if [[ -z "${2:-}" ]] || [[ "$2" == -* ]]; then
                    error "--system-claude requires an argument"
                    exit 1
                fi
                SYSTEM_CLAUDE_PATH="$2"
                shift 2
                ;;
            -f|--firewall)
                ENABLE_FIREWALL=true
                shift
                ;;
            -n|--name)
                if [[ -z "${2:-}" ]] || [[ "$2" == -* ]]; then
                    error "--name requires an argument"
                    exit 1
                fi
                CONTAINER_NAME="$2"
                shift 2
                ;;
            -r|--rm)
                ENABLE_RM=true
                shift
                ;;
            --no-rm)
                ENABLE_RM=false
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -d|--debug)
                DEBUG=true
                VERBOSE=true  # Debug implies verbose
                shift
                ;;
            --)
                # Everything after -- goes to docker pass-through or command
                shift
                # Look for another -- separator
                local found_second_separator=false
                while [[ $# -gt 0 ]]; do
                    if [[ "$1" == "--" ]] && [[ "$found_second_separator" == "false" ]]; then
                        found_second_separator=true
                        shift
                        # Everything after this second -- is the command
                        COMMAND_ARGS=("$@")
                        return 0
                    else
                        DOCKER_ARGS+=("$1")
                        shift
                    fi
                done
                # If no second separator found, DOCKER_ARGS stay as docker flags
                # and we run interactively (no command)
                return 0
                ;;
            -*)
                error "Unknown option: $1"
                echo "Run '$SCRIPT_NAME --help' for usage information" >&2
                exit 1
                ;;
            *)
                # First non-option argument starts the command
                COMMAND_ARGS=("$@")
                return 0
                ;;
        esac
    done
}

# ============================================================================
# Error Handlers
# ============================================================================

# Trap errors
trap 'error "Command failed on line $LINENO"' ERR

# Handle interrupts gracefully
# Exit code 130 = 128 + SIGINT(2), standard for interrupted commands
trap 'echo ""; echo "Interrupted by user"; exit 130' INT

# ============================================================================
# Main Function
# ============================================================================

main() {
    # 1. Parse arguments
    parse_arguments "$@"
    debug "Parsed arguments: TYPE=$TYPE, PROJECT_PATH=$PROJECT_PATH"

    # 2. Load environment and validate DOCKER_USERNAME
    load_environment
    debug "DOCKER_USERNAME=$DOCKER_USERNAME"

    # 3. Run preflight checks
    check_required_tools
    check_docker_running

    # 4. Validate container type
    validate_type "$TYPE"

    # 5. Validate and resolve project path
    PROJECT_PATH=$(validate_directory "$PROJECT_PATH" "Project")
    debug "Resolved project path: $PROJECT_PATH"

    # 6. Check if image exists (pull if needed)
    local image="${DOCKER_USERNAME}/claude-container:${TYPE}"
    check_image_exists "$image"

    # 7. Build docker command
    build_docker_command

    # 8. Show command if verbose mode
    if [[ "$VERBOSE" == "true" ]]; then
        echo "Running: ${DOCKER_CMD[*]}" >&2
        echo "" >&2
    fi

    # 9. Execute docker command
    debug "Executing docker command"
    "${DOCKER_CMD[@]}"
}

# ============================================================================
# Script Entry Point
# ============================================================================

main "$@"
