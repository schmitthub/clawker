# Docker CLI Codebase Structure: Container Options DRY Pattern

> Generated by codebase-scanner for docker-cli repository
> Analysis Date: January 2026
> Focus: Container Options Pattern Implementation

---

## Executive Summary

The Docker CLI repository demonstrates a mature, production-tested architectural pattern for managing shared container-related flags across multiple commands. The implementation uses a **three-layer abstraction**:

1. **Options Storage Layer**: `containerOptions` struct holds parsed flag values
2. **Flag Registration Layer**: `addFlags()` initializes and registers all flags with pflag
3. **API Conversion Layer**: `parse()` transforms options into backend API structures

This pattern eliminates duplication of 98+ container flags while maintaining type safety, validation, and API version compatibility. The codebase is organized into clear, composable modules that separate concerns effectively.

---

## Repository Overview

```
Repository: docker-cli
Primary Language: Go (~95%)
Secondary Language: Bash (~5%)
Framework: Cobra (command framework), pflag (flag parsing)
Build System: docker buildx bake
Package Manager: Go modules (vendor.mod for CalVer)
Organization Pattern: Hybrid (by-feature/by-layer)
Estimated Size: ~3,500+ files, ~200+ directories
```

### Repository Location & Git Status

- **Path**: `/Users/andrew/Code/vendor/docker/docker-cli`
- **Current Branch**: `explore`
- **Main Branch**: `master`
- **Recent Commit**: `e216886bf5` (serena init)

### Key Statistics

- **cli/command/container/opts.go**: 1,155 lines (core pattern implementation)
- **opts/ package**: 20+ files providing reusable flag types
- **Container command files**: 60+ Go files in `cli/command/container/`
- **Test coverage**: Comprehensive unit tests throughout

---

## Top-Level Repository Structure

```
docker-cli/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ docker/              # Entry point for CLI binary
â”‚       â””â”€â”€ docker.go        # Main CLI initialization
â”‚
â”œâ”€â”€ cli/                      # Core CLI functionality
â”‚   â”œâ”€â”€ command/             # Command implementations
â”‚   â”‚   â”œâ”€â”€ container/       # Container commands (focus of this survey)
â”‚   â”‚   â”œâ”€â”€ image/           # Image commands
â”‚   â”‚   â”œâ”€â”€ network/         # Network commands
â”‚   â”‚   â”œâ”€â”€ service/         # Service commands
â”‚   â”‚   â”œâ”€â”€ volume/          # Volume commands
â”‚   â”‚   â””â”€â”€ [20+ more]       # Other command groups
â”‚   â”œâ”€â”€ flags/               # Global CLI flags
â”‚   â”œâ”€â”€ config/              # Configuration file handling
â”‚   â”œâ”€â”€ context/             # Docker context management
â”‚   â””â”€â”€ streams/             # Input/output stream handling
â”‚
â”œâ”€â”€ opts/                     # Custom option types (KEY LAYER)
â”‚   â”œâ”€â”€ opts.go             # ListOpts, MapOpts, NanoCPUs, MemBytes
â”‚   â”œâ”€â”€ mount.go            # MountOpt for --mount flag
â”‚   â”œâ”€â”€ network.go          # NetworkOpt for --net flag
â”‚   â”œâ”€â”€ ulimit.go           # UlimitOpt for --ulimit flag
â”‚   â”œâ”€â”€ gpus.go             # GPUOpt for --gpus flag
â”‚   â”œâ”€â”€ duration.go         # Duration parsing
â”‚   â”œâ”€â”€ parse.go            # Utility parsing functions
â”‚   â””â”€â”€ [15+ more]          # Validators and specialized types
â”‚
â”œâ”€â”€ internal/                # Internal packages
â”‚   â”œâ”€â”€ commands/            # Command registration system
â”‚   â””â”€â”€ test/               # Test utilities
â”‚
â”œâ”€â”€ cli-plugins/             # Plugin system
â”‚   â””â”€â”€ manager/            # Plugin discovery and loading
â”‚
â”œâ”€â”€ docs/                    # Documentation
â”œâ”€â”€ e2e/                     # End-to-end tests
â”œâ”€â”€ scripts/                 # Build and utility scripts
â”œâ”€â”€ vendor/                  # Vendored dependencies
â””â”€â”€ [Configuration files: docker-bake.hcl, Dockerfile, Makefile, etc.]
```

---

## The Container Command Package: cli/command/container/

The `container` package is the primary user of the container options pattern. It implements 20+ subcommands for container management.

### Directory Structure

```
cli/command/container/
â”œâ”€â”€ opts.go                  # *** CORE PATTERN IMPLEMENTATION ***
â”‚   â”œâ”€â”€ containerOptions    # Struct holding all flag values (88 fields)
â”‚   â”œâ”€â”€ containerConfig     # Output struct with Config, HostConfig, NetworkingConfig
â”‚   â”œâ”€â”€ addFlags()          # Flag registration function (180 lines)
â”‚   â”œâ”€â”€ parse()             # Conversion to API types (400 lines)
â”‚   â”œâ”€â”€ Helper functions    # parseNetworkOpts, parseDevice, parseSecurityOpts, etc.
â”‚   â””â”€â”€ Validators          # validateAttach, validateDevice, validateLinuxPath, etc.
â”‚
â”œâ”€â”€ opts_test.go            # Comprehensive unit tests for opts.go
â”‚
â”œâ”€â”€ run.go                   # docker run command
â”‚   â””â”€â”€ Uses: addFlags() and parse()
â”‚
â”œâ”€â”€ create.go               # docker create command
â”‚   â””â”€â”€ Uses: addFlags() and parse()
â”‚
â”œâ”€â”€ exec.go                 # docker exec command
â”‚   â””â”€â”€ Limited option subset
â”‚
â”œâ”€â”€ cmd.go                  # Command group registration
â”‚
â”œâ”€â”€ [50+ other commands]    # attach, start, stop, restart, etc.
â”‚   â””â”€â”€ Mix of: full options, partial options, or no options
â”‚
â”œâ”€â”€ testdata/               # Test fixtures and data
â”œâ”€â”€ utils.go                # Utility functions
â”œâ”€â”€ utils_test.go           # Utility tests
â”œâ”€â”€ client_test.go          # Fake client for testing
â”‚
â””â”€â”€ formatter_*.go          # Output formatting (stats, diff)
```

### File Count & Organization

| Category | Count | Purpose |
|----------|-------|---------|
| Option files | 2 | opts.go, opts_test.go |
| Command implementations | 45+ | Individual subcommands |
| Command tests | 25+ | Test files (*_test.go) |
| Utility files | 5+ | formatter, utils, client_test |
| **Total** | **75+** | **Comprehensive container command suite** |

---

## The Pattern Implementation Details

### Layer 1: Options Storage - containerOptions Struct

**File**: `cli/command/container/opts.go:48-145`
**Lines**: ~100 lines of struct definition
**Purpose**: Intermediate storage for all parsed flag values

```go
type containerOptions struct {
    // Repeatable flags (ListOpts - for multi-value flags)
    attach    opts.ListOpts
    volumes   opts.ListOpts
    tmpfs     opts.ListOpts
    env       opts.ListOpts
    labels    opts.ListOpts
    devices   opts.ListOpts
    // ... 10+ more ListOpts

    // Key-value pair flags (MapOpts)
    sysctls       *opts.MapOpts
    annotations   *opts.MapOpts
    storageOpt    *opts.MapOpts

    // Complex structured types
    mounts   opts.MountOpt
    netMode  opts.NetworkOpt
    ulimits  *opts.UlimitOpt
    gpus     opts.GPUOpt

    // Typed scalar values
    memory    opts.MemBytes        // Parses "512m", "1g"
    cpus      opts.NanoCPUs        // Parses "1.5"
    cpuShares int64

    // Primitive types
    privileged      bool
    stdin           bool
    tty             bool
    hostname        string
    workingDir      string
    user            string
    cpuPercent      int64

    // Positional arguments (exported for command layer)
    Image string
    Args  []string
}
```

**Key Design Characteristics**:

1. **88 total fields** covering all container creation options
2. **Custom types for validation**: Uses `opts.ListOpts`, `opts.MapOpts`, `opts.MemBytes`, etc.
3. **Unexported fields**: Private (lowercase) for encapsulation
4. **Exported positional args**: `Image` and `Args` for command layer access
5. **No nested structs**: Flat structure for simplicity and directness

### Layer 2: Flag Registration - addFlags() Function

**File**: `cli/command/container/opts.go:148-328`
**Lines**: ~180 lines of flag registration
**Purpose**: Initialize options with validators and register all flags

```go
func addFlags(flags *pflag.FlagSet) *containerOptions {
    // Step 1: Create options struct with validators
    copts := &containerOptions{
        attach:    opts.NewListOpts(validateAttach),
        dns:       opts.NewListOpts(opts.ValidateIPAddress),
        env:       opts.NewListOpts(opts.ValidateEnv),
        labels:    opts.NewListOpts(opts.ValidateLabel),
        sysctls:   opts.NewMapOpts(nil, opts.ValidateSysctl),
        ulimits:   opts.NewUlimitOpt(nil),
        gpus:      opts.NewGPUOpt(),
        mounts:    opts.MountOpt{},
        netMode:   opts.NetworkOpt{},
        // ... 40+ more option initializations
    }

    // Step 2: Register individual flags with pflag
    // Repeatable flags
    flags.VarP(&copts.attach, "attach", "a",
        "Attach to STDIN, STDOUT or STDERR")
    flags.VarP(&copts.volumes, "volume", "v",
        "Mount a volume")
    flags.VarP(&copts.env, "env", "e",
        "Set environment variables")

    // Scalar flags
    flags.StringVar(&copts.hostname, "hostname", "",
        "Container host name")
    flags.StringVar(&copts.user, "user", "",
        "Username or UID")
    flags.Var(&copts.memory, "memory",
        "Memory limit")

    // Boolean flags
    flags.BoolVar(&copts.privileged, "privileged", false,
        "Give extended privileges to this container")
    flags.BoolVar(&copts.stdin, "interactive", false,
        "Keep STDIN open even if not attached")

    // Step 3: Add API version annotations
    flags.StringVar(&copts.cgroupnsMode, "cgroupns", "",
        "Cgroup namespace to use")
    _ = flags.SetAnnotation("cgroupns", "version", []string{"1.41"})

    flags.Var(&copts.gpus, "gpus", "GPU devices to add")
    _ = flags.SetAnnotation("gpus", "version", []string{"1.40"})

    // Step 4: Add platform-specific annotations (ostype)
    flags.Int64Var(&copts.cpuCount, "cpu-count", 0,
        "Number of CPUs (Windows)")
    _ = flags.SetAnnotation("cpu-count", "ostype", []string{"windows"})

    flags.Int64Var(&copts.ioMaxBandwidth, "io-maxbandwidth", 0,
        "Maximum IO bandwidth (Windows)")
    _ = flags.SetAnnotation("io-maxbandwidth", "ostype", []string{"windows"})

    // Step 5: Handle deprecated flags
    var stub opts.MemBytes
    flags.Var(&stub, "kernel-memory",
        "Kernel memory limit (deprecated)")
    _ = flags.MarkDeprecated("kernel-memory",
        "and no longer supported by the kernel")

    // Step 6: Handle flag aliases (same variable, different names)
    flags.Var(&copts.netMode, "net",
        "Connect a container to a network")
    flags.Var(&copts.netMode, "network",
        "Connect a container to a network")
    flags.MarkHidden("net")  // Hide legacy name

    return copts
}
```

**Feature Highlights**:

1. **Validator injection**: Each ListOpts/MapOpts gets a validator function during construction
2. **Version annotations**: Flags marked with minimum API versions (e.g., "1.41")
3. **OS-type annotations**: Platform-specific flags marked for validation
4. **Deprecation handling**: Old flags accepted but flagged as deprecated
5. **Flag aliases**: Multiple names for same variable (prefer new, hide old)
6. **Consistent help text**: Descriptive messages for each flag

### Layer 3: Conversion - parse() Function

**File**: `cli/command/container/opts.go:341-740`
**Lines**: ~400 lines of conversion and validation logic
**Purpose**: Transform containerOptions into API-compatible structures

```go
func parse(flags *pflag.FlagSet, copts *containerOptions,
    serverOS string) (*containerConfig, error) {

    // Step 1: Cross-field validation
    if copts.macAddress != "" {
        if _, err := net.ParseMAC(copts.macAddress); err != nil {
            return nil, fmt.Errorf("%s is not a valid mac address", copts.macAddress)
        }
    }

    // Step 2: Transform collected values
    envVariables, err := opts.ReadKVEnvStrings(
        copts.envFile.GetSlice(),
        copts.env.GetSlice(),
    )
    if err != nil {
        return nil, err
    }

    // Step 3: Server-OS-dependent validation
    for _, device := range copts.devices.GetSlice() {
        validated, err := validateDevice(device, serverOS)
        if err != nil {
            return nil, err
        }
    }

    // Step 4: Convert to API structures
    resources := container.Resources{
        Memory:           copts.memory.Value(),     // MemBytes â†’ int64
        NanoCPUs:         copts.cpus.Value(),       // NanoCPUs â†’ int64
        Ulimits:          copts.ulimits.GetList(),  // UlimitOpt â†’ []*Ulimit
        CPUShares:        copts.cpuShares,
        CPUPercent:       copts.cpuPercent,
        // ... 20+ more resource fields
    }

    config := &container.Config{
        Hostname:     copts.hostname,
        Domainname:   copts.domainname,
        User:         copts.user,
        AttachStdin:  copts.stdin,
        AttachStdout: strslice.StrSlice(copts.attach.GetSlice()).Contains("stdout"),
        AttachStderr: strslice.StrSlice(copts.attach.GetSlice()).Contains("stderr"),
        Env:          envVariables,
        Cmd:          strslice.StrSlice(copts.Args),
        Entrypoint:   copts.entrypoint.GetSlice(),
        Image:        copts.Image,
        Labels:       opts.ConvertKVStringsToMap(copts.labels.GetSlice()),
        // ... 10+ more config fields
    }

    hostConfig := &container.HostConfig{
        Resources:       resources,
        Mounts:          copts.mounts.Value(),
        Privileged:      copts.privileged,
        PidMode:         pidmode.PidMode(copts.pidMode),
        UTSMode:         utsmodes.UTSMode(copts.utsMode),
        IpcMode:         ipcmode.IpcMode(copts.ipcMode),
        // ... 30+ more hostconfig fields
    }

    // Step 5: Handle conditional fields
    if flags.Changed("init") {
        hostConfig.Init = &copts.init
    }

    if flags.Changed("pids-limit") {
        hostConfig.PidsLimit = &copts.pidsLimit
    }

    // Step 6: Parse and validate complex fields
    networkingConfig, err := parseNetworkOpts(flags, copts)
    if err != nil {
        return nil, err
    }

    return &containerConfig{
        Config:           config,
        HostConfig:       hostConfig,
        NetworkingConfig: networkingConfig,
    }, nil
}
```

**Key Responsibilities**:

1. **Cross-field validation**: Validates relationships between multiple options
2. **Type conversion**: Maps custom types to API types (MemBytes â†’ int64, etc.)
3. **Value transformation**: Combines multiple option values (env files + env flags)
4. **Conditional fields**: Uses `flags.Changed()` to detect explicit vs default values
5. **Server-dependent validation**: Adjusts validation based on server OS
6. **Complex parsing**: Calls helper functions for networking, security options, etc.

### Output Structure - containerConfig

**File**: `cli/command/container/opts.go:330-334`
**Lines**: ~5 lines
**Purpose**: Clean API-ready output structure

```go
type containerConfig struct {
    Config           *container.Config
    HostConfig       *container.HostConfig
    NetworkingConfig *network.NetworkingConfig
}
```

---

## The opts/ Package: Custom Option Types

**Location**: `/Users/andrew/Code/vendor/docker/docker-cli/opts/`
**File Count**: 20+ files
**Purpose**: Reusable flag types implementing `pflag.Value` interface

### Core Files

| File | Purpose | Key Types |
|------|---------|-----------|
| `opts.go` | Foundation types | ListOpts, MapOpts, NanoCPUs, MemBytes, MemSwapBytes, FilterOpt |
| `mount.go` | Mount flag parsing | MountOpt |
| `network.go` | Network mode parsing | NetworkOpt |
| `ulimit.go` | Ulimit flag parsing | UlimitOpt |
| `gpus.go` | GPU device flag | GPUOpt |
| `duration.go` | Duration parsing | Duration wrapper |
| `parse.go` | Utility functions | ParseCPUs, ParseLink, etc. |
| `env.go` | Environment variable handling | ReadKVEnvStrings, ReadEnvFile |
| `capabilities.go` | Linux capabilities | CapabilitiesOpt, validate functions |
| `hosts.go` | Host entries | ValidateDNSSearch, parseHostFile |
| `weightdevice.go` | I/O weight devices | WeightDevice |
| `throttledevice.go` | I/O throttle devices | ThrottleDevice |

### Type Hierarchy

```
pflag.Value (interface)
â”œâ”€â”€ ListOpts (repeatable flags)
â”‚   Methods: String(), Set(), Delete(), Get(), GetSlice(), GetMap(), Type()
â”‚
â”œâ”€â”€ MapOpts (key-value pairs)
â”‚   Methods: String(), Set(), GetAll(), Type()
â”‚
â”œâ”€â”€ MemBytes (memory with units)
â”‚   Example: "512m", "1g"
â”‚   Methods: String(), Set(), Type(), Value() â†’ int64
â”‚
â”œâ”€â”€ NanoCPUs (CPU fractions)
â”‚   Example: "1.5" â†’ 1500000000 nanoseconds
â”‚   Methods: String(), Set(), Type(), Value() â†’ int64
â”‚
â”œâ”€â”€ MemSwapBytes (swap with units)
â”‚   Methods: String(), Set(), Type(), Value() â†’ int64
â”‚
â”œâ”€â”€ FilterOpt (filter expressions)
â”‚   Example: "name=value"
â”‚   Methods: String(), Set(), Type(), Value() â†’ filters.Args
â”‚
â”œâ”€â”€ MountOpt (mount configuration)
â”‚   Example: "type=bind,source=/host,target=/container"
â”‚   Methods: Value() â†’ []mounttypes.Mount
â”‚
â”œâ”€â”€ NetworkOpt (network selection)
â”‚   Example: "bridge", "host", "container:name"
â”‚   Methods: Value() â†’ string, IsHost() â†’ bool
â”‚
â””â”€â”€ UlimitOpt (ulimit configuration)
    Example: "nofile=1024:2048"
    Methods: GetList() â†’ []*units.Ulimit
```

### ListOpts Implementation Example

```go
type ListOpts struct {
    values    *[]string
    validator ValidatorFctType
}

// Methods implementing pflag.Value
func (opts *ListOpts) String() string
func (opts *ListOpts) Set(value string) error  // Validates via validator function
func (opts *ListOpts) Delete(key string) error
func (opts *ListOpts) Type() string            // Returns "list"

// Retrieval methods
func (opts *ListOpts) GetSlice() []string      // Returns []string
func (opts *ListOpts) GetMap() map[string]struct{} // For deduplication
func (opts *ListOpts) GetAllOrEmpty() []string // Safe retrieval

// Composition
func (opts *ListOpts) WithValidator(validator ValidatorFctType) *ListOpts
```

### Validator Pattern

```go
type ValidatorFctType func(string) (string, error)

// Built-in validators
var (
    ValidateIPAddress  ValidatorFctType  // Checks valid IPv4/IPv6
    ValidateMACAddress ValidatorFctType  // Checks valid MAC
    ValidateDNSSearch  ValidatorFctType  // Checks DNS search domain
    ValidateLabel      ValidatorFctType  // Checks KEY=value format
    ValidateSysctl     ValidatorFctType  // Checks sysctl key=value
    ValidateLink       ValidatorFctType  // Checks container link syntax
)

// Custom validators
func validateAttach(val string) (string, error) {
    s := strings.ToLower(val)
    switch s {
    case "stdin", "stdout", "stderr":
        return s, nil
    default:
        return "", fmt.Errorf("valid streams are STDIN, STDOUT and STDERR")
    }
}
```

---

## Command Integration Pattern

### How run.go Uses the Pattern

**File**: `cli/command/container/run.go`

```go
// 1. Command-specific options embed shared options
type runOptions struct {
    createOptions          // Embedded struct with container options
    detach     bool        // Run-specific: detach mode
    sigProxy   bool        // Run-specific: signal proxying
    detachKeys string      // Run-specific: detach key sequence
}

// 2. Command construction with flag registration
func newRunCommand(dockerCLI command.Cli) *cobra.Command {
    var options runOptions
    var copts *containerOptions  // Will hold shared container options

    cmd := &cobra.Command{
        Use:   "run [OPTIONS] IMAGE [COMMAND] [ARG...]",
        Short: "Run a command in a new container",
        RunE: func(cmd *cobra.Command, args []string) error {
            // Parse positional args
            if len(args) < 1 {
                return errors.New("image is required")
            }
            copts.Image = args[0]
            if len(args) > 1 {
                copts.Args = args[1:]
            }
            return runRun(cmd.Context(), dockerCLI, cmd.Flags(),
                          &options, copts)
        },
    }

    flags := cmd.Flags()

    // 3. Register run-specific flags first
    flags.BoolVarP(&options.detach, "detach", "d", false,
        "Run container in background and print container ID")
    flags.BoolVar(&options.sigProxy, "sig-proxy", true,
        "Proxy received signals to the process")
    flags.StringVar(&options.detachKeys, "detach-keys", "",
        "Override the key sequence for detaching a container")

    // 4. Register ALL shared container flags via addFlags
    copts = addFlags(flags)

    return cmd
}

// 5. Command execution with conversion
func runRun(ctx context.Context, dockerCLI command.Cli,
    flags *pflag.FlagSet, options *runOptions,
    copts *containerOptions) error {

    // Get server OS for platform-specific validation
    serverInfo, _ := dockerCLI.Client().Info(ctx)

    // Convert options to API types using parse()
    containerCfg, err := parse(flags, copts, serverInfo.OSType)
    if err != nil {
        return err
    }

    // Create container with API structures
    response, err := dockerCLI.Client().ContainerCreate(ctx,
        containerCfg.Config,
        containerCfg.HostConfig,
        containerCfg.NetworkingConfig,
        nil,
        options.name,
    )
    if err != nil {
        return err
    }

    // Proceed with container startup...
    return attachContainer(ctx, dockerCLI, options, containerCfg.Config.Image)
}
```

### How create.go Uses the Pattern

**File**: `cli/command/container/create.go`

```go
type createOptions struct {
    name          string  // Create-specific: container name
    platform      string  // Create-specific: platform
    pull          string  // Create-specific: pull image
    quiet         bool    // Create-specific: quiet mode
    useAPISocket  bool    // Create-specific: use API socket
}

func newCreateCommand(dockerCLI command.Cli) *cobra.Command {
    var options createOptions
    var copts *containerOptions

    cmd := &cobra.Command{
        Use:   "create [OPTIONS] IMAGE [COMMAND] [ARG...]",
        Short: "Create a new container",
        RunE: func(cmd *cobra.Command, args []string) error {
            copts.Image = args[0]
            if len(args) > 1 {
                copts.Args = args[1:]
            }
            return runCreate(cmd.Context(), dockerCLI,
                           cmd.Flags(), &options, copts)
        },
    }

    flags := cmd.Flags()

    // Create-specific flags
    flags.StringVar(&options.name, "name", "",
        "Assign a name to the container")
    flags.StringVar(&options.platform, "platform", "",
        "Set platform if server is multi-platform capable")

    // Register shared container options
    copts = addFlags(flags)

    return cmd
}
```

### Pattern Comparison

| Aspect | run.go | create.go |
|--------|--------|-----------|
| Embedded struct | `runOptions{createOptions}` | Direct struct |
| Command-specific flags | detach, sigProxy, detachKeys | name, platform, pull |
| Shared flags | Via `addFlags()` | Via `addFlags()` |
| Conversion | `parse(flags, copts, os)` | `parse(flags, copts, os)` |
| Container creation | ContainerCreate() | ContainerCreate() |
| Post-creation | AttachContainer() | Output container ID |

---

## Test Organization

### Test File Structure

**Location**: `cli/command/container/opts_test.go`

Tests cover:
1. **Flag parsing**: Ensures flags are correctly parsed into containerOptions
2. **Type conversion**: Validates custom types work correctly
3. **Validation**: Tests validator functions reject invalid input
4. **API conversion**: Tests parse() produces correct API structures
5. **Edge cases**: Memory limits, CPU values, platform-specific options

### Command Tests

**Pattern**: `cli/command/container/*_test.go` (25+ test files)

Example pattern in `run_test.go`:
```go
func TestRunValidateFlags(t *testing.T) {
    testCases := []struct {
        name          string
        flags         []string
        expectedErr   string
        expectedValid bool
    }{
        {
            name:          "valid memory",
            flags:         []string{"--memory", "512m"},
            expectedValid: true,
        },
        {
            name:        "invalid memory",
            flags:       []string{"--memory", "invalid"},
            expectedErr: "invalid memory",
        },
        // ... more test cases
    }

    for _, tc := range testCases {
        t.Run(tc.name, func(t *testing.T) {
            fakeCLI := test.NewFakeCli(&fakeClient{})
            cmd := newRunCommand(fakeCLI)
            cmd.SetArgs(tc.flags)

            err := cmd.Execute()
            if tc.expectedErr != "" {
                assert.ErrorContains(t, err, tc.expectedErr)
            } else {
                assert.NilError(t, err)
            }
        })
    }
}
```

### Fake Client Pattern

**File**: `cli/command/container/client_test.go`

```go
type fakeClient struct {
    createContainerFunc func(opts types.ContainerCreateConfig) (types.ContainerCreateResponse, error)
    containerInspectFunc func(ctx context.Context, containerID string) (types.ContainerJSON, error)
    // ... 20+ more methods
}

// Tests use this pattern:
fakeCLI := test.NewFakeCli(&fakeClient{
    createContainerFunc: func(opts types.ContainerCreateConfig) (types.ContainerCreateResponse, error) {
        return types.ContainerCreateResponse{ID: "test-id"}, nil
    },
})
```

---

## Related Packages & Integration Points

### 1. Internal Commands Registry

**Location**: `internal/commands/`
**Purpose**: Command registration system

```go
// Commands register themselves via init()
func init() {
    commands.Register(newRunCommand)
    commands.RegisterLegacy(newAttachCommand)  // Hidden by default
}
```

### 2. CLI Flags Package

**Location**: `cli/flags/`
**Purpose**: Global CLI-level flags (host, TLS, etc.)

Uses **same pflag approach** but for daemon connection flags rather than container options.

### 3. CLI Configuration

**Location**: `cli/config/`
**Purpose**: Handles ~/.docker/config.json

Integration: Reads config for auth, context, etc. before creating containers.

### 4. CLI Streams

**Location**: `cli/streams/`
**Purpose**: Input/output stream handling

Integration: Works with containerOptions stdin/tty settings for interactive containers.

### 5. CLI Context

**Location**: `cli/context/`
**Purpose**: Docker context management

Integration: Determines target daemon (local, remote, etc.) for container operations.

### 6. Plugin System

**Location**: `cli-plugins/manager/`
**Purpose**: Discovers and loads external plugins

Integration: Plugins can extend container commands with custom options.

### 7. Moby API Types

**Location**: `vendor/github.com/moby/moby/api/types/`
**Purpose**: Moby daemon API structures

Integration: `parse()` converts containerOptions to these types for API calls.

---

## Key Design Patterns & Principles

### 1. Three-Layer Transformation Pattern

```
Raw String Flags
    â†“ (pflag + custom types)
    Validation happens here (Set() methods)
containerOptions
    â†“ (parse function)
    Validation happens here (cross-field, server-dependent)
containerConfig (with Config, HostConfig, NetworkingConfig)
    â†“ (API call)
Moby daemon API
```

### 2. Validator Injection Pattern

```go
// Validators are injected at construction
attach: opts.NewListOpts(validateAttach)
dns:    opts.NewListOpts(opts.ValidateIPAddress)

// Each call to Set() runs the validator
func (opts *ListOpts) Set(value string) error {
    v, err := opts.validator(value)  // Run injected validator
    if err != nil {
        return err
    }
    *opts.values = append(*opts.values, v)
    return nil
}
```

### 3. Flag Annotation Pattern

```go
// API Version
flags.SetAnnotation("gpus", "version", []string{"1.40"})

// OS Type
flags.SetAnnotation("cpu-count", "ostype", []string{"windows"})

// These are checked by the CLI framework at runtime
```

### 4. Conditional Field Handling

```go
// Some fields are only set if explicitly specified
if flags.Changed("init") {
    hostConfig.Init = &copts.init
}

// This allows distinguishing explicit False from unspecified
```

### 5. Composition over Inheritance

```go
// run.go embeds createOptions
type runOptions struct {
    createOptions          // Embedding, not inheritance
    detach     bool
    sigProxy   bool
}

// Both commands can use same addFlags() without duplication
```

### 6. pflag.Value Interface Pattern

```go
// All custom types implement this interface
type Value interface {
    String() string
    Set(string) error
    Type() string
}

// This allows pflag to work with any type
flags.Var(&copts.memory, "memory", "Memory limit")
flags.Var(&copts.cpus, "cpus", "CPU limit")
```

---

## Architecture Strengths

### 1. **Elimination of Duplication**
- 98 container flags defined once in containerOptions
- Shared across run, create, and other commands
- Validation logic centralized

### 2. **Type Safety**
- Custom types prevent invalid values at parse time
- Compiler catches type mismatches
- No string-based configuration

### 3. **Extensibility**
- Add new flag: struct field + addFlags() entry + parse() conversion
- No existing code modification needed
- New commands can reuse all flags immediately

### 4. **Testability**
- Validators are pure functions
- parse() is a pure function (given flags & options, returns config)
- Fake clients enable comprehensive testing
- Each layer can be tested independently

### 5. **API Versioning**
- Flags automatically validated against server API version
- Graceful degradation for older daemons
- Version annotations guide CLI framework

### 6. **Platform Compatibility**
- OS-type annotations enable platform-specific validation
- Same codebase handles Windows, Linux, macOS
- Conditional logic in parse() handles differences

### 7. **User Experience**
- Helpful error messages from validators
- Consistent help text across commands
- Deprecated flags continue working with warnings

---

## Complexity Metrics

| Metric | Value | Assessment |
|--------|-------|------------|
| **containerOptions fields** | 88 | Large but manageable |
| **addFlags() registrations** | ~100+ | Well-organized, clear purpose for each |
| **parse() conversion logic** | ~400 lines | Could be refactored into smaller functions |
| **opts/ package files** | 20+ | Appropriate granularity |
| **Test coverage** | Comprehensive | Good unit + integration tests |
| **Lines per file** | 1,155 (opts.go) | Large but single-purpose |

---

## File Reference Map

### Core Pattern Files

| File | Lines | Purpose | Key Symbols |
|------|-------|---------|------------|
| `cli/command/container/opts.go` | 1,155 | Pattern implementation | containerOptions, addFlags, parse, containerConfig |
| `cli/command/container/opts_test.go` | 400+ | Unit tests | TestParseOptions, TestParseVolume, etc. |
| `opts/opts.go` | 300+ | Core types | ListOpts, MapOpts, MemBytes, NanoCPUs |
| `opts/mount.go` | 200+ | Mount parsing | MountOpt |
| `opts/network.go` | 150+ | Network parsing | NetworkOpt |
| `opts/ulimit.go` | 150+ | Ulimit parsing | UlimitOpt |

### Command Integration Files

| File | Lines | Purpose | Pattern Usage |
|------|-------|---------|----------------|
| `cli/command/container/run.go` | 150+ | docker run | Embeds createOptions, uses addFlags/parse |
| `cli/command/container/create.go` | 150+ | docker create | Uses addFlags/parse directly |
| `cli/command/container/exec.go` | 100+ | docker exec | Limited subset of options |
| `cli/command/container/cmd.go` | 50+ | Command registration | Registers all subcommands |

### Support Files

| File | Purpose | Integration |
|------|---------|------------|
| `cli/flags/options.go` | Global CLI flags | Connection flags (host, TLS) |
| `cli/command/cli.go` | CLI interface | Provides client to commands |
| `internal/commands/commands.go` | Registration system | Commands call Register() in init() |
| `internal/test/test.go` | Test utilities | FakeCli for testing |

---

## Code Metrics Summary

```
Total Lines of Code (core pattern):    ~1,500
  - opts.go:                            1,155
  - opts_test.go:                       ~300
  - container command files:            ~3,000+

Total Files (container commands):      ~75
  - Core pattern files:                 2
  - Command implementations:            45+
  - Test files:                         25+

Custom Option Types:                   ~8
  - Built-in validators:               ~15
  - Helper parsing functions:           ~20

Architectural Layers:                  3
  1. Storage (containerOptions)
  2. Registration (addFlags)
  3. Conversion (parse)
```

---

## Lessons for Adaptation

### âœ“ What to Replicate

1. **Three-layer approach**: Storage â†’ Registration â†’ Conversion
2. **pflag.Value interface**: Custom types for validation
3. **Validator injection**: Functions passed to option constructors
4. **Flag annotations**: Version and platform metadata
5. **Composition pattern**: Embed shared options in command-specific structs
6. **Comprehensive tests**: Unit tests for each layer
7. **Helper functions**: parseNetworkOpts, parseSecurityOpts, etc.

### âš  Watch For

1. **opts.go scale**: Single 1,155-line file might be refactored into:
   - containerOptions (struct definition)
   - addFlags (flag registration)
   - parse (conversion logic)
   - helpers (validation and helper functions)

2. **Cross-field validation**: Takes significant code in parse()

3. **Server-dependent behavior**: serverOS parameter affects validation

4. **Lazy client initialization**: Docker CLI doesn't initialize client until needed

5. **Flag aliases**: Maintaining backward compatibility adds complexity

### ðŸŽ¯ Adaptation Priorities

For teams building similar tools:

1. **Phase 1**: Implement pflag.Value types (ListOpts, MapOpts, MemBytes-like)
2. **Phase 2**: Create options struct with all fields
3. **Phase 3**: Build addFlags function with validators
4. **Phase 4**: Implement parse() function for conversion
5. **Phase 5**: Create test suite with fake client
6. **Phase 6**: Integrate into first command (run/create equivalent)

---

## Summary

The Docker CLI's container options pattern is a **battle-tested solution** for managing complex, shared CLI flag requirements. By using:

- **Custom types** implementing `pflag.Value`
- **Centralized options struct** for storage
- **Dedicated registration function** for flags
- **Conversion function** for API compatibility
- **Comprehensive validation** at multiple layers

The codebase achieves:

âœ“ **DRY principle**: 98 flags defined once, shared across commands
âœ“ **Type safety**: Compiler catches errors, not users
âœ“ **Maintainability**: Changes in one place affect all commands
âœ“ **Extensibility**: New commands reuse all existing flags
âœ“ **Testability**: Pure functions, fake clients, comprehensive tests
âœ“ **User experience**: Helpful errors, version compatibility, platform support

This architecture can be adapted to any CLI tool with rich flag requirements, from container orchestrators to infrastructure-as-code tools.
