# Product Requirements: Container Options DRY Pattern

> Generated by product-analyst for docker/docker-cli
> Focus: Shared flags pattern for container-related commands

---

## Product Overview

**Product Name:** Container Options DRY Pattern (Shared Flag Architecture)
**Product Type:** Reusable CLI Architecture Pattern / Library
**Primary Purpose:** Enable multiple CLI commands to share a common set of flags while maintaining type safety, validation, and clean API conversion.

**Target Users:**
- **CLI Developers**: Engineers building docker-like CLIs who need to share flags across multiple commands (e.g., `run`, `create`, `exec`)
- **CLI Maintainers**: Engineers extending existing CLIs with new flags or commands while ensuring consistency
- **Platform Teams**: Teams building internal tools that manage containers, VMs, or similar resources with complex configuration surfaces

---

## Executive Summary

The Container Options DRY Pattern solves a fundamental problem in CLI development: **how to share complex flag configurations across multiple commands without duplication**. Docker CLI uses this pattern to manage **98+ flags** that are shared between `docker run`, `docker create`, and other container commands.

The pattern consists of three layers:
1. **Storage Layer**: An intermediate struct (`containerOptions`) holding all parsed flag values
2. **Registration Layer**: A single function (`addFlags()`) that wires all flags to the storage struct
3. **Conversion Layer**: A transformation function (`parse()`) that converts intermediate values to API-ready types

This architecture eliminates duplication, ensures validation consistency, provides a single source of truth for flag definitions, and cleanly separates CLI concerns from API concerns.

---

## Core Features

### Feature 1: Centralized Flag Definition

**Description:** All shared flags are defined in one place, eliminating duplication across commands. Commands inherit the complete flag set through a single function call.

**User Stories:**

#### US-1.1: Share Flags Across Commands
> As a CLI developer, I want to define flags once and share them across multiple commands so that I maintain consistency and reduce maintenance burden.

**Acceptance Criteria:**
- [ ] Given two or more commands that need the same flags, when I call the shared flag registration function in each command, then both commands have identical flag definitions
- [ ] Given a shared flag registration, when I add a new flag to the registration function, then all commands automatically gain access to that flag
- [ ] Given a flag with help text, when the user runs `--help` on any sharing command, then the help text is identical across commands
- [ ] Edge case: Adding a command-specific flag to one command does not affect other commands sharing the base flags

#### US-1.2: Single Source of Truth for Flag Metadata
> As a CLI maintainer, I want all flag metadata (names, shorthand, help text, defaults) defined in one location so that updates propagate consistently.

**Acceptance Criteria:**
- [ ] Given a flag's help text, when I modify it in the registration function, then all commands using that flag display the updated help text
- [ ] Given a flag's default value, when I change it in the registration function, then all commands apply the new default
- [ ] Given a flag with a shorthand (e.g., `-e` for `--env`), when defined in registration, then all sharing commands recognize both forms

---

### Feature 2: Type-Safe Custom Option Types

**Description:** Custom types that implement the flag parsing interface provide type-safe parsing, validation, and value retrieval for complex flag values.

**User Stories:**

#### US-2.1: Parse Repeatable Flags
> As a CLI developer, I want to support flags that can be specified multiple times so that users can provide lists of values (e.g., multiple environment variables).

**Acceptance Criteria:**
- [ ] Given a repeatable flag type (ListOpts), when the user specifies `-e VAR1=val1 -e VAR2=val2`, then both values are stored in order
- [ ] Given a repeatable flag, when retrieved, then I receive all values as a slice
- [ ] Given a repeatable flag with no values provided, when retrieved, then I receive an empty slice (not nil)
- [ ] Edge case: Duplicate values in repeatable flags are preserved unless explicitly deduplicated

#### US-2.2: Parse Key-Value Pair Flags
> As a CLI developer, I want to support key-value pair flags so that users can provide map-like configurations (e.g., sysctls, labels).

**Acceptance Criteria:**
- [ ] Given a map option type (MapOpts), when the user specifies `--sysctl net.ipv4.forward=1`, then the key-value pair is stored correctly
- [ ] Given multiple key-value pairs with the same key, when retrieved, then the last value wins
- [ ] Given an invalid key-value format (missing `=`), when parsed, then an error is returned immediately
- [ ] Edge case: Values containing `=` (e.g., `key=val=ue`) preserve everything after the first `=` as the value

#### US-2.3: Parse Human-Readable Units
> As a CLI developer, I want to support human-readable units (e.g., memory, CPU) so that users can specify values naturally.

**Acceptance Criteria:**
- [ ] Given a memory flag (MemBytes), when the user specifies `--memory 512m`, then it parses to 536870912 bytes
- [ ] Given a memory flag, when the user specifies `--memory 1g`, then it parses to 1073741824 bytes
- [ ] Given a CPU flag (NanoCPUs), when the user specifies `--cpus 1.5`, then it parses to 1500000000 nanoseconds
- [ ] Given an invalid unit format, when parsed, then a clear error message is returned
- [ ] Edge case: Zero values are valid and distinct from unset values

#### US-2.4: Parse Complex Structured Flags
> As a CLI developer, I want to support complex structured flags so that users can specify multi-field configurations inline.

**Acceptance Criteria:**
- [ ] Given a mount option type, when the user specifies `--mount type=bind,src=/host,dst=/cnt,readonly`, then all fields are parsed correctly
- [ ] Given a network option type, when the user specifies `--network name=mynet,ip=10.0.0.5,alias=web`, then all fields are parsed correctly
- [ ] Given missing required fields in a complex flag, when parsed, then a specific error identifies the missing field
- [ ] Edge case: Fields can appear in any order within the flag value

---

### Feature 3: Validation at Parse Time

**Description:** Validation logic is injected into option types at construction time, providing immediate feedback during flag parsing rather than deferred errors.

**User Stories:**

#### US-3.1: Inject Validators at Construction
> As a CLI developer, I want to inject validation functions into option types so that invalid values are rejected immediately during parsing.

**Acceptance Criteria:**
- [ ] Given a ListOpts with an IP address validator, when the user provides an invalid IP, then an error is returned during flag parsing
- [ ] Given a ListOpts with a validator that normalizes values, when retrieval happens, then normalized values are stored
- [ ] Given a ListOpts with no validator (nil), when any string is provided, then it is accepted without modification
- [ ] Edge case: Validator errors include the invalid value in the error message for user clarity

#### US-3.2: Cross-Field Validation
> As a CLI developer, I want to validate combinations of flags so that mutually exclusive or dependent flags are checked.

**Acceptance Criteria:**
- [ ] Given `--rm` and `--restart=always` flags, when both are specified, then an error indicates they are mutually exclusive
- [ ] Given `--no-healthcheck` and `--health-cmd` flags, when both are specified, then an error indicates the conflict
- [ ] Given platform-dependent validation (e.g., Linux device paths), when server OS differs, then appropriate validation is applied
- [ ] Edge case: Cross-validation happens after all flags are parsed, not during individual flag parsing

---

### Feature 4: API Version and Platform Annotations

**Description:** Flags can be annotated with API version requirements and platform constraints, enabling automatic compatibility checks.

**User Stories:**

#### US-4.1: Annotate Flags with API Version Requirements
> As a CLI developer, I want to mark flags with minimum API versions so that incompatible flags are handled gracefully with older servers.

**Acceptance Criteria:**
- [ ] Given a flag annotated with version `1.40`, when connecting to a server with API `1.39`, then the CLI framework prevents use or warns appropriately
- [ ] Given a flag annotated with version `1.41`, when connecting to a server with API `1.44`, then the flag works normally
- [ ] Given version annotations, when flags are introspected, then version requirements are accessible programmatically
- [ ] Edge case: Flags without version annotations work with all API versions

#### US-4.2: Annotate Flags with Platform Constraints
> As a CLI developer, I want to mark flags as platform-specific so that Windows-only or Linux-only flags are appropriately handled.

**Acceptance Criteria:**
- [ ] Given a flag annotated as Windows-only, when running against a Linux server, then the flag is hidden or produces an appropriate error
- [ ] Given a platform annotation, when displaying help on a non-matching platform, then the flag may be hidden from help output
- [ ] Given no platform annotation, when any server is connected, then the flag is available
- [ ] Edge case: Platform checks can be deferred until execution if server OS is unknown at flag registration

---

### Feature 5: Backward Compatibility Support

**Description:** The pattern supports flag aliases and deprecation markers to maintain CLI stability while evolving.

**User Stories:**

#### US-5.1: Support Flag Aliases
> As a CLI developer, I want to support multiple names for the same flag so that legacy flag names continue working while newer names are preferred.

**Acceptance Criteria:**
- [ ] Given both `--net` and `--network` pointing to the same variable, when either is used, then the same value is set
- [ ] Given a flag alias marked as hidden, when `--help` is shown, then only the preferred name appears
- [ ] Given both alias and preferred name used together, when parsed, then the last value wins (or an error if configured)
- [ ] Edge case: Flag completions should prefer the non-hidden name

#### US-5.2: Mark Flags as Deprecated
> As a CLI developer, I want to mark flags as deprecated so that users receive warnings while their scripts continue working.

**Acceptance Criteria:**
- [ ] Given a deprecated flag, when used, then a warning is printed to stderr
- [ ] Given a deprecated flag with a reason, when used, then the warning includes the deprecation reason
- [ ] Given a deprecated flag, when `--help` is shown, then it may be hidden or marked as deprecated
- [ ] Edge case: Deprecated flags still function correctly; they just produce warnings

---

### Feature 6: Clean Conversion to API Types

**Description:** A conversion function transforms the intermediate storage struct into API-ready structures, cleanly separating CLI parsing from API concerns.

**User Stories:**

#### US-6.1: Convert Options to API Structures
> As a CLI developer, I want a single function that converts parsed flags to API types so that commands don't duplicate conversion logic.

**Acceptance Criteria:**
- [ ] Given a populated containerOptions struct, when `parse()` is called, then API-ready Config, HostConfig, and NetworkingConfig are returned
- [ ] Given custom option types (ListOpts, MemBytes), when converted, then appropriate API types are used ([]string, int64)
- [ ] Given validation errors during conversion, when detected, then a clear error is returned before API calls
- [ ] Edge case: Conversion handles nil/empty values gracefully

#### US-6.2: Detect Explicit vs Default Values
> As a CLI developer, I want to distinguish between flags explicitly set by users and default values so that optional API fields are handled correctly.

**Acceptance Criteria:**
- [ ] Given a boolean flag not specified by the user, when checked with `flags.Changed()`, then it returns false
- [ ] Given a boolean flag explicitly set to its default value, when checked with `flags.Changed()`, then it returns true
- [ ] Given an optional API field that should be nil when not set, when the flag was not changed, then nil is passed to the API
- [ ] Edge case: This enables three-state booleans (true, false, unset) for API fields

---

## Supporting Features

### Command-Specific Flag Extension

Commands can add their own flags alongside shared flags without modifying the shared definition.

- Commands embed or compose with command-specific options structs
- Command-specific flags are registered separately from shared flags
- Both shared and command-specific flags are available during execution

### Test Infrastructure

The pattern includes established test patterns and helpers for verifying flag parsing.

- `setupRunFlags()` helper creates isolated flag sets for testing
- `parseRun()` helper exercises the complete parsing pipeline
- Table-driven tests cover all flag variations
- FakeCli pattern enables command-level integration testing

---

## Non-Functional Requirements

### Maintainability

| Metric | Requirement | Notes |
|--------|-------------|-------|
| Single definition location | All shared flags defined in one file | Enables grep-ability and audit |
| Change propagation | Flag changes require updates in 1-3 locations max | Storage struct, registration, conversion |
| Documentation colocation | Help text defined at flag registration | No separate documentation to synchronize |

**Requirements:**
- Adding a new flag should require changes to at most 3 code locations: struct field, flag registration, parse handling
- Modifying flag help text should require exactly 1 code change
- Flag deprecation should not require changes to existing command code

### Extensibility

| Metric | Requirement | Notes |
|--------|-------------|-------|
| New command integration | Single function call to inherit all shared flags | Via `addFlags(flags)` |
| New flag type creation | Implement 3-method interface | pflag.Value interface |
| New validator creation | Single function signature | `func(string) (string, error)` |

**Requirements:**
- A new command sharing existing flags should require only calling `addFlags()` in its constructor
- A new custom option type should require implementing only the pflag.Value interface (3 methods)
- A new validator should be a pure function taking a string and returning validated string or error

### Testability

| Metric | Requirement | Notes |
|--------|-------------|-------|
| Unit test isolation | Flags testable without command execution | Via `setupRunFlags()` pattern |
| Parse function purity | `parse()` should be a pure function | Given inputs, deterministic outputs |
| Validator independence | Validators testable in isolation | No external dependencies |

**Requirements:**
- The `parse()` function should be testable as a pure function given flags, options, and server OS
- Each custom option type should be independently unit testable
- Each validator function should be testable without instantiating the full CLI
- Test coverage should include: valid inputs, invalid inputs, edge cases, cross-field conflicts

### Performance

| Metric | Requirement | Notes |
|--------|-------------|-------|
| Flag parsing | O(n) where n = number of flags | Linear with flag count |
| Memory allocation | Single allocation for options struct | No per-flag allocations during setup |
| Validator execution | During `Set()` call only | No re-validation during retrieval |

**Requirements:**
- Flag registration should complete in constant time per flag
- Flag parsing should complete in linear time with number of flags provided
- Validation should happen exactly once per flag value (during parsing, not during conversion)

### Scalability

| Metric | Requirement | Notes |
|--------|-------------|-------|
| Flag count | Pattern should scale to 100+ flags | Docker CLI has 98+ |
| Command count | Pattern should support 10+ sharing commands | No per-command duplication |
| Validator count | Validators should be independently deployable | No monolithic validator registry |

**Requirements:**
- The pattern should support at least 100 shared flags without architectural changes
- The pattern should support at least 10 commands sharing the same flag set
- Adding flags should have no impact on existing flag processing performance

---

## Assumptions

Things assumed to be true for this specification:

1. **pflag/cobra availability**: The CLI uses spf13/pflag and spf13/cobra or compatible flag parsing libraries
2. **Go language**: The implementation language is Go; some patterns (interface-based polymorphism) are language-specific
3. **Backend API stability**: The API types that flags convert to have reasonably stable schemas
4. **Single server target**: Flag parsing targets a single server at a time (server OS is known at conversion time)
5. **CLI execution model**: Commands execute synchronously; flag parsing completes before command logic runs

---

## Constraints

Limitations that affect the product:

1. **Language binding**: The pattern as implemented is Go-specific; other languages would need equivalent interface mechanisms
2. **pflag dependency**: Custom option types must implement pflag.Value interface; changing flag libraries requires adapter layer
3. **Flat structure**: The pattern uses a flat options struct (98 fields); grouping into sub-structs would require refactoring
4. **Synchronous validation**: Validators run synchronously during parsing; async validation is not supported
5. **String-based parsing**: All flag values enter as strings; binary or structured input formats are not supported

---

## Out of Scope

Explicitly not included in this specification:

1. **Command execution logic**: What commands do after parsing is outside this pattern's scope
2. **API client implementation**: How parsed configs are sent to backends is not covered
3. **Configuration file support**: Loading flags from config files is a separate concern
4. **Interactive prompts**: The pattern handles command-line flags only, not interactive input
5. **Flag auto-generation**: Generating flags from API schemas is not part of this pattern
6. **i18n/l10n**: Internationalization of help text is not addressed
7. **GUI integration**: The pattern is CLI-specific; GUI bindings would need separate design

---

## Dependencies

External systems or conditions required:

1. **spf13/pflag**: Flag parsing library providing the Value interface and FlagSet type
2. **spf13/cobra**: Command framework for command registration and routing (optional but typical)
3. **Backend API types**: Container, HostConfig, NetworkingConfig types that flags map to
4. **Go standard library**: `net`, `strings`, `fmt` for validation and parsing utilities
5. **gotest.tools/v3**: Testing utilities (assert, is) for test implementation

---

## Glossary

| Term | Definition |
|------|------------|
| **containerOptions** | Intermediate storage struct holding all parsed flag values before API conversion |
| **addFlags()** | Function that registers all shared flags with a FlagSet and returns initialized containerOptions |
| **parse()** | Function that converts containerOptions to API-ready structures with validation |
| **ListOpts** | Custom option type for repeatable flags that stores multiple string values |
| **MapOpts** | Custom option type for key-value pair flags that stores a string map |
| **MemBytes** | Custom option type that parses human-readable memory values (e.g., "1g") to bytes |
| **NanoCPUs** | Custom option type that parses CPU fractions (e.g., "1.5") to nanoseconds |
| **pflag.Value** | Interface requiring String(), Set(string) error, and Type() string methods |
| **ValidatorFctType** | Function signature `func(string) (string, error)` for value validation |
| **Flag annotation** | Metadata attached to flags for version requirements or platform constraints |
| **FlagSet** | Collection of flag definitions associated with a command |

---

## Feature Priority Matrix

| Feature | Priority | Complexity | Notes |
|---------|----------|------------|-------|
| Centralized Flag Definition | Must Have | Medium | Core value proposition of the pattern |
| Type-Safe Custom Option Types | Must Have | High | Enables complex flag values with validation |
| Validation at Parse Time | Must Have | Medium | Critical for user experience |
| Clean Conversion to API Types | Must Have | High | Required for backend integration |
| API Version Annotations | Should Have | Low | Important for evolving APIs |
| Platform Annotations | Should Have | Low | Important for cross-platform CLIs |
| Flag Aliases | Should Have | Low | Required for backward compatibility |
| Flag Deprecation | Should Have | Low | Required for API evolution |
| Test Infrastructure | Should Have | Medium | Enables confident changes |
| Command-Specific Extension | Nice to Have | Low | Most CLIs need this |

---

## Implementation Checklist

For teams adopting this pattern:

### Phase 1: Foundation

- [ ] Create intermediate options struct with all shared flag fields
- [ ] Create `addFlags(*pflag.FlagSet) *Options` function
- [ ] Register basic flags (strings, bools, ints) with help text
- [ ] Create `parse(*pflag.FlagSet, *Options, serverOS) (*Config, error)` function
- [ ] Write unit tests for basic flag parsing

### Phase 2: Custom Types

- [ ] Create ListOpts type implementing pflag.Value
- [ ] Create MapOpts type implementing pflag.Value
- [ ] Create unit-aware types (MemBytes, NanoCPUs) if needed
- [ ] Create complex structured types (MountOpt, NetworkOpt) if needed
- [ ] Implement validator injection pattern
- [ ] Write unit tests for all custom types

### Phase 3: Validation

- [ ] Implement per-field validators (IP, DNS, label format, etc.)
- [ ] Add cross-field validation in parse() function
- [ ] Add server OS-dependent validation where needed
- [ ] Write tests for all validation scenarios including error cases

### Phase 4: Metadata

- [ ] Add API version annotations to version-gated flags
- [ ] Add platform annotations to OS-specific flags
- [ ] Implement flag aliases for backward compatibility
- [ ] Mark deprecated flags with warnings
- [ ] Document all annotations in code comments

### Phase 5: Integration

- [ ] Integrate `addFlags()` into each sharing command
- [ ] Call `parse()` in command execution
- [ ] Add command-specific flags alongside shared flags
- [ ] Write integration tests using FakeCli pattern
- [ ] Validate end-to-end flag parsing and conversion

---

## Summary

The Container Options DRY Pattern provides a battle-tested architecture for managing complex CLI flag configurations across multiple commands. By separating concerns into storage, registration, and conversion layers, it enables:

- **Single source of truth** for 98+ flags shared across commands
- **Type-safe parsing** via custom option types implementing pflag.Value
- **Immediate validation** through validator injection at construction
- **Clean API separation** with dedicated conversion function
- **Evolution support** via version/platform annotations and deprecation markers

Teams building CLIs with shared flag surfaces should adopt this pattern to reduce duplication, improve consistency, and simplify maintenance. The pattern has been proven at scale in Docker CLI and provides clear extension points for customization.
