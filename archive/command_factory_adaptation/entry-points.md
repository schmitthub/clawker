# Entry Points Analysis

> Generated by entry-point-analyzer for github/cli

## Entry Point Summary

```
Application Type: CLI
Primary Entry: cmd/gh/main.go (main function)
Secondary Entries: pkg/cmd/root/root.go (NewCmdRoot - command tree builder)
Initialization Pattern: Factory pattern with lazy-loaded dependencies
```

## Primary Entry Point

#### cmd/gh/main.go
- **File**: `/Users/andrew/Code/vendor/github/cli/cmd/gh/main.go`
- **Type**: CLI main entry point
- **Invocation**: `go run` or compiled `gh` binary
- **Purpose**: Application bootstrap that delegates to the command system

**Code**:
```go
func main() {
    code := ghcmd.Main()
    os.Exit(int(code))
}
```

This is a minimal entry point that immediately delegates to `ghcmd.Main()` in the internal package and translates the exit code.

## Initialization Sequence

```
1. cmd/gh/main.go:main() (line 9)
   └─ Calls ghcmd.Main()

2. internal/ghcmd/cmd.go:Main() (line 41)
   └─ Creates factory via factory.New(buildVersion)
   └─ Loads config and performs migrations
   └─ Starts background update checker
   └─ Configures terminal colors and survey library
   └─ Creates root command via root.NewCmdRoot()
   └─ Expands CLI args and handles help translation for extensions
   └─ Executes command via rootCmd.ExecuteContextC()
   └─ Handles errors and displays update messages

3. pkg/cmd/factory/default.go:New() (line 28)
   └─ Creates base Factory struct with AppVersion, Config, ExecutableName
   └─ Populates Factory fields in dependency order:
      a. IOStreams (depends on Config)
      b. HttpClient (depends on Config, IOStreams, appVersion)
      c. PlainHttpClient (depends on IOStreams, appVersion)
      d. GitClient (depends on IOStreams, Executable)
      e. Remotes (depends on Config, GitClient)
      f. BaseRepo (depends on Remotes)
      g. Prompter (depends on Config, IOStreams)
      h. Browser (depends on Config, IOStreams)
      i. ExtensionManager (depends on Config, HttpClient, IOStreams)
      j. Branch (depends on GitClient)

4. pkg/cmd/root/root.go:NewCmdRoot() (line 57)
   └─ Creates cobra.Command with metadata and hooks
   └─ Sets PersistentPreRunE for auth checking
   └─ Registers command groups (core, actions, extension)
   └─ Adds all child commands (pr, issue, repo, etc.)
   └─ Creates "repo-resolving" factory variant for smart BaseRepo resolution
   └─ Registers extensions from ExtensionManager
   └─ Registers aliases from config
   └─ Returns configured root command
```

## Request/Command Flow

### CLI Command Flow

```
[User Input] → [Cobra Parsing] → [Command Router] → [Command Handler] → [Output]
                    │              │                   │
                    │              │                   └─ Command-specific RunE
                    │              └─ cobra.Command tree lookup
                    └─ os.Args expansion and preprocessing
```

**Detailed trace:**

1. **Entry**: User invokes `gh pr list --state open`
   - Location: `cmd/gh/main.go:main()` → `ghcmd.Main()`

2. **Preprocessing**: Args expanded and help translated
   - Location: `internal/ghcmd/cmd.go:Main()` (lines 65-72)
   - Handles help command translation for extensions
   - Sets expanded args on root command

3. **Parsing**: Cobra parses command and flags
   - Location: `rootCmd.ExecuteContextC(ctx)` (line 76)
   - Cobra walks command tree to find matching command
   - Parses flags according to command definition

4. **Auth Check**: PersistentPreRunE validates authentication
   - Location: `pkg/cmd/root/root.go:NewCmdRoot()` (lines 79-89)
   - Checks if auth required via `cmdutil.IsAuthCheckEnabled(cmd)`
   - Validates auth via `cmdutil.CheckAuth(cfg)`
   - Returns `AuthError{}` if not authenticated

5. **Routing**: Command tree traversal
   - `rootCmd` (gh) → `prCmd` (pr) → `listCmd` (list)
   - Each level created via `NewCmd*` functions
   - Factory passed down the command chain

6. **Handler**: Command's RunE function executes
   - Location: `pkg/cmd/pr/list/list.go:NewCmdList()` (lines 86-101)
   - RunE validates flags
   - Calls either `runF` (test injection) or `listRun(opts)`

7. **Response**: Output written via IOStreams
   - Location: `pkg/cmd/pr/list/list.go:listRun()` (lines 141-256)
   - Uses `opts.IO` for all output
   - Renders tables, handles paging, exports JSON

## Handler Registration

Commands use a consistent pattern for registration and execution:

### Pattern: NewCmd* Factory Functions

**Location**: Each command in `pkg/cmd/<group>/<command>/`

**Example**: `pkg/cmd/pr/list/list.go:NewCmdList()`

**Signature**:
```go
func NewCmdList(f *cmdutil.Factory, runF func(*ListOptions) error) *cobra.Command
```

**Structure**:

1. **Options Creation** (lines 46-52):
```go
opts := &ListOptions{
    IO:         f.IOStreams,
    HttpClient: f.HttpClient,
    Browser:    f.Browser,
    Now:        time.Now,
}
```

2. **Cobra Command Creation** (lines 56-85):
```go
cmd := &cobra.Command{
    Use:   "list",
    Short: "List pull requests in a repository",
    Long:  `...`,
    Example: `...`,
    Aliases: []string{"ls"},
    Args:    cmdutil.NoArgsQuoteReminder,
    RunE: func(cmd *cobra.Command, args []string) error {
        // Runtime setup
        opts.BaseRepo = f.BaseRepo

        // Validation
        if opts.LimitResults < 1 {
            return cmdutil.FlagErrorf("...")
        }

        // Execution
        if runF != nil {
            return runF(opts)  // Test injection
        }
        return listRun(opts)   // Production
    },
}
```

3. **Flag Registration** (lines 104-115):
```go
cmd.Flags().BoolVarP(&opts.WebMode, "web", "w", false, "...")
cmd.Flags().IntVarP(&opts.LimitResults, "limit", "L", 30, "...")
cmdutil.StringEnumFlag(cmd, &opts.State, "state", "s", "open", ...)
```

4. **Command Return** (line 119):
```go
return cmd
```

### Handler Execution Bridge

The `RunE` function serves as the bridge between Cobra's execution model and the command's business logic:

**Bridge Responsibilities**:
1. **Late Binding**: Assigns factory functions at runtime (e.g., `opts.BaseRepo = f.BaseRepo`)
2. **Validation**: Checks flag combinations and values
3. **Test Injection**: Allows `runF` override for testing
4. **Delegation**: Calls the actual run function (`listRun(opts)`)

**Why Late Binding?**
- `BaseRepo` resolution depends on runtime context (current directory, -R flag, etc.)
- Factory functions are lazy-evaluated to avoid unnecessary work
- Allows factory to be modified before command execution (e.g., `SmartBaseRepoFunc`)

## Extension Points

| Extension Type | Location | Purpose |
|---------------|----------|---------|
| **Command Registration** | `pkg/cmd/root/root.go:NewCmdRoot()` lines 90-128 | Add new commands via `cmd.AddCommand()` |
| **Factory Dependencies** | `pkg/cmd/factory/default.go:New()` lines 28-47 | Add new factory dependencies |
| **Command Groups** | `pkg/cmd/<group>/<group>.go` | Create command hierarchies with subcommands |
| **Test Injection** | `NewCmd*` functions | Pass `runF` parameter to override run function |
| **Lazy Evaluation** | Factory function fields | Defer expensive operations until needed |
| **Smart Resolvers** | `pkg/cmd/factory/default.go:SmartBaseRepoFunc()` | Custom resolution logic for BaseRepo |
| **Extensions** | `pkg/cmd/root/root.go` lines 155-165 | External commands registered dynamically |
| **Aliases** | `pkg/cmd/root/root.go` lines 168-197 | User-defined command shortcuts |

## Factory Pattern Deep Dive

### Factory Structure

The `cmdutil.Factory` struct (defined in `pkg/cmdutil/factory.go:18-37`) contains:

**Immediate Values**:
- `AppVersion string` - Application version string
- `ExecutableName string` - Name of the executable ("gh")
- `Browser browser.Browser` - Browser opener
- `ExtensionManager extensions.ExtensionManager` - Extension system
- `GitClient *git.Client` - Git operations
- `IOStreams *iostreams.IOStreams` - I/O streams
- `Prompter prompter.Prompter` - User prompting

**Lazy Functions** (evaluated on demand):
- `BaseRepo func() (ghrepo.Interface, error)` - Repository resolver
- `Branch func() (string, error)` - Current branch getter
- `Config func() (gh.Config, error)` - Config loader
- `HttpClient func() (*http.Client, error)` - Authenticated HTTP client
- `PlainHttpClient func() (*http.Client, error)` - Unauthenticated HTTP client
- `Remotes func() (context.Remotes, error)` - Git remotes resolver

### Factory Construction

The `factory.New()` function constructs the factory in a specific dependency order:

```go
func New(appVersion string) *cmdutil.Factory {
    f := &cmdutil.Factory{
        AppVersion:     appVersion,
        Config:         configFunc(),        // No dependencies
        ExecutableName: "gh",
    }

    f.IOStreams = ioStreams(f)                             // Depends on Config
    f.HttpClient = httpClientFunc(f, appVersion)           // Depends on Config, IOStreams, appVersion
    f.PlainHttpClient = plainHttpClientFunc(f, appVersion) // Depends on IOStreams, appVersion
    f.GitClient = newGitClient(f)                          // Depends on IOStreams, Executable
    f.Remotes = remotesFunc(f)                             // Depends on Config, GitClient
    f.BaseRepo = BaseRepoFunc(f)                           // Depends on Remotes
    f.Prompter = newPrompter(f)                            // Depends on Config, IOStreams
    f.Browser = newBrowser(f)                              // Depends on Config, IOStreams
    f.ExtensionManager = extensionManager(f)               // Depends on Config, HttpClient, IOStreams
    f.Branch = branchFunc(f)                               // Depends on GitClient

    return f
}
```

### Key Factory Functions

#### 1. BaseRepoFunc - Basic Repository Resolution

**Location**: `pkg/cmd/factory/default.go:74-82`

```go
func BaseRepoFunc(f *cmdutil.Factory) func() (ghrepo.Interface, error) {
    return func() (ghrepo.Interface, error) {
        remotes, err := f.Remotes()
        if err != nil {
            return nil, err
        }
        return remotes[0], nil  // Returns first remote
    }
}
```

Returns the first git remote without intelligent resolution.

#### 2. SmartBaseRepoFunc - Intelligent Repository Resolution

**Location**: `pkg/cmd/factory/default.go:49-72`

This factory variant provides smarter repository resolution:
- Checks for `-R/--repo` flag override first
- Falls back to git remotes
- Used for commands that need flexible repo targeting

**Usage Pattern**:
```go
repoResolvingCmdFactory := *f
repoResolvingCmdFactory.BaseRepo = factory.SmartBaseRepoFunc(f)
cmd.AddCommand(prCmd.NewCmdPR(&repoResolvingCmdFactory))
```

#### 3. httpClientFunc - HTTP Client with Auth

**Location**: `pkg/cmd/factory/default.go:188-208`

```go
func httpClientFunc(f *cmdutil.Factory, appVersion string) func() (*http.Client, error) {
    return func() (*http.Client, error) {
        io := f.IOStreams
        cfg, err := f.Config()
        if err != nil {
            return nil, err
        }
        opts := api.HTTPClientOptions{
            Config:      cfg.Authentication(),
            Log:         io.ErrOut,
            LogColorize: io.ColorEnabled(),
            AppVersion:  appVersion,
        }
        client, err := api.NewHTTPClient(opts)
        if err != nil {
            return nil, err
        }
        client.Transport = api.ExtractHeader("X-GitHub-SSO", &ssoHeader)(client.Transport)
        return client, nil
    }
}
```

Lazy evaluation pattern:
1. Returns a closure that captures the factory
2. Closure executes when `f.HttpClient()` is called
3. Reads config and constructs client on-demand
4. Adds SSO header extraction middleware

#### 4. ioStreams - I/O Configuration

**Location**: `pkg/cmd/factory/default.go:292-349`

Creates IOStreams with environment-based configuration:
- `GH_PROMPT_DISABLED` / config `prompt` - Disables prompting
- `GH_ACCESSIBLE_PROMPTER` / config `accessiblePrompter` - Accessibility mode
- `GH_SPINNER_DISABLED` / config `spinner` - Disables spinners
- `GH_PAGER` / config `pager` / `PAGER` - Pager configuration (precedence order)
- `GH_COLOR_LABELS` / config `colorLabels` - Color label rendering

This function is eagerly evaluated (returns `*iostreams.IOStreams` directly, not a closure).

## Command Execution Flow - Detailed Example

### Example: `gh pr list --state open`

**1. Bootstrap** (`cmd/gh/main.go:9-11`):
```
main() → ghcmd.Main() → os.Exit(exitCode)
```

**2. Factory Creation** (`internal/ghcmd/cmd.go:46`):
```
cmdFactory := factory.New(buildVersion)
```

Factory is now populated with all dependencies.

**3. Root Command Creation** (`internal/ghcmd/cmd.go:54`):
```
rootCmd, err := root.NewCmdRoot(cmdFactory, buildVersion, buildDate)
```

**4. Root Command Setup** (`pkg/cmd/root/root.go:57-239`):

Registers command hierarchy:
```
gh (root)
├── pr (NewCmdPR)
│   ├── list (NewCmdList)
│   ├── create
│   └── ...
├── issue
├── repo
└── ...
```

**5. Command Execution** (`internal/ghcmd/cmd.go:76`):
```
rootCmd.ExecuteContextC(ctx)
```

Cobra parses args: `["pr", "list", "--state", "open"]`

**6. Command Tree Traversal**:
- Finds `pr` subcommand in root
- Finds `list` subcommand in pr
- Matches flags: `--state open`

**7. PersistentPreRunE Hook** (`pkg/cmd/root/root.go:79-89`):
```
if cmdutil.IsAuthCheckEnabled(cmd) && !cmdutil.CheckAuth(cfg) {
    return &AuthError{}
}
```

**8. RunE Execution** (`pkg/cmd/pr/list/list.go:86-101`):

```go
RunE: func(cmd *cobra.Command, args []string) error {
    // Late binding
    opts.BaseRepo = f.BaseRepo

    // Validation
    if opts.LimitResults < 1 {
        return cmdutil.FlagErrorf("invalid value for --limit: %v", opts.LimitResults)
    }

    // Execution
    if runF != nil {
        return runF(opts)
    }
    return listRun(opts)
}
```

**9. listRun Execution** (`pkg/cmd/pr/list/list.go:141-256`):

Key steps:
```go
func listRun(opts *ListOptions) error {
    // 1. Resolve lazy dependencies
    httpClient, err := opts.HttpClient()  // Evaluates factory function
    baseRepo, err := opts.BaseRepo()      // Evaluates factory function

    // 2. Build filter options
    filters := shared.FilterOptions{
        Entity:  "pr",
        State:   prState,
        // ... other filters from opts
    }

    // 3. Web mode: open browser
    if opts.WebMode {
        openURL, err := shared.ListURLWithQuery(prListURL, filters, false)
        return opts.Browser.Browse(openURL)
    }

    // 4. Fetch pull requests
    listResult, err := listPullRequests(httpClient, opts.Detector, baseRepo, filters, opts.LimitResults)

    // 5. Handle output
    if opts.Exporter != nil {
        return opts.Exporter.Write(opts.IO, listResult.PullRequests)
    }

    // 6. Render table
    table := tableprinter.New(opts.IO, tableprinter.WithHeader(headers...))
    for _, pr := range listResult.PullRequests {
        table.AddField(prNum, ...)
        table.AddField(pr.Title)
        // ...
    }
    return table.Render()
}
```

**10. Output** (via `opts.IO`):
```
Showing 5 of 5 open pull requests in cli/cli

#123  Fix bug in pr list command    feat/fix-list  2 days ago
#122  Add new feature              feat/new       3 days ago
...
```

## Call Graph Seeds

These functions are valuable starting points for deeper architecture analysis:

### Core Initialization
- **`ghcmd.Main()`** at `internal/ghcmd/cmd.go:41` - Application entry point with full initialization sequence, error handling, and update checking
- **`factory.New()`** at `pkg/cmd/factory/default.go:28` - Factory construction showing dependency injection order
- **`root.NewCmdRoot()`** at `pkg/cmd/root/root.go:57` - Complete command tree registration and configuration

### Factory Resolvers
- **`factory.SmartBaseRepoFunc()`** at `pkg/cmd/factory/default.go:49` - Intelligent repository resolution with flag override support
- **`httpClientFunc()`** at `pkg/cmd/factory/default.go:188` - HTTP client construction with auth and middleware
- **`ioStreams()`** at `pkg/cmd/factory/default.go:292` - I/O configuration from environment and config

### Command Patterns
- **`pr.NewCmdPR()`** at `pkg/cmd/pr/pr.go:25` - Parent command with subcommand grouping
- **`list.NewCmdList()`** at `pkg/cmd/pr/list/list.go:45` - Leaf command with options, flags, and RunE
- **`list.listRun()`** at `pkg/cmd/pr/list/list.go:141` - Command business logic with lazy evaluation

### Extension Mechanisms
- **Extension registration** at `pkg/cmd/root/root.go:155-165` - Dynamic external command loading
- **Alias registration** at `pkg/cmd/root/root.go:168-197` - User-defined shortcuts
- **Command groups** at `pkg/cmd/root/root.go:73-83` - Organizational structure

## Initialization Order Guarantees

The factory construction order is critical for avoiding circular dependencies:

```
Level 0 (No Dependencies):
  - AppVersion
  - ExecutableName
  - Config

Level 1 (Depends on Config only):
  - IOStreams

Level 2 (Depends on Level 0-1):
  - HttpClient (Config, IOStreams)
  - PlainHttpClient (IOStreams)
  - GitClient (IOStreams)
  - Prompter (Config, IOStreams)
  - Browser (Config, IOStreams)

Level 3 (Depends on Level 0-2):
  - Remotes (Config, GitClient)
  - ExtensionManager (Config, HttpClient, IOStreams)

Level 4 (Depends on Level 0-3):
  - BaseRepo (Remotes)
  - Branch (GitClient)
```

This ordering ensures:
1. No circular dependencies
2. Each dependency is available when needed
3. Lazy functions can safely reference other factory fields
4. Commands can rely on all factory fields being populated

## Testing Integration

The factory pattern supports testing through:

### 1. RunF Injection

Every `NewCmd*` function accepts an optional `runF` parameter:

```go
func NewCmdList(f *cmdutil.Factory, runF func(*ListOptions) error) *cobra.Command
```

In tests:
```go
func TestListRun(t *testing.T) {
    tests := []struct {
        name    string
        opts    *ListOptions
        wantErr bool
    }{
        // test cases
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            cmd := NewCmdList(factory, func(opts *ListOptions) error {
                // Custom test logic
                assert.Equal(t, tt.opts.State, opts.State)
                return nil
            })

            cmd.Execute()
        })
    }
}
```

### 2. Factory Mocking

Tests create custom factories with mocked dependencies:

```go
func TestCommand(t *testing.T) {
    ios, _, stdout, stderr := iostreams.Test()
    factory := &cmdutil.Factory{
        IOStreams: ios,
        HttpClient: func() (*http.Client, error) {
            return &http.Client{
                Transport: httpmock.New(),  // Mock HTTP
            }, nil
        },
        BaseRepo: func() (ghrepo.Interface, error) {
            return ghrepo.New("owner", "repo"), nil
        },
    }

    cmd := NewCmdList(factory, nil)
    // ... test execution
}
```

### 3. Options Direct Testing

Commands can be tested by constructing `*Options` directly:

```go
func TestListRun(t *testing.T) {
    opts := &ListOptions{
        IO: iostreams.Test(),
        HttpClient: mockHttpClient,
        State: "open",
        // ...
    }

    err := listRun(opts)
    assert.NoError(t, err)
}
```

## Architecture Insights

### Why Factory Pattern?

1. **Dependency Injection**: Commands receive all dependencies through factory, avoiding globals
2. **Lazy Evaluation**: Expensive operations (config loading, HTTP client setup) deferred until needed
3. **Testability**: Easy to mock dependencies by replacing factory functions
4. **Flexibility**: Factory can be modified at runtime (e.g., `SmartBaseRepoFunc` replacement)
5. **Consistency**: All commands follow same initialization pattern

### Why Lazy Functions?

Factory uses function fields (`func() (T, error)`) instead of direct values for:

1. **Deferred Execution**: Only execute if command needs that dependency
2. **Runtime Context**: Resolution depends on current directory, flags, etc.
3. **Error Handling**: Can fail gracefully when dependency unavailable
4. **Overridability**: Can be replaced before command execution

Example: `BaseRepo` function is replaced with `SmartBaseRepoFunc` for commands that support `-R` flag.

### Why Two-Phase Command Creation?

Commands are created in two phases:

**Phase 1**: `NewCmd*` (at startup)
- Creates cobra.Command structure
- Registers flags
- Defines RunE function
- Fast, no I/O

**Phase 2**: `RunE` execution (when invoked)
- Resolves lazy dependencies
- Validates flag combinations
- Executes business logic

This separation:
- Keeps startup fast (doesn't resolve dependencies for unused commands)
- Allows flag completion to work without full initialization
- Supports help text generation without expensive operations

### Why Options Struct?

Each command uses an options struct (e.g., `ListOptions`) to:

1. **Group Related Data**: Command state, dependencies, and flags together
2. **Test Injection**: Easy to construct for testing
3. **Clear Interface**: Documents what a command needs
4. **Separation**: Options created in `NewCmd*`, populated by Cobra flags, consumed by run function

### Extension Architecture

The command system supports three extension mechanisms:

1. **Built-in Extensions** (`pkg/cmd/root/root.go:155-165`):
   - Discovered via `f.ExtensionManager.List()`
   - Registered as commands if no name conflict
   - Full access to factory

2. **Aliases** (`pkg/cmd/root/root.go:168-197`):
   - User-defined shortcuts from config
   - Two types: command aliases and shell aliases (prefix `!`)
   - Inherit help from target command

3. **External Commands**:
   - Handled via special error type `ExternalCommandExitError`
   - Exit code passed through from external process

## Summary

The GitHub CLI command factory pattern is a well-designed dependency injection system that:

1. **Bootstraps** through `main()` → `ghcmd.Main()` → `factory.New()` → `root.NewCmdRoot()`
2. **Initializes dependencies** in a specific order to avoid circular dependencies
3. **Registers commands** in a tree structure using cobra
4. **Executes commands** through RunE functions that bridge to business logic
5. **Resolves dependencies lazily** via factory function fields
6. **Supports testing** through injection points and mockable dependencies
7. **Enables extensions** through dynamic command registration

The pattern provides a clean separation between command structure (cobra metadata), dependency management (factory), and business logic (run functions), making the codebase maintainable and testable.
