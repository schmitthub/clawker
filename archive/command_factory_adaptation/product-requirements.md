# Product Requirements: GitHub CLI Command Factory System

> Generated by product-analyst for github/cli
>
> Feature Scope: Command Factory (`cmdutil.Factory`) dependency injection pattern and leaf command consumption
>
> Date: 2026-01-28

---

## Product Overview

**Product Name:** GitHub CLI Command Factory System
**Product Type:** Internal framework / Developer toolkit (Go library pattern)
**Primary Purpose:** Provide a consistent, testable dependency injection system that enables CLI developers to build new commands with shared access to configuration, HTTP clients, git operations, I/O streams, and other services -- without managing dependency lifecycle themselves.

**Target Users:**
- **CLI Command Developer**: Builds new `gh` subcommands (e.g., `gh pr list`, `gh issue create`) using the factory to obtain dependencies like HTTP clients, repository resolution, and terminal I/O.
- **CLI Test Author**: Writes unit and integration tests for commands by injecting mock dependencies through the factory pattern, avoiding real network calls, git operations, or terminal interactions.
- **CLI Framework Maintainer**: Extends or modifies the factory itself, adding new shared dependencies, changing initialization order, or introducing new resolution strategies.
- **Extension Developer**: Builds external `gh` extensions that receive factory-provided services for consistency with core commands.

---

## Core Features

### Feature 1: Centralized Dependency Injection Container

**Description:** The `cmdutil.Factory` struct acts as a single container that holds all shared dependencies needed by CLI commands. It is constructed once at application startup and threaded through the entire command hierarchy. Commands extract only the dependencies they need, keeping each command decoupled from the dependency creation logic.

**User Stories:**

##### US-1.1: Receive Pre-Configured Dependencies
> As a CLI command developer, I want to receive a factory with all dependencies already initialized so that I do not need to set up HTTP clients, git clients, or configuration loading myself.

**Acceptance Criteria:**
- [ ] Given a factory constructed via `factory.New(appVersion)`, when a command accesses `f.IOStreams`, then it receives a fully configured IOStreams instance with TTY detection, color support, and pager settings applied.
- [ ] Given a factory, when a command calls `f.HttpClient()`, then it receives an authenticated HTTP client with the user's credentials, User-Agent header, SSO header extraction, and debug logging configured.
- [ ] Given a factory, when a command accesses `f.GitClient`, then it receives a git client with stderr/stdin/stdout correctly wired to the IOStreams and the gh binary path set for credential helper integration.
- [ ] Given a factory, when a command accesses `f.Browser`, then it receives a browser launcher configured according to user preferences.
- [ ] Given a factory, when a command accesses `f.Prompter`, then it receives a prompter configured with the user's preferred editor and accessibility settings.

##### US-1.2: Lazy Evaluation of Expensive Dependencies
> As a CLI command developer, I want expensive operations (HTTP client creation, config file parsing, git remote discovery) to be deferred until I actually need them so that commands that do not use those resources start quickly.

**Acceptance Criteria:**
- [ ] Given a factory, when a command does not call `f.HttpClient()`, then no HTTP client is created and no config file is read for authentication credentials.
- [ ] Given a factory, when a command does not call `f.BaseRepo()`, then no git remotes are queried.
- [ ] Given a factory, when a command calls `f.Config()` multiple times, then the config file is read only once (cached on first call).
- [ ] Given a factory, when `f.Config()` fails on the first call, then subsequent calls return the same cached error without re-attempting.

##### US-1.3: Access Application Metadata
> As a CLI command developer, I want to access the application version and executable name through the factory so that I can include them in output, User-Agent headers, or help text.

**Acceptance Criteria:**
- [ ] Given a factory, when `f.AppVersion` is read, then it returns the build version string injected at compile time.
- [ ] Given a factory, when `f.Executable()` is called, then it returns the absolute path to the currently running `gh` binary, respecting the `GH_PATH` environment variable override.

---

### Feature 2: Options Struct Pattern for Command Configuration

**Description:** Each leaf command defines its own Options struct that cherry-picks dependencies from the factory and adds command-specific flags and state. The run function depends only on the Options struct, never on the factory directly, achieving the principle of depending on what you use rather than what you are given.

**User Stories:**

##### US-2.1: Define Command-Specific Dependencies
> As a CLI command developer, I want to define an Options struct that declares exactly which factory dependencies my command needs so that the command's requirements are self-documenting and testable.

**Acceptance Criteria:**
- [ ] Given a new command, when I define a `ListOptions` struct with `HttpClient func() (*http.Client, error)` and `IO *iostreams.IOStreams`, then those fields are populated from the factory in the `NewCmdList` constructor.
- [ ] Given an Options struct, when the run function executes, then it accesses dependencies exclusively through the Options struct, not through the factory pointer.
- [ ] Given an Options struct with lazy function fields (e.g., `BaseRepo func() (ghrepo.Interface, error)`), when the run function calls `opts.BaseRepo()`, then the closure is evaluated at that point, enabling late binding.

##### US-2.2: Add Command-Specific Flags
> As a CLI command developer, I want to bind cobra flag values directly to my Options struct fields so that flag parsing and command configuration are unified in one place.

**Acceptance Criteria:**
- [ ] Given a command with `--state` flag, when `cmd.Flags().StringVar` binds to `opts.State`, then after cobra parses `--state closed`, `opts.State` equals `"closed"`.
- [ ] Given a command using `cmdutil.StringEnumFlag`, when an invalid value is provided (e.g., `--state invalid`), then a validation error is returned before the run function executes.
- [ ] Given a command using `cmdutil.NilBoolFlag` for `--draft`, when the flag is not provided, then `opts.Draft` is `nil` (distinguishable from explicit `--draft=false`).
- [ ] Given a command using `cmdutil.AddJSONFlags`, when `--json number,title` is provided, then `opts.Exporter` is non-nil and configured to output only those fields.

##### US-2.3: Inject Test-Specific Dependencies
> As a CLI command developer, I want to add test injection points (e.g., `Now func() time.Time`, `Detector fd.Detector`) to my Options struct so that tests can control time, feature detection, or other external factors.

**Acceptance Criteria:**
- [ ] Given an Options struct with `Now func() time.Time`, when the constructor sets `Now: time.Now`, then production code uses real time.
- [ ] Given a test that constructs Options with `Now: func() time.Time { return fixedTime }`, when the run function calls `opts.Now()`, then it receives the fixed time for deterministic output.

---

### Feature 3: Test Double Injection via `runF` Parameter

**Description:** Every `NewCmd*` function accepts an optional `runF func(*Options) error` parameter. When non-nil, it replaces the real run function. This enables tests to intercept execution after cobra flag parsing and validation but before business logic, allowing surgical injection of test doubles.

**User Stories:**

##### US-3.1: Override Run Function for Testing
> As a CLI test author, I want to pass a custom run function to `NewCmdList` so that I can verify flag parsing produces correct options without executing the real command logic.

**Acceptance Criteria:**
- [ ] Given `NewCmdList(factory, testRunF)` where `testRunF` captures the options, when the command executes with `--state closed --limit 10`, then `testRunF` receives an Options struct with `State == "closed"` and `LimitResults == 10`.
- [ ] Given `NewCmdList(factory, nil)`, when the command executes, then it calls the real `listRun(opts)` function (production path).
- [ ] Given a `runF` that modifies options before calling the real run function (e.g., injecting a fake `Detector`), when the real run function executes, then it uses the injected test double.

##### US-3.2: Test Flag Validation
> As a CLI test author, I want to verify that invalid flag combinations produce appropriate errors without needing to mock HTTP or git dependencies.

**Acceptance Criteria:**
- [ ] Given `--limit 0` is passed to `gh pr list`, when the RunE function executes, then it returns a `FlagError` with message containing "invalid value for --limit".
- [ ] Given both `--author` and `--app` flags are provided, when the RunE function executes, then it returns a `FlagError` indicating mutual exclusivity.
- [ ] Given a `runF` override, when flag validation fails, then `runF` is never called (validation occurs before delegation).

##### US-3.3: Construct Minimal Factory for Tests
> As a CLI test author, I want to construct a partial `Factory` struct with only the fields my test needs so that tests are concise and do not require setting up unrelated dependencies.

**Acceptance Criteria:**
- [ ] Given a test that only needs IOStreams and HttpClient, when `factory := &cmdutil.Factory{IOStreams: ios, HttpClient: mockFn}` is created, then `NewCmdList(factory, runF)` succeeds without requiring Browser, Prompter, or other fields.
- [ ] Given `iostreams.Test()` returns `(ios, stdin, stdout, stderr)`, when a command writes to `opts.IO.Out`, then `stdout.String()` contains the output.

---

### Feature 4: Repository Resolution Strategies

**Description:** The factory supports two repository resolution strategies -- basic (first remote) and smart (API-aware with fork handling). The root command selectively assigns the smart resolver to commands that operate on repositories, avoiding unnecessary API calls for commands that do not need them.

**User Stories:**

##### US-4.1: Basic Repository Resolution
> As a CLI command developer, I want the default `BaseRepo` to return the first git remote (sorted by priority: upstream, github, origin, then others) so that simple commands resolve a repository quickly without API calls.

**Acceptance Criteria:**
- [ ] Given git remotes `upstream` (cli/cli) and `origin` (user/fork), when `BaseRepoFunc` resolves, then it returns `cli/cli` (upstream is prioritized).
- [ ] Given only an `origin` remote, when `BaseRepoFunc` resolves, then it returns the origin repository.
- [ ] Given no authenticated remotes, when `BaseRepoFunc` resolves, then it returns an error.

##### US-4.2: Smart Repository Resolution with Fork Awareness
> As a CLI command developer working on PR/issue commands, I want `SmartBaseRepoFunc` to use the GitHub API to resolve fork relationships and prompt for disambiguation so that commands operate on the correct base repository.

**Acceptance Criteria:**
- [ ] Given a fork with upstream configured and `resolved` git config set to `base`, when `SmartBaseRepoFunc` resolves, then it returns the upstream repository without prompting.
- [ ] Given multiple remotes with no `resolved` config and an interactive terminal, when `SmartBaseRepoFunc` resolves and finds multiple candidate repositories, then it instructs the user to run `gh repo set-default`.
- [ ] Given a non-interactive terminal (piped output), when `SmartBaseRepoFunc` resolves and there is no `resolved` config, then it returns the first remote without prompting (backward compatibility).

##### US-4.3: Repository Override via -R Flag
> As a CLI end user, I want to use `-R owner/repo` to target a specific repository regardless of my current git directory so that I can operate on any repository without cloning it.

**Acceptance Criteria:**
- [ ] Given `gh pr list -R cli/cli`, when the command executes, then `opts.BaseRepo()` returns `cli/cli` regardless of the current directory's git remotes.
- [ ] Given the `GH_REPO` environment variable is set to `cli/cli`, when no `-R` flag is provided, then `opts.BaseRepo()` returns `cli/cli`.
- [ ] Given both `-R user/repo` and `GH_REPO=other/repo`, when the command executes, then `-R` takes precedence.

---

### Feature 5: Consistent Command Structure Pattern

**Description:** All commands follow a three-phase pattern: (1) construction in `NewCmd*` where dependencies are extracted from the factory and flags are registered, (2) validation in `RunE` where flags are checked and late-binding assignments occur, (3) execution in the run function where business logic uses only the Options struct. This pattern ensures consistency across 100+ commands.

**User Stories:**

##### US-5.1: Follow the Standard Command Pattern
> As a CLI command developer, I want a documented, consistent pattern for building new commands so that I can create commands quickly and other developers can review them easily.

**Acceptance Criteria:**
- [ ] Given a new command package `pkg/cmd/pr/list/`, when implementing it, then it must contain: (a) a `ListOptions` struct, (b) a `NewCmdList(f *cmdutil.Factory, runF func(*ListOptions) error) *cobra.Command` function, and (c) a `listRun(opts *ListOptions) error` function.
- [ ] Given the `NewCmdList` function, when it creates the Options struct, then factory dependencies are assigned immediately (e.g., `IO: f.IOStreams`) while `BaseRepo` is assigned in `RunE` (late binding for `-R` support).
- [ ] Given the `RunE` closure, when `runF` is non-nil, then it calls `runF(opts)`; when nil, it calls `listRun(opts)`.
- [ ] Given a command group like `pr`, when registering subcommands, then each is created via `list.NewCmdList(f, nil)` passing the factory and nil for the run function.

##### US-5.2: Support Command Aliases
> As a CLI end user, I want `gh pr ls` to work as an alias for `gh pr list` so that I can use shorter command names.

**Acceptance Criteria:**
- [ ] Given a command with `Aliases: []string{"ls"}`, when `gh pr ls` is invoked, then it executes the `list` command.

##### US-5.3: Support Web Mode
> As a CLI end user, I want `gh pr list --web` to open the pull requests page in my browser so that I can view results in the GitHub web interface.

**Acceptance Criteria:**
- [ ] Given `--web` flag is set, when the command executes, then `opts.Browser.Browse(url)` is called with the correct GitHub URL including filter parameters.
- [ ] Given `--web` flag is set and stdout is a TTY, when the command executes, then a message "Opening ... in your browser." is printed to stderr.

---

### Feature 6: Factory Construction and Dependency Wiring

**Description:** The `factory.New()` function constructs the factory with an explicit, ordered initialization sequence. Dependencies are wired in topological order so that each dependency's requirements are available when it is initialized.

**User Stories:**

##### US-6.1: Initialize Dependencies in Correct Order
> As a CLI framework maintainer, I want the factory to initialize dependencies in a well-defined order so that no dependency is used before it is available.

**Acceptance Criteria:**
- [ ] Given `factory.New(version)` is called, then dependencies are initialized in this order: Config (no deps) -> IOStreams (Config) -> HttpClient (Config, IOStreams) -> PlainHttpClient (IOStreams) -> GitClient (IOStreams) -> Remotes (Config, GitClient) -> BaseRepo (Remotes) -> Prompter (Config, IOStreams) -> Browser (Config, IOStreams) -> ExtensionManager (Config, HttpClient, IOStreams) -> Branch (GitClient).
- [ ] Given any dependency initialization fails, when a command accesses that dependency, then the error is propagated at call time (not at factory construction time).
- [ ] Given the factory is constructed, when no command has been executed yet, then no config file has been read, no HTTP client has been created, and no git operations have been performed (all lazy dependencies remain unevaluated).

##### US-6.2: Configure IOStreams from Environment and Config
> As a CLI end user, I want my terminal preferences (pager, color, prompts, accessibility) to be automatically applied so that the CLI respects my configuration.

**Acceptance Criteria:**
- [ ] Given `GH_PROMPT_DISABLED=1` is set, when IOStreams is created, then `io.CanPrompt()` returns false.
- [ ] Given `GH_PAGER=less` is set, when IOStreams is created, then the pager is set to `less`.
- [ ] Given pager precedence order: `GH_PAGER` > config `pager` > `PAGER`, when both `GH_PAGER` and config pager are set, then `GH_PAGER` wins.
- [ ] Given `GH_ACCESSIBLE_PROMPTER=1` is set, when IOStreams is created, then the accessible prompter mode is enabled.
- [ ] Given `GH_SPINNER_DISABLED=1` is set, when IOStreams is created, then spinners are replaced with text indicators.

##### US-6.3: Provide Both Authenticated and Plain HTTP Clients
> As a CLI command developer, I want access to both an authenticated and a plain HTTP client so that login flows can avoid circular dependency on existing credentials.

**Acceptance Criteria:**
- [ ] Given `f.HttpClient()` is called, then the returned client includes authentication headers from the user's stored credentials.
- [ ] Given `f.PlainHttpClient()` is called, then the returned client has `SkipDefaultHeaders: true` and does not include authentication headers.
- [ ] Given any HTTP response includes an `X-GitHub-SSO` header, then the SSO URL is captured globally and accessible via `factory.SSOURL()`.

---

### Feature 7: Structured Error Handling

**Description:** The factory system defines a hierarchy of error types that map to specific exit codes and user-facing behaviors. Commands return typed errors, and the top-level `Main()` function translates them into appropriate exit codes and messages.

**User Stories:**

##### US-7.1: Return Typed Errors for Different Outcomes
> As a CLI command developer, I want to return specific error types so that the CLI displays appropriate messages and exits with the correct code.

**Acceptance Criteria:**
- [ ] Given a command returns `cmdutil.FlagErrorf(...)`, then the CLI displays the error message along with command usage text and exits with code 1.
- [ ] Given a command returns `cmdutil.SilentError`, then the CLI exits with code 1 without printing any additional message.
- [ ] Given a command returns `cmdutil.CancelError`, then the CLI exits with code 2.
- [ ] Given a command returns `cmdutil.PendingError`, then the CLI exits with code 8.
- [ ] Given a command returns `cmdutil.NewNoResultsError(msg)`, then the CLI exits with code 0 and prints the message to stderr only when stdout is a TTY.

##### US-7.2: Handle Authentication Errors Gracefully
> As a CLI end user, I want helpful error messages when I am not authenticated so that I know how to fix the problem.

**Acceptance Criteria:**
- [ ] Given a command requires authentication and the user is not logged in, then the CLI displays authentication help text and exits with code 4.
- [ ] Given an HTTP 401 response, then the CLI suggests `gh auth login`.
- [ ] Given an SSO challenge response, then the CLI displays the browser authorization URL.
- [ ] Given missing OAuth scopes, then the CLI displays which scopes are needed.

##### US-7.3: Handle Pager Closure Gracefully
> As a CLI end user, I want to quit the pager (e.g., press `q` in `less`) without seeing an error so that exiting the pager feels natural.

**Acceptance Criteria:**
- [ ] Given the user closes the pager mid-output, when a write to stdout returns EPIPE, then the CLI exits with code 0 (not an error).

---

## Supporting Features

### SF-1: Custom Flag Types

The `cmdutil` package provides specialized flag types that reduce boilerplate and enforce consistency:
- `StringEnumFlag`: Restricts values to a predefined set with shell completion.
- `NilBoolFlag`: Distinguishes between "not set" (nil), "explicitly true", and "explicitly false".
- `NilStringFlag`: Distinguishes between "not set" (nil) and "set to empty string".
- `AddJSONFlags`: Registers `--json`, `--jq`, and `--template` flags for structured output.
- `RegisterBranchCompletionFlags`: Enables git branch name completion for specified flags.
- `MutuallyExclusive`: Validates that at most one of several conditions is true.

### SF-2: JSON Export System

Commands support structured output via the `Exporter` interface:
- `--json field1,field2` selects specific fields for JSON output.
- `--jq expression` applies a jq filter to JSON output.
- `--template tmpl` applies a Go template to JSON output.
- Commands check `if opts.Exporter != nil` to branch between human-readable and structured output.

### SF-3: TTY-Adaptive Output

Commands adapt their output based on terminal detection:
- TTY stdout: Table headers, colored output, `#` prefix on PR numbers, relative timestamps.
- Non-TTY stdout (piped): No headers, no color, raw PR numbers, additional STATE column, absolute timestamps.
- Pager: Started only when stdout is a TTY; pager failure is non-fatal (logged to stderr, command continues).
- Progress indicators: Shown only when both stdout and stderr are TTY; uses spinner or text based on accessibility settings.

### SF-4: Authentication Pre-Check

The root command's `PersistentPreRunE` hook checks authentication before any command runs:
- Commands can opt out via `cmdutil.DisableAuthCheck(cmd)`.
- Individual flags can disable the check via `cmdutil.DisableAuthCheckFlag(flag)` (e.g., `--web` does not need auth).

### SF-5: Extension and Alias Support

The root command dynamically registers:
- Extensions discovered via `f.ExtensionManager.List()`, skipping any that conflict with core commands.
- User-defined aliases from configuration, supporting both command aliases and shell aliases (prefixed with `!`).

### SF-6: Shared Utility Packages

Command groups maintain `shared/` packages for cross-command utilities:
- `pkg/cmd/pr/shared/`: PR display formatting, filter options, query builders, interactive editing, PR finder.
- Each group's shared package is isolated from other groups, preventing coupling.
- Shared packages can themselves receive factory dependencies (e.g., `shared.NewFinder(factory)`).

---

## Non-Functional Requirements

### Performance

| Metric | Requirement | Notes |
|--------|-------------|-------|
| CLI startup time | Factory construction must not perform I/O | All expensive operations (config, HTTP, git) are lazy closures |
| Config loading | Cached after first call | `configFunc()` uses closure-based memoization |
| HTTP client creation | On-demand only | Not created if command does not need network access |
| Git operations | On-demand only | Not performed if command does not need repository context |
| TCELL_MINIMIZE | Set at build init | Saves 30-40ms startup by reducing terminal library initialization |

### Testability

| Requirement | Implementation | Notes |
|-------------|----------------|-------|
| Commands must be unit-testable without real I/O | `iostreams.Test()` provides buffer-backed streams | Returns stdin, stdout, stderr buffers |
| Commands must be testable without real HTTP | `httpmock.Registry` as `http.RoundTripper` | Supports GraphQL regex matching and response fixtures |
| Commands must be testable without real git | Factory fields accept mock closures | `BaseRepo`, `Branch`, `Remotes` can return canned values |
| Commands must support run function override | `runF func(*Options) error` parameter | Every `NewCmd*` function must accept this parameter |
| Time-dependent output must be deterministic in tests | `Now func() time.Time` in Options | Injected via `runF` override pattern |
| Browser operations must be verifiable | `browser.Stub` records opened URLs | `BrowsedURL()` method for assertions |

### Extensibility

| Requirement | Rationale |
|-------------|-----------|
| Adding a new command must not require modifying the factory struct | New commands extract existing factory fields; new shared dependencies are rare |
| Adding a new command requires exactly one registration line in the parent group | `cmd.AddCommand(newcmd.NewCmdX(f, nil))` |
| Factory fields can be replaced at runtime for specialization | Demonstrated by `SmartBaseRepoFunc` struct copy pattern and `EnableRepoOverride` mutation |
| New factory dependencies can be added without breaking existing commands | Go struct allows additive field additions; existing commands simply ignore new fields |

### Reliability

- Lazy dependency failures propagate as errors at call time, not as panics at startup.
- The pager writer wraps EPIPE errors as `ErrClosedPagerPipe`, which is treated as a successful exit.
- The extension manager degrades gracefully if Config or HttpClient initialization fails (returns a partially functional manager).
- DNS errors are detected and displayed with a helpful "check your internet connection" message.

### Security

- Authenticated and plain HTTP clients are separate (`HttpClient` vs `PlainHttpClient`) to prevent credential leakage during login flows.
- OAuth client credentials are injected at compile time via `-ldflags`, never stored in source code.
- Credentials are stored in the OS keyring when available, with fallback to config file.
- SSO challenge URLs are extracted from HTTP response headers and displayed to the user.
- The `PersistentPreRunE` auth check prevents unauthenticated commands from reaching API endpoints.

### Usability

- Commands support `-R owner/repo` for operating on any repository without cloning.
- Shell completion is generated for enum flags, branch names, and JSON field names.
- `NoArgsQuoteReminder` provides helpful error messages when users forget quotes around arguments.
- Help text uses `heredoc.Doc` for clean multi-line formatting.
- Commands have aliases (e.g., `ls` for `list`) for discoverability.

### Compatibility

- Supports github.com and GitHub Enterprise Server (GHES) via `featuredetection.Detector`.
- Cross-platform: Linux, macOS, Windows with platform-specific terminal handling (Cygwin detection, colorable wrapping).
- Go 1.25.5 required (specified in `go.mod`).
- Cobra v1.10.2 for command framework.
- `go-gh` v2.13.0 for GitHub API integration.

---

## Assumptions

Things assumed to be true for this specification:

1. The factory is constructed exactly once per CLI invocation in `ghcmd.Main()`.
2. Commands execute synchronously; there is no concurrent command execution sharing a factory instance.
3. The factory struct is passed by pointer, and only `BaseRepo` is mutated at runtime (via `EnableRepoOverride`).
4. Config is immutable during a single command execution (cached after first read).
5. All leaf commands follow the three-phase pattern (construction, validation, execution).
6. The `runF` parameter is `nil` in production and non-nil only in tests.
7. Go struct zero values are safe for unused factory fields (commands only access what they need).

---

## Constraints

Limitations that affect the product:

1. **Factory is a concrete struct, not an interface**: The injection contract is implicit (public fields) rather than compiler-enforced. Adding a required field cannot be caught at compile time for existing consumers.
2. **Single-variant specialization**: The struct copy pattern (`repoResolvingCmdFactory := *f`) works for one variant (smart BaseRepo) but does not scale to multiple independent variants.
3. **Runtime field mutation**: `EnableRepoOverride` mutates the factory at runtime, which depends on cobra hook execution order being correct. This is an implicit coupling.
4. **Initialization order is manual**: The wiring order in `factory.New()` relies on developer discipline and comments; there is no compile-time enforcement of the dependency graph.
5. **Global SSO state**: The `ssoHeader` package-level variable is a side effect captured through HTTP transport middleware, making it difficult to test or scope.
6. **Factory growth**: With 13+ fields, the Factory approaches "God Object" territory. Each new shared dependency requires changes in three packages (definition, construction, root command).

---

## Out of Scope

Explicitly not included in this specification:

1. **Individual command business logic**: This document covers the factory pattern and how commands consume it, not the specific behavior of `gh pr list`, `gh issue create`, etc.
2. **GitHub API protocol details**: GraphQL query construction, pagination, and REST endpoints are API-layer concerns, not factory concerns.
3. **Extension system internals**: How extensions are discovered, installed, and executed is outside the factory pattern scope.
4. **Configuration file format**: The YAML configuration schema and migration logic are internal to the config package.
5. **Release and deployment**: Build system, CI/CD, and distribution are infrastructure concerns documented separately.

---

## Dependencies

External systems or conditions required:

1. **Cobra (v1.10.2)**: Command framework providing command tree, flag parsing, help generation, and subcommand routing. Replacement would require rewriting every command handler.
2. **pflag (v1.0.10)**: Flag parsing library tightly integrated with Cobra. Required for all flag types including custom helpers.
3. **go-gh (v2.13.0)**: GitHub API client providing GraphQL interface, token management, and HTTP transport. Foundation for `api/client.go`.
4. **Git CLI**: The `git.Client` wraps the system `git` binary for repository operations. Requires git to be installed.
5. **Operating System**: Terminal detection, pager launching, browser opening, and keyring access are OS-dependent. Platform-specific handling exists for macOS, Linux, and Windows.
6. **GitHub Authentication**: Commands that access the API require stored OAuth tokens or environment variables (`GH_TOKEN`).

---

## Glossary

| Term | Definition |
|------|------------|
| Factory | The `cmdutil.Factory` struct that serves as the dependency injection container for all CLI commands |
| Options struct | A per-command struct (e.g., `ListOptions`) that holds extracted factory dependencies and command-specific flags |
| Lazy closure | A `func() (T, error)` field on the factory that defers expensive initialization until first invocation |
| `runF` | An optional function parameter in `NewCmd*` constructors that overrides the real run function for testing |
| Late binding | The pattern where `opts.BaseRepo = f.BaseRepo` is assigned in `RunE` (not in the constructor) to support runtime override via `-R` flag |
| Smart resolution | `SmartBaseRepoFunc` -- API-aware repository resolution that handles forks and prompts for disambiguation |
| Basic resolution | `BaseRepoFunc` -- Simple resolution that returns the first remote sorted by name priority |
| `EnableRepoOverride` | A mechanism that adds `-R/--repo` flag support to command groups by mutating `f.BaseRepo` in a `PersistentPreRunE` hook |
| Sentinel error | A package-level error value (e.g., `SilentError`, `CancelError`) used for control flow rather than exceptional conditions |
| `FlagError` | An error type that triggers display of command usage text alongside the error message |
| `NoResultsError` | An error type that indicates empty query results (exit code 0, message shown only in TTY mode) |
| IOStreams | The `iostreams.IOStreams` struct that wraps stdin/stdout/stderr with TTY detection, color, pager, and progress indicator support |
| `httpmock.Registry` | A test utility that acts as an `http.RoundTripper`, matching requests and returning stubbed responses |

---

## Feature Priority Matrix

| Feature | Priority | Complexity | Notes |
|---------|----------|------------|-------|
| Centralized Factory struct with all dependencies | Must Have | Medium | Core of the pattern; all commands depend on it |
| Options struct per command | Must Have | Low | Simple Go struct pattern; self-documenting |
| Lazy closure fields for expensive dependencies | Must Have | Medium | Essential for startup performance and late binding |
| `runF` test injection parameter | Must Have | Low | Critical for testability; every command must support it |
| Basic repository resolution (`BaseRepoFunc`) | Must Have | Low | Simple first-remote selection |
| Smart repository resolution (`SmartBaseRepoFunc`) | Must Have | High | API-aware fork resolution with prompting |
| Repository override (`-R` flag, `EnableRepoOverride`) | Must Have | Medium | Enables operating on any repository |
| Ordered dependency initialization in `New()` | Must Have | Medium | Must be correct; fragile if order changes |
| Custom flag types (`StringEnumFlag`, `NilBoolFlag`, etc.) | Should Have | Low | Reduces boilerplate; enforces consistency |
| JSON export flags (`AddJSONFlags`) | Should Have | Medium | Important for scripting and automation |
| TTY-adaptive output behavior | Should Have | Medium | Key UX differentiator for interactive vs piped usage |
| Authentication pre-check (`PersistentPreRunE`) | Should Have | Low | Prevents confusing API errors for unauthenticated users |
| Typed error hierarchy with exit codes | Should Have | Low | Important for scripting consumers |
| Branch completion registration | Nice to Have | Low | UX enhancement for tab completion |
| Extension and alias dynamic registration | Nice to Have | High | Extensibility feature; not needed for core commands |
| Factory variant via struct copy | Nice to Have | Low | Enables per-group specialization |

---

## Appendix: Key Source File Locations

| File | Purpose |
|------|---------|
| `/Users/andrew/Code/vendor/github/cli/pkg/cmdutil/factory.go` | Factory struct definition |
| `/Users/andrew/Code/vendor/github/cli/pkg/cmd/factory/default.go` | Factory constructor (`New()`) and all dependency initializers |
| `/Users/andrew/Code/vendor/github/cli/pkg/cmd/factory/remote_resolver.go` | Remote resolution logic |
| `/Users/andrew/Code/vendor/github/cli/pkg/cmd/root/root.go` | Root command assembly, dual factory strategy |
| `/Users/andrew/Code/vendor/github/cli/pkg/cmd/pr/list/list.go` | Reference leaf command implementation |
| `/Users/andrew/Code/vendor/github/cli/pkg/cmd/pr/list/list_test.go` | Reference test implementation |
| `/Users/andrew/Code/vendor/github/cli/pkg/cmdutil/repo_override.go` | `-R` flag implementation and factory mutation |
| `/Users/andrew/Code/vendor/github/cli/pkg/cmdutil/flags.go` | Custom flag type helpers |
| `/Users/andrew/Code/vendor/github/cli/pkg/cmdutil/json_flags.go` | JSON export flag system |
| `/Users/andrew/Code/vendor/github/cli/pkg/cmdutil/errors.go` | Error types and sentinel values |
| `/Users/andrew/Code/vendor/github/cli/pkg/iostreams/iostreams.go` | IOStreams with TTY detection and `Test()` helper |
| `/Users/andrew/Code/vendor/github/cli/pkg/httpmock/registry.go` | HTTP mocking test infrastructure |
| `/Users/andrew/Code/vendor/github/cli/internal/ghcmd/cmd.go` | Application entry point (`Main()`) with error-to-exit-code mapping |
