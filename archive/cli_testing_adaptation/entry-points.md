# Entry Points Analysis - Testing Implementation

> Generated by entry-point-analyzer for docker/cli

## Entry Point Summary

```
Application Type: Hybrid (CLI with extensive testing infrastructure)
Primary Test Entries:
  - Unit tests: gotestsum, go test, docker buildx bake test
  - E2E tests: scripts/test/e2e/entry, docker buildx bake e2e-image
  - CI/CD: GitHub Actions workflows
Testing Modes: Container-based, Host-based, Remote daemon
```

## Testing Entry Points Overview

The Docker CLI project has a sophisticated multi-layered testing infrastructure with three primary entry point categories:

1. **Container-Based Testing** - Tests run inside Docker containers (preferred method)
2. **Host-Based Testing** - Direct Go test execution on host machines
3. **CI/CD Pipeline Testing** - GitHub Actions orchestrated test execution

---

## Primary Entry Points

### 1. Container-Based Unit Tests

#### `docker buildx bake test`
- **File**: docker-bake.hcl:143-147
- **Type**: Docker BuildKit target
- **Invocation**: `docker buildx bake test`
- **Purpose**: Execute unit tests in containerized environment

**Target Definition**:
```hcl
target "test" {
    inherits = ["_common"]
    target = "test"
    output = ["type=cacheonly"]
}
```

**Dockerfile Stage** (Dockerfile:94-100):
```dockerfile
FROM build-${BASE_VARIANT} AS test
COPY --link --from=gotestsum /out/gotestsum /usr/bin/gotestsum
ENV GO111MODULE=auto
RUN --mount=type=bind,target=.,rw \
    --mount=type=cache,target=/root/.cache \
    --mount=type=cache,target=/go/pkg/mod \
    gotestsum -- -coverprofile=/tmp/coverage.txt $(go list ./... | grep -vE '/vendor/|/e2e/|/cmd/docker-trust')
```

#### `docker buildx bake test-coverage`
- **File**: docker-bake.hcl:149-153
- **Type**: Docker BuildKit target with coverage output
- **Invocation**: `docker buildx bake test-coverage`
- **Purpose**: Execute unit tests and export coverage report

**Coverage Export**:
```hcl
target "test-coverage" {
    inherits = ["_common"]
    target = "test-coverage"
    output = ["build/coverage"]
}
```

---

### 2. Host-Based Unit Tests

#### `make test-unit` (Local Development)
- **File**: Makefile:35-37
- **Type**: Make target (direct execution)
- **Invocation**: `make test-unit`
- **Purpose**: Run unit tests on host with gotestsum

```makefile
test-unit: ## run unit tests
	gotestsum -- $${TESTDIRS:-$(shell go list ./... | grep -vE '/vendor/|/e2e/|/cmd/docker-trust')} $(TESTFLAGS)
```

**Environment Variables**:
- `TESTDIRS`: Override directories to test (default: all non-vendor, non-e2e)
- `TESTFLAGS`: Additional flags passed to `go test`
- `GOTESTSUM_FORMAT`: Output format (dots, short, standard-quiet, etc.)

#### Direct `go test` Invocation
- **File**: N/A (standard Go tooling)
- **Type**: Direct test execution
- **Invocation**: `go test ./path/to/package -run TestName`
- **Purpose**: Run specific tests during development

**Example**:
```bash
# Single test
go test ./cli/command/container/... -run TestRunLabel -v

# Via gotestsum (preferred)
gotestsum -- ./cli/command/container/... -run TestRunLabel
```

---

### 3. E2E Testing Entry Points

#### E2E Test Entry Script
- **File**: scripts/test/e2e/entry
- **Type**: Bash orchestration script
- **Invocation**: Called from Dockerfile CMD or manually
- **Purpose**: Main entry point for e2e test execution

**Flow**:
```bash
#!/usr/bin/env bash
if [ -n "${REMOTE_DAEMON-}" ]; then
  # Run tests against a remote daemon
  ./scripts/test/e2e/run fetch-images
  ./scripts/test/e2e/run test "${DOCKER_HOST-}"
else
  # Run tests against dind (Docker-in-Docker)
  ./scripts/test/e2e/wrapper
fi
```

#### E2E Test Orchestration
- **File**: scripts/test/e2e/run
- **Type**: Multi-mode orchestration script
- **Invocation**: `./scripts/test/e2e/run [setup|cleanup|test|run]`
- **Purpose**: Setup test environment, run tests, teardown

**Modes**:
1. **setup**: Start Docker Compose test environment
2. **cleanup**: Tear down test environment
3. **test ENGINE_HOST**: Run tests against specific engine
4. **run** (default): Full cycle (setup → test → cleanup)
5. **fetch-images**: Pre-fetch required Docker images

**Test Execution** (lines 60-75):
```bash
runtests() {
    local engine_host=$1
    env -i \
        TEST_DOCKER_HOST="$engine_host" \
        TEST_DOCKER_CERT_PATH="${DOCKER_CERT_PATH-}" \
        TEST_REMOTE_DAEMON="${REMOTE_DAEMON-}" \
        TEST_SKIP_PLUGIN_TESTS="${SKIP_PLUGIN_TESTS-}" \
        GOPATH="$GOPATH" \
        PATH="$PWD/build/:/usr/bin:/usr/local/bin:/usr/local/go/bin" \
        HOME="$HOME" \
        DOCKER_CLI_E2E_PLUGINS_EXTRA_DIRS="$PWD/build/plugins-linux-${GOARCH}" \
        GO111MODULE=auto \
        "$(command -v gotestsum)" -- ${TESTDIRS:-./e2e/...} ${TESTFLAGS-}
}
```

#### E2E Container Image Build
- **File**: docker-bake.hcl:155-164, Dockerfile:124-133
- **Type**: Docker BuildKit target
- **Invocation**: `docker buildx bake e2e-image`
- **Purpose**: Build container image with e2e test suite

**Dockerfile E2E Stage**:
```dockerfile
FROM e2e-base-${BASE_VARIANT} AS e2e
COPY --link --from=gotestsum /out/gotestsum /usr/bin/gotestsum
COPY --link --from=build /out ./build/
COPY --link --from=build-plugins /out ./build/
COPY --link --from=buildx  /buildx         /usr/libexec/docker/cli-plugins/docker-buildx
COPY --link --from=compose /docker-compose /usr/libexec/docker/cli-plugins/docker-compose
COPY --link . .
ENV DOCKER_BUILDKIT=1
ENV PATH=/go/src/github.com/docker/cli/build:$PATH
CMD ["./scripts/test/e2e/entry"]
```

#### E2E Test Execution (Make)
- **File**: docker.Makefile:131-145
- **Type**: Make targets for e2e variants
- **Invocation**: `make -f docker.Makefile test-e2e-local` or `test-e2e-connhelper-ssh`

```makefile
test-e2e-local: build-e2e-image
	docker run --rm $(ENVVARS) \
		--mount type=bind,src=$(CURDIR)/build/coverage,dst=/tmp/coverage \
		--mount type=bind,src=/var/run/docker.sock,dst=/var/run/docker.sock \
		$(E2E_IMAGE_NAME)

test-e2e-connhelper-ssh: build-e2e-image
	docker run --rm $(ENVVARS) -e TEST_CONNHELPER=ssh \
		--mount type=bind,src=$(CURDIR)/build/coverage,dst=/tmp/coverage \
		--mount type=bind,src=/var/run/docker.sock,dst=/var/run/docker.sock \
		$(E2E_IMAGE_NAME)
```

---

## Initialization Sequence

### Unit Test Initialization

```
1. Test Discovery (go test / gotestsum)
   └─ Package scanning via `go list ./...`

2. Package-level TestMain (if present)
   ├─ Example: e2e/container/main_test.go:11-17
   └─ Calls environment.Setup()

3. Environment Setup (internal/test/environment/testenv.go:18-49)
   ├─ Read TEST_DOCKER_HOST env var
   ├─ Set DOCKER_HOST override
   ├─ Configure TLS if TEST_DOCKER_CERT_PATH set
   ├─ Set REMOTE_DAEMON flag
   └─ Set SKIP_PLUGIN_TESTS flag

4. Individual Test Execution
   └─ Test functions run in package
```

**Environment Setup Code**:
```go
func Setup() error {
    dockerHost := os.Getenv("TEST_DOCKER_HOST")
    if dockerHost == "" {
        return errors.New("$TEST_DOCKER_HOST must be set")
    }
    if err := os.Setenv(client.EnvOverrideHost, dockerHost); err != nil {
        return err
    }
    // TLS, REMOTE_DAEMON, SKIP_PLUGIN_TESTS configuration...
    return nil
}
```

### E2E Test Initialization (Container-Based)

```
1. Build E2E Image (docker buildx bake e2e-image)
   ├─ Build CLI binary (FROM build stage)
   ├─ Build test plugins (FROM build-plugins stage)
   ├─ Install gotestsum, buildx, compose plugins
   └─ Copy source code

2. Start E2E Container
   └─ CMD: ./scripts/test/e2e/entry

3. E2E Entry Script (scripts/test/e2e/entry)
   ├─ Check REMOTE_DAEMON flag
   └─ Route to appropriate test mode

4a. Remote Daemon Mode
   ├─ Fetch test images
   └─ Run tests against $DOCKER_HOST

4b. DinD Mode (default)
   └─ Call wrapper script

5. Wrapper Script (scripts/test/e2e/wrapper)
   ├─ Call run script with 'setup'
   ├─ Start Docker Compose environment
   │  ├─ Launch registry:3 service
   │  └─ Launch docker:${ENGINE_VERSION}-dind service
   ├─ Connect to test network
   ├─ Wait for daemon ready
   ├─ Load test images into daemon
   ├─ Initialize swarm if needed
   └─ Get engine host address

6. Test Execution
   ├─ Set environment variables (TEST_DOCKER_HOST, etc.)
   ├─ Run gotestsum -- ./e2e/... ${TESTFLAGS}
   └─ Execute Go tests

7. Cleanup
   ├─ Disconnect from test network
   └─ Docker Compose down
```

---

## Request/Command Flow

### Unit Test Flow

#### Container-Based Unit Tests

```
[Developer] → [docker buildx bake test] → [BuildKit] → [Dockerfile test stage] → [gotestsum] → [go test] → [Test Functions]
              │                                          │
              │                                          └─ Mounts: source code (bind), go cache, go pkg/mod
              └─ Uses docker-bake.hcl target definition
```

**Detailed Trace**:
1. **Entry**: Developer runs `docker buildx bake test`
2. **BuildKit Processing**:
   - Reads docker-bake.hcl
   - Finds `test` target
   - Builds Dockerfile to `test` stage
3. **Container Build**:
   - Base: golang:1.25.6-alpine
   - Install gotestsum binary
   - Mount source as bind mount (read-write)
   - Mount Go caches
4. **Test Execution**:
   - Run: `gotestsum -- -coverprofile=/tmp/coverage.txt $(go list ./... | grep -vE '/vendor/|/e2e/|/cmd/docker-trust')`
   - Package discovery via `go list`
   - Filter out vendor, e2e, docker-trust
5. **Test Run**:
   - For each package, execute test functions
   - Use FakeCli for mocking (internal/test/cli.go)
6. **Output**: Coverage written to /tmp/coverage.txt (cached in container)

#### Host-Based Unit Tests

```
[Developer] → [make test-unit] → [gotestsum] → [go test] → [Package Discovery] → [Test Execution]
                                   │
                                   └─ Respects TESTDIRS, TESTFLAGS env vars
```

**Detailed Trace**:
1. **Entry**: Developer runs `make test-unit`
2. **Makefile Expansion**:
   - Resolves `TESTDIRS` (default: `go list ./... | grep -vE ...`)
   - Resolves `TESTFLAGS`
3. **gotestsum Invocation**:
   - Formats test output
   - Calls `go test` with discovered packages
4. **go test**:
   - Compiles test binaries
   - Runs TestMain if present
   - Executes test functions
5. **Result**: Test output to stdout, coverage if requested

### E2E Test Flow

#### Full E2E Cycle (DinD Mode)

```
[Developer/CI] → [make test-e2e-local] → [build e2e image] → [docker run] → [entry script]
                                           │                                  │
                                           │                                  ├─ [wrapper script]
                                           │                                  │   ├─ [run setup]
                                           │                                  │   │   └─ Docker Compose up
                                           │                                  │   ├─ [run test]
                                           │                                  │   │   └─ gotestsum -- ./e2e/...
                                           │                                  │   └─ [run cleanup]
                                           │                                  │       └─ Docker Compose down
                                           │                                  │
                                           └─ Contains: CLI binary, plugins, test source, gotestsum
```

**Detailed Trace**:
1. **Entry**: `make -f docker.Makefile test-e2e-local`
2. **Image Build**: `docker buildx bake e2e-image`
   - Build CLI binary for target platform
   - Build test plugins
   - Install gotestsum, buildx plugin, compose plugin
   - Package everything into e2e image
3. **Container Start**:
   ```bash
   docker run --rm \
     --mount type=bind,src=./build/coverage,dst=/tmp/coverage \
     --mount type=bind,src=/var/run/docker.sock,dst=/var/run/docker.sock \
     docker-cli-e2e
   ```
4. **Entry Script**: `./scripts/test/e2e/entry`
   - Detects no REMOTE_DAEMON
   - Calls `./scripts/test/e2e/wrapper`
5. **Wrapper Orchestration**:
   - Calls `./scripts/test/e2e/run setup`
     - Starts `compose-env.yaml` services
     - registry:3 container
     - docker:${ENGINE_VERSION}-dind container
     - Connects e2e container to test network
     - Returns engine host address
   - Calls `./scripts/test/e2e/run test <engine_host>`
     - Sets TEST_DOCKER_HOST, TEST_REMOTE_DAEMON, etc.
     - Runs `gotestsum -- ./e2e/... ${TESTFLAGS}`
   - Calls `./scripts/test/e2e/run cleanup`
     - Tears down Compose environment
6. **Test Execution**:
   - gotestsum discovers e2e test packages
   - Each package's TestMain calls environment.Setup()
   - Tests execute against DinD daemon
   - Coverage written to /tmp/coverage

#### Remote Daemon Mode

```
[CI Environment] → [docker run e2e] → [entry script]
                    │ (REMOTE_DAEMON=1)  │
                    │                    ├─ [run fetch-images]
                    │                    └─ [run test $DOCKER_HOST]
                    │                        └─ gotestsum -- ./e2e/...
                    │
                    └─ Bind-mount: coverage output
```

---

## Handler Registration

### Unit Test Discovery

**Pattern**: Standard Go testing conventions
- **Location**: Any `*_test.go` file
- **Registration**: Automatic via Go toolchain

**Example Handler Signature**:
```go
func TestRunLabel(t *testing.T) {
    fakeCLI := test.NewFakeCli(&fakeClient{
        createContainerFunc: func(...) {...},
    })
    cmd := newRunCommand(fakeCLI)
    cmd.SetArgs([]string{"--detach=true", "--label", "foo", "busybox"})
    assert.NilError(t, cmd.Execute())
}
```

**FakeCli Factory** (internal/test/cli.go:37-56):
```go
func NewFakeCli(apiClient client.APIClient, opts ...func(*FakeCli)) *FakeCli {
    outBuffer := new(bytes.Buffer)
    errBuffer := new(bytes.Buffer)
    c := &FakeCli{
        client:    apiClient,
        out:       streams.NewOut(outBuffer),
        outBuffer: outBuffer,
        err:       streams.NewOut(errBuffer),
        errBuffer: errBuffer,
        in:        streams.NewIn(io.NopCloser(strings.NewReader(""))),
        configfile:     configfile.New(""),
        currentContext: command.DefaultContextName,
    }
    return c
}
```

### E2E Test Discovery

**Pattern**: Go testing with environment setup hook
- **Location**: `e2e/**/*_test.go`
- **Registration**: Via TestMain in each package

**TestMain Hook** (e2e/container/main_test.go):
```go
func TestMain(m *testing.M) {
    if err := environment.Setup(); err != nil {
        fmt.Println(err.Error())
        os.Exit(3)
    }
    os.Exit(m.Run())
}
```

---

## Extension Points

| Extension Type | Location | Purpose |
|---------------|----------|---------|
| **Test Variants** | docker.Makefile:131-145 | Add new e2e test modes (local, ssh, custom) |
| **Build Targets** | docker-bake.hcl | Define new test configurations |
| **Test Utilities** | internal/test/ | Extend FakeCli, add test helpers |
| **Environment Setup** | internal/test/environment/testenv.go | Add daemon capability checks, skip conditions |
| **CI Matrix** | .github/workflows/test.yml, e2e.yml | Expand platform/engine version coverage |
| **Docker Compose Env** | e2e/compose-env*.yaml | Modify test infrastructure services |
| **Test Filters** | Makefile, scripts | Customize package selection for tests |

### Key Extension Mechanisms

1. **Environment Variables**:
   - `TESTDIRS`: Filter test packages
   - `TESTFLAGS`: Pass flags to go test
   - `GOTESTSUM_FORMAT`: Control output format
   - `TEST_CONNHELPER`: E2E connection mode (ssh, etc.)
   - `ENGINE_VERSION`: Docker engine version for e2e
   - `BASE_VARIANT`: alpine vs debian base

2. **Build Variants**:
   - Platform matrix: 11 platforms (darwin/amd64, linux/arm64, etc.)
   - Base variants: alpine (default), debian (USE_GLIBC=1)
   - Link modes: static (default), dynamic

3. **Test Modes**:
   - **Unit**: Container-based (`docker buildx bake`) or host-based (`make test-unit`)
   - **E2E Local**: Tests against DinD (Docker-in-Docker)
   - **E2E SSH**: Tests via SSH connection helper
   - **E2E Remote**: Tests against existing daemon ($DOCKER_HOST)

---

## Call Graph Seeds

Key functions that serve as valuable starting points for deeper analysis:

### Testing Infrastructure

- **`environment.Setup`** at internal/test/environment/testenv.go:18
  - Why: Core e2e test initialization, sets up daemon connection
  - Dependencies: Configures DOCKER_HOST, TLS, test flags

- **`test.NewFakeCli`** at internal/test/cli.go:37
  - Why: Primary unit test mocking facility
  - Usage: Creates fake CLI with mock Docker client for testing commands

- **`runtests`** at scripts/test/e2e/run:60
  - Why: Main e2e test invocation function
  - Context: Sets environment, invokes gotestsum with proper flags

- **`setup`** at scripts/test/e2e/run:18
  - Why: E2E environment provisioning
  - Actions: Starts Docker Compose, configures networking, returns engine host

### Build and Orchestration

- **`binary` target** at Dockerfile:71-92
  - Why: Shows how CLI is built before testing
  - Context: Used by e2e tests to get testable binary

- **`test` stage** at Dockerfile:94-100
  - Why: Container-based unit test execution
  - Integration: How source mounting and caching work

### Test Helpers

- **`environment.SkipIfNotExperimentalDaemon`** at internal/test/environment/testenv.go:75
  - Why: Conditional test execution based on daemon capabilities
  - Pattern: Example of runtime environment detection

- **`environment.DaemonAPIVersion`** at internal/test/environment/testenv.go:113
  - Why: API version negotiation for compatibility testing

---

## CI/CD Pipeline Test Execution

### GitHub Actions Test Workflow (.github/workflows/test.yml)

**Two-Track Testing Strategy**:

#### Track 1: Container-Based (ubuntu-24.04)

```yaml
jobs:
  ctn:
    runs-on: ubuntu-24.04
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Test
        uses: docker/bake-action@v6
        with:
          targets: test-coverage
      - name: Send to Codecov
        uses: codecov/codecov-action@v5
        with:
          files: ./build/coverage/coverage.txt
```

**Flow**:
1. Setup BuildKit
2. Execute `docker buildx bake test-coverage`
3. BuildKit builds to `test-coverage` stage
4. Extracts coverage from container to `./build/coverage/coverage.txt`
5. Upload to Codecov

#### Track 2: Host-Based (macOS Intel/ARM)

```yaml
jobs:
  host:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os:
          - macos-14        # ARM (M1)
          - macos-15-intel  # Intel
          - macos-15        # ARM (M1)
    steps:
      - name: Test
        run: |
          ln -s vendor.mod go.mod
          ln -s vendor.sum go.sum
          go test -coverprofile=/tmp/coverage.txt $(go list ./... | grep -vE '^github.com/docker/cli/e2e/')
```

**Flow**:
1. Checkout to GOPATH structure
2. Setup Go 1.25.6
3. Create symlinks for go.mod/go.sum (vendor mode)
4. Run `go test` directly
5. Upload coverage

**Why Two Tracks?**
- Container track: Linux x86_64 testing with Docker BuildKit
- Host track: macOS native testing (Docker not available in Actions macOS runners)

### E2E Workflow (.github/workflows/e2e.yml)

**Matrix Strategy**:
```yaml
strategy:
  matrix:
    target: [local, connhelper-ssh]
    base: [alpine, debian]
    engine-version: [rc, 29, 28, 25]
```

**Total Combinations**: 2 × 2 × 4 = 16 test scenarios

**Execution Per Job**:
```yaml
steps:
  - name: Update daemon.json (enable experimental)
  - name: Set up Docker Buildx
  - name: Run ${{ matrix.target }}
    run: make -f docker.Makefile test-e2e-${{ matrix.target }}
    env:
      BASE_VARIANT: ${{ matrix.base }}
      ENGINE_VERSION: ${{ matrix.engine-version }}
      TESTFLAGS: -coverprofile=/tmp/coverage/coverage.txt
```

**Flow**:
1. Configure host Docker daemon (experimental mode)
2. Build e2e image with matrix parameters
3. Run e2e tests via docker.Makefile target
4. Collect coverage
5. Upload to Codecov

### Validation Workflow (.github/workflows/validate.yml)

**Test-Related Validation**:
```yaml
jobs:
  validate:
    matrix:
      target: [lint, shellcheck, validate-vendor, update-authors]
    steps:
      - name: Run
        uses: docker/bake-action@v6
        with:
          targets: ${{ matrix.target }}
```

**Additional Targets**:
- `lint`: golangci-lint via docker-bake.hcl:93-98
- `shellcheck`: Shell script validation via docker-bake.hcl:100-105

---

## Build Scripts and Variables

### Build Variables (.variables)

**File**: scripts/build/.variables

**Key Variables Set**:
- `VERSION`: Git describe or refs parsing
- `GITCOMMIT`: Short commit SHA
- `BUILDTIME`: RFC3339 timestamp
- `GOOS`, `GOARCH`, `GOARM`: Target platform
- `CGO_ENABLED`: Auto-detected based on platform
- `GO_LINKMODE`: static (default) or dynamic
- `GO_BUILDMODE`: -buildmode=pie for CGO builds
- `GO_LDFLAGS`: Version info, link flags
- `GO_BUILDTAGS`: Build tags (osusergo netgo for static CGO)
- `TARGET`: Output binary path
- `SOURCE`: github.com/docker/cli/cmd/docker

**Usage Context**: Sourced by scripts/build/binary and e2e test scripts

### Binary Build Script

**File**: scripts/build/binary

**Flow**:
```bash
#!/usr/bin/env sh
. ./scripts/build/.variables

# Windows: generate version info resource
if [ "$(go env GOOS)" = "windows" ]; then
    ./scripts/build/mkversioninfo
    go generate -v "${SOURCE}"
fi

# Build binary
go build -o "${TARGET}" -tags "${GO_BUILDTAGS}" -ldflags "${GO_LDFLAGS}" ${GO_BUILDMODE} "${SOURCE}"

# Create symlink
ln -sf "$(basename "${TARGET}")" "$(dirname "${TARGET}")/docker"
```

**Integration with Tests**:
- E2E tests require built binary in `build/` directory
- Binary built during Dockerfile `build` stage
- Copied into e2e stage for testing

---

## Test Environment Configuration

### Docker Compose Test Environment

**File**: e2e/compose-env.yaml

```yaml
services:
  registry:
    image: 'registry:3'

  engine:
    image: 'docker:${ENGINE_VERSION:-28}-dind'
    privileged: true
    command: ['--insecure-registry=registry:5000', '--experimental']
    environment:
      - DOCKER_TLS_CERTDIR=
```

**Purpose**:
- **registry**: Local Docker registry for image push/pull tests
- **engine**: Docker-in-Docker daemon for e2e tests

**Networking**:
- Creates `{PROJECT}_default` network
- E2E container connects to this network
- Tests access engine via `tcp://engine-ip:2375`

### SSH Connection Helper Variant

**File**: e2e/compose-env.connhelper-ssh.yaml

**Extension**: Adds SSH configuration for testing connection helpers

**Usage**: Activated when `TEST_CONNHELPER=ssh`

---

## Development Container

### Interactive Dev Container

**Entry Point**: `make -f docker.Makefile dev` or `make shell`

**Flow**:
```makefile
dev: build_docker_image
	$(DOCKER_RUN) -it \
		--mount type=bind,src=/var/run/docker.sock,dst=/var/run/docker.sock \
		$(DEV_DOCKER_IMAGE_NAME)
```

**Image**: dockerfiles/Dockerfile.dev
- Base: golang:1.25.6-alpine
- Includes: gotestsum, gofumpt, goversioninfo, buildx plugin
- Interactive bash with MOTD
- Source mounted at `/go/src/github.com/docker/cli`

**Inside Container**:
```bash
# Available commands
make test-unit     # Run unit tests
make lint          # Run linter
make binary        # Build binary
make fmt           # Format code
```

**Purpose**: Consistent development environment across platforms

---

## Special Testing Features

### Coverage Collection

**Unit Test Coverage**:
- **Container**: `-coverprofile=/tmp/coverage.txt` in Dockerfile
- **Host**: `-coverprofile=/tmp/coverage.txt` in Makefile
- **Output**: `build/coverage/coverage.txt` (extracted from container)

**E2E Coverage**:
- **Flag**: `TESTFLAGS=-coverprofile=/tmp/coverage/coverage.txt`
- **Collection**: Coverage from e2e tests (integration code paths)
- **Merge**: Combined with unit test coverage in CI

### Test Filtering

**Package Exclusions** (all test entry points):
```bash
grep -vE '/vendor/|/e2e/|/cmd/docker-trust'
```

**Rationale**:
- `/vendor/`: Third-party code (not tested)
- `/e2e/`: E2E tests (separate test suite)
- `/cmd/docker-trust`: Legacy plugin (separate build)

**Custom Filtering**:
```bash
# Test specific packages
TESTDIRS="./cli/command/container ./cli/command/image" make test-unit

# Test with specific flags
TESTFLAGS="-v -run TestRun" make test-unit
```

### Parallel Test Execution

**Default**: Go test runs tests in parallel within package
**Control**: Use `TESTFLAGS=-p N` to limit parallelism

**CI Strategy**: Matrix parallelism across jobs, not within tests

---

## Summary

The Docker CLI testing infrastructure is a sophisticated, multi-layered system with:

1. **Dual Test Modes**: Container-based (preferred, reproducible) and host-based (macOS support)
2. **Three Test Levels**: Unit tests (go test), E2E tests (full integration), validation (lint/shellcheck)
3. **Flexible Execution**: Make targets, docker buildx bake, direct go test, CI workflows
4. **Comprehensive Coverage**: 16 e2e scenarios (2 targets × 2 bases × 4 engine versions)
5. **Developer-Friendly**: Interactive dev container, flexible test filtering, fast feedback
6. **CI-Optimized**: Parallel matrix execution, coverage aggregation, multi-platform testing

**Key Testing Principles**:
- Container-first for reproducibility
- Extensive mocking via FakeCli for unit tests
- Real daemon integration for e2e tests
- Version matrix testing for compatibility
- Coverage-driven quality metrics
